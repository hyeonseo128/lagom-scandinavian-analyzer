<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>스칸디나비아 디자인 정량화 연구 분석기</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f8f9fa;
            line-height: 1.6;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px 0;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
            font-weight: 400;
        }

        .header .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            margin-bottom: 20px;
        }

        .keywords {
            font-size: 0.9rem;
            opacity: 0.8;
            font-style: italic;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .research-phases {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .phase-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            border-left: 4px solid #3498db;
            transition: transform 0.2s ease;
        }

        .phase-card:hover {
            transform: translateY(-2px);
        }

        .phase-card.active {
            border-left-color: #e74c3c;
            background: linear-gradient(135deg, #fff 0%, #f8f9ff 100%);
        }

        .phase-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }

        .phase-number {
            background: #3498db;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
            font-weight: bold;
        }

        .upload-sections {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .upload-group {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }

        .upload-group.experimental {
            border-top: 4px solid #27ae60;
        }

        .upload-group.control {
            border-top: 4px solid #e67e22;
        }

        .group-title {
            font-size: 1.4rem;
            font-weight: 600;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }

        .group-icon {
            margin-right: 10px;
            font-size: 1.5rem;
        }

        .upload-area {
            border: 2px dashed #bdc3c7;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #fafbfc;
        }

        .upload-area:hover {
            border-color: #3498db;
            background: #f8f9ff;
        }

        .upload-area.dragover {
            border-color: #2ecc71;
            background: #f0fff4;
            transform: scale(1.02);
        }

        .upload-btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            margin: 10px 5px;
            transition: all 0.3s ease;
        }

        .upload-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }

        .upload-btn.clear {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .upload-btn.clear:hover {
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
        }

        .image-count {
            margin-top: 15px;
            font-weight: 600;
            color: #2c3e50;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .count-badge {
            background: #ecf0f1;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.9rem;
        }

        .analysis-section {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }

        .analysis-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .analyze-btn {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .analyze-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(39, 174, 96, 0.3);
        }

        .analyze-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .progress-container {
            background: #ecf0f1;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: #d5dbdb;
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            transition: width 0.3s ease;
            border-radius: 6px;
        }

        .progress-text {
            text-align: center;
            font-weight: 600;
            color: #2c3e50;
        }

        .results-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 30px;
        }

        .results-card {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 25px;
            border-left: 4px solid #3498db;
        }

        .results-card.experimental {
            border-left-color: #27ae60;
        }

        .results-card.control {
            border-left-color: #e67e22;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .stat-label {
            font-size: 0.9rem;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #2c3e50;
        }

        .statistical-analysis {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }

        .significance-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .significance-table th,
        .significance-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ecf0f1;
        }

        .significance-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #2c3e50;
        }

        .significant {
            color: #27ae60;
            font-weight: bold;
        }

        .not-significant {
            color: #e74c3c;
        }

        .chart-container {
            margin: 20px 0;
            text-align: center;
        }

        .chart-controls {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .chart-selector, .metric-selector {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .chart-selector label, .metric-selector label {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9rem;
        }

        .chart-selector select, .metric-selector select {
            padding: 8px 15px;
            border: 2px solid #bdc3c7;
            border-radius: 6px;
            background: white;
            font-size: 0.9rem;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }

        .chart-selector select:focus, .metric-selector select:focus {
            outline: none;
            border-color: #3498db;
        }

        .chart-canvas {
            max-width: 100%;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            background: white;
            margin: 20px 0;
        }

        .chart-description {
            background: #f8f9ff;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            color: #2c3e50;
            font-size: 0.9rem;
            line-height: 1.5;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .research-report {
            background: white;
            border-radius: 12px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            line-height: 1.8;
        }

        .report-section {
            margin-bottom: 30px;
        }

        .report-section h3 {
            color: #2c3e50;
            font-size: 1.4rem;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #ecf0f1;
        }

        .export-controls {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            margin-top: 20px;
        }

        .export-btn {
            background: linear-gradient(135deg, #8e44ad 0%, #9b59b6 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 6px;
            margin: 0 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .export-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(142, 68, 173, 0.3);
        }

        @media (max-width: 768px) {
            .upload-sections,
            .results-grid {
                grid-template-columns: 1fr;
            }
            
            .analysis-controls {
                flex-direction: column;
            }
        }

        .methodology-info {
            background: #e8f5e8;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            border-left: 4px solid #27ae60;
        }

        .warning-box {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            color: #856404;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>스칸디나비아 디자인의 시각적 특징 정량화 연구</h1>
        <div class="subtitle">'라곰(Lagom)'의 미학을 중심으로 한 프로그래밍 기반 융합 탐구</div>
        <div class="keywords">
            Keywords: Scandinavian Design, Lagom, Computer Vision, Image Analysis, Data Science, Quantification
        </div>
    </div>

    <div class="container">
        <!-- 연구 단계 설명 -->
        <div class="research-phases">
            <div class="phase-card active">
                <div class="phase-title">
                    <span class="phase-number">1</span>
                    데이터셋 구축
                </div>
                <p>실험군(스칸디나비아 디자인)과 대조군(바로크 등 화려한 스타일)의 이미지를 체계적으로 수집하여 비교 분석을 위한 데이터베이스를 구축합니다.</p>
            </div>
            <div class="phase-card">
                <div class="phase-title">
                    <span class="phase-number">2</span>
                    정량적 분석
                </div>
                <p>색상(채도, 명도, 다양성), 공간(여백 비율), 복잡성(엣지 밀도) 등의 객관적 지표를 통해 디자인 특성을 수치화합니다.</p>
            </div>
            <div class="phase-card">
                <div class="phase-title">
                    <span class="phase-number">3</span>
                    통계적 검증
                </div>
                <p>t-test를 통해 두 그룹 간의 차이가 통계적으로 유의미한지 검증하여 가설의 타당성을 과학적으로 입증합니다.</p>
            </div>
            <div class="phase-card">
                <div class="phase-title">
                    <span class="phase-number">4</span>
                    연구 보고서
                </div>
                <p>분석 결과를 학술적 형태의 연구 보고서로 정리하여 문화적 미학의 데이터 과학적 해석 사례를 제시합니다.</p>
            </div>
        </div>

        <!-- 이미지 업로드 섹션 -->
        <div class="upload-sections">
            <div class="upload-group experimental">
                <div class="group-title">
                    <span class="group-icon">🇸🇪</span>
                    실험군: 스칸디나비아 디자인
                </div>
                <div class="methodology-info">
                    <strong>수집 대상:</strong> 스웨덴 현지 인테리어, 건축, 공공디자인, IKEA 등 스칸디나비아 브랜드 제품 이미지
                </div>
                <div class="upload-area" id="experimentalUpload">
                    <p>📷 스칸디나비아 디자인 이미지를 업로드하세요</p>
                    <p style="font-size: 0.9rem; color: #7f8c8d; margin-top: 10px;">
                        드래그 앤 드롭 또는 클릭하여 여러 이미지 선택
                    </p>
                    <input type="file" id="experimentalInput" multiple accept="image/*" style="display: none;">
                    <button class="upload-btn" onclick="document.getElementById('experimentalInput').click()">
                        이미지 선택
                    </button>
                    <button class="upload-btn clear" onclick="clearGroup('experimental')">
                        초기화
                    </button>
                </div>
                <div class="image-count">
                    <span>업로드된 이미지:</span>
                    <span class="count-badge" id="experimentalCount">0장</span>
                </div>
            </div>

            <div class="upload-group control">
                <div class="group-title">
                    <span class="group-icon">🏛️</span>
                    대조군: 비교 문화권 디자인
                </div>
                <div class="methodology-info">
                    <strong>수집 대상:</strong> 바로크, 로코코, 빅토리아 시대 등 화려하고 장식적인 예술 작품 및 디자인 이미지
                </div>
                <div class="upload-area" id="controlUpload">
                    <p>🎨 화려한 스타일의 비교 이미지를 업로드하세요</p>
                    <p style="font-size: 0.9rem; color: #7f8c8d; margin-top: 10px;">
                        스칸디나비아 디자인과 대조되는 복잡하고 장식적인 이미지
                    </p>
                    <input type="file" id="controlInput" multiple accept="image/*" style="display: none;">
                    <button class="upload-btn" onclick="document.getElementById('controlInput').click()">
                        이미지 선택
                    </button>
                    <button class="upload-btn clear" onclick="clearGroup('control')">
                        초기화
                    </button>
                </div>
                <div class="image-count">
                    <span>업로드된 이미지:</span>
                    <span class="count-badge" id="controlCount">0장</span>
                </div>
            </div>
        </div>

        <!-- 분석 실행 섹션 -->
        <div class="analysis-section">
            <h3>📊 정량적 분석 실행</h3>
            <div class="warning-box">
                <strong>⚠️ 연구 조건:</strong> 각 그룹당 최소 10장 이상의 이미지가 필요합니다. 더 많은 이미지일수록 통계적으로 신뢰성 있는 결과를 얻을 수 있습니다.
            </div>
            
            <div class="analysis-controls">
                <button class="analyze-btn" id="analyzeBtn" onclick="startAnalysis()" disabled>
                    🔬 분석 시작
                </button>
                <button class="export-btn" onclick="exportResults()" disabled id="exportBtn">
                    📄 결과 내보내기
                </button>
            </div>

            <div class="progress-container" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">분석 준비 중...</div>
            </div>
        </div>

        <!-- 분석 결과 섹션 -->
        <div class="results-grid" id="resultsGrid" style="display: none;">
            <div class="results-card experimental">
                <h3>🇸🇪 스칸디나비아 디자인 분석 결과</h3>
                <div class="stats-grid" id="experimentalStats">
                    <!-- 통계 항목들이 동적으로 생성됩니다 -->
                </div>
            </div>
            <div class="results-card control">
                <h3>🏛️ 비교 문화권 디자인 분석 결과</h3>
                <div class="stats-grid" id="controlStats">
                    <!-- 통계 항목들이 동적으로 생성됩니다 -->
                </div>
            </div>
        </div>

        <!-- 통계적 검증 결과 -->
        <div class="statistical-analysis" id="statisticalAnalysis" style="display: none;">
            <h3>📈 통계적 유의성 검증 (t-test)</h3>
            <div class="methodology-info">
                <strong>검증 방법:</strong> 독립표본 t-검정 (Independent Samples t-test)<br>
                <strong>유의수준:</strong> α = 0.05 (p-value < 0.05일 때 통계적으로 유의미함)
            </div>
            <table class="significance-table" id="significanceTable">
                <thead>
                    <tr>
                        <th>분석 지표</th>
                        <th>스칸디나비아 평균</th>
                        <th>대조군 평균</th>
                        <th>차이율 (%)</th>
                        <th>p-value</th>
                        <th>통계적 유의성</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- 결과가 동적으로 생성됩니다 -->
                </tbody>
            </table>
        </div>

        <!-- 시각화 차트 -->
        <div class="chart-container" id="chartContainer" style="display: none;">
            <h3>📊 비교 분석 시각화</h3>
            
            <!-- 차트 유형 선택 -->
            <div class="chart-controls">
                <div class="chart-selector">
                    <label for="chartType">차트 유형:</label>
                    <select id="chartType">
                        <option value="bar">막대 그래프</option>
                        <option value="boxplot">박스 플롯</option>
                        <option value="scatter">산점도</option>
                        <option value="histogram">히스토그램</option>
                        <option value="radar">레이더 차트</option>
                    </select>
                </div>
                
                <div class="metric-selector" id="metricSelector" style="display: none;">
                    <label for="selectedMetric">분석 지표:</label>
                    <select id="selectedMetric">
                        <option value="saturation">평균 채도</option>
                        <option value="brightness">평균 명도</option>
                        <option value="colordiversity">색상 다양성</option>
                        <option value="negativespace">여백 비율</option>
                        <option value="edgedensity">엣지 밀도</option>
                        <option value="texturecomplexity">텍스처 복잡성</option>
                        <option value="symmetry">대칭성</option>
                    </select>
                </div>
                
                <button class="upload-btn" onclick="exportChart()">
                    💾 차트 저장
                </button>
            </div>
            
            <canvas id="comparisonChart" class="chart-canvas" width="900" height="500"></canvas>
            
            <!-- 차트 설명 -->
            <div class="chart-description" id="chartDescription">
                차트 유형을 선택하여 데이터를 시각화해보세요.
            </div>
        </div>

        <!-- 연구 보고서 -->
        <div class="research-report" id="researchReport" style="display: none;">
            <h2>연구 결과 보고서</h2>
            
            <div class="report-section">
                <h3>1. 연구 목적 및 방법</h3>
                <p>본 연구는 스칸디나비아 디자인의 핵심 개념인 '라곰(Lagom)'을 컴퓨터 비전 기술을 통해 정량화하고, 타 문화권의 시각 예술과 객관적으로 비교 분석하는 것을 목적으로 한다. 이미지 분석 알고리즘을 활용하여 색상, 공간, 복잡성 등의 시각적 특징을 수치화하고, 통계적 검증을 통해 그 차이의 유의미성을 검증하였다.</p>
            </div>

            <div class="report-section">
                <h3>2. 주요 연구 결과</h3>
                <div id="keyFindings">
                    <!-- 주요 발견사항이 동적으로 생성됩니다 -->
                </div>
            </div>

            <div class="report-section">
                <h3>3. 결론 및 의의</h3>
                <div id="conclusions">
                    <!-- 결론이 동적으로 생성됩니다 -->
                </div>
            </div>

            <div class="export-controls">
                <button class="export-btn" onclick="exportPDF()">📑 PDF 보고서 다운로드</button>
                <button class="export-btn" onclick="exportCSV()">📊 원시 데이터 CSV 다운로드</button>
                <button class="export-btn" onclick="exportChart()">📈 차트 이미지 다운로드</button>
            </div>
        </div>
    </div>

    <script>
        class ScandinavianDesignResearcher {
            constructor() {
                this.experimentalImages = [];
                this.controlImages = [];
                this.analysisResults = null;
                this.setupEventListeners();
            }

            setupEventListeners() {
                // 실험군 이미지 업로드
                const experimentalInput = document.getElementById('experimentalInput');
                const experimentalUpload = document.getElementById('experimentalUpload');

                experimentalInput.addEventListener('change', (e) => {
                    this.handleImageUpload(e.target.files, 'experimental');
                });

                this.setupDragAndDrop(experimentalUpload, experimentalInput, 'experimental');

                // 대조군 이미지 업로드
                const controlInput = document.getElementById('controlInput');
                const controlUpload = document.getElementById('controlUpload');

                controlInput.addEventListener('change', (e) => {
                    this.handleImageUpload(e.target.files, 'control');
                });

                this.setupDragAndDrop(controlUpload, controlInput, 'control');
            }

            setupDragAndDrop(uploadArea, input, groupType) {
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });

                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });

                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    this.handleImageUpload(e.dataTransfer.files, groupType);
                });
            }

            async handleImageUpload(files, groupType) {
                const imageArray = groupType === 'experimental' ? this.experimentalImages : this.controlImages;
                
                for (const file of files) {
                    if (file.type.startsWith('image/')) {
                        try {
                            const image = await this.loadImage(file);
                            const analysisData = await this.preprocessImage(image, file.name);
                            imageArray.push(analysisData);
                        } catch (error) {
                            console.error('이미지 로드 오류:', error);
                        }
                    }
                }

                this.updateImageCount(groupType);
                this.checkAnalysisReady();
            }

            loadImage(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.onerror = reject;
                        img.src = e.target.result;
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            async preprocessImage(image, filename) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // 표준 크기로 조정 (512x512)
                canvas.width = 512;
                canvas.height = 512;
                ctx.drawImage(image, 0, 0, 512, 512);
                
                const imageData = ctx.getImageData(0, 0, 512, 512);
                
                return {
                    filename: filename,
                    imageData: imageData,
                    canvas: canvas
                };
            }

            updateImageCount(groupType) {
                const count = groupType === 'experimental' ? this.experimentalImages.length : this.controlImages.length;
                const countElement = document.getElementById(groupType + 'Count');
                countElement.textContent = `${count}장`;
            }

            checkAnalysisReady() {
                const analyzeBtn = document.getElementById('analyzeBtn');
                const ready = this.experimentalImages.length >= 3 && this.controlImages.length >= 3;
                analyzeBtn.disabled = !ready;
            }

            async startAnalysis() {
                const progressContainer = document.getElementById('progressContainer');
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');

                progressContainer.style.display = 'block';
                
                try {
                    // 1. 실험군 분석
                    progressText.textContent = '실험군(스칸디나비아) 이미지 분석 중...';
                    progressFill.style.width = '25%';
                    
                    const experimentalResults = await this.analyzeImageGroup(this.experimentalImages);
                    
                    // 2. 대조군 분석
                    progressText.textContent = '대조군(비교 문화권) 이미지 분석 중...';
                    progressFill.style.width = '50%';
                    
                    const controlResults = await this.analyzeImageGroup(this.controlImages);
                    
                    // 3. 통계 분석
                    progressText.textContent = '통계적 검증 수행 중...';
                    progressFill.style.width = '75%';
                    
                    const statisticalResults = this.performStatisticalAnalysis(experimentalResults, controlResults);
                    
                    // 4. 결과 표시
                    progressText.textContent = '결과 생성 중...';
                    progressFill.style.width = '100%';
                    
                    this.analysisResults = {
                        experimental: experimentalResults,
                        control: controlResults,
                        statistical: statisticalResults
                    };
                    
                    this.displayResults();
                    
                    progressText.textContent = '분석 완료!';
                    setTimeout(() => {
                        progressContainer.style.display = 'none';
                    }, 2000);
                    
                } catch (error) {
                    console.error('분석 오류:', error);
                    progressText.textContent = '분석 중 오류가 발생했습니다.';
                }
            }

            async analyzeImageGroup(images) {
                const results = {
                    images: [],
                    aggregated: {
                        avgSaturation: 0,
                        avgBrightness: 0,
                        avgColorDiversity: 0,
                        avgNegativeSpace: 0,
                        avgEdgeDensity: 0,
                        avgTextureComplexity: 0,
                        avgSymmetry: 0
                    }
                };

                // 각 이미지 분석
                for (const imageData of images) {
                    const analysis = this.analyzeImage(imageData.imageData);
                    results.images.push({
                        filename: imageData.filename,
                        ...analysis
                    });
                }

                // 평균값 계산
                const metrics = ['avgSaturation', 'avgBrightness', 'avgColorDiversity', 
                               'avgNegativeSpace', 'avgEdgeDensity', 'avgTextureComplexity', 'avgSymmetry'];
                
                metrics.forEach(metric => {
                    const key = metric.replace('avg', '').toLowerCase();
                    const values = results.images.map(img => img[key] || 0);
                    results.aggregated[metric] = values.reduce((sum, val) => sum + val, 0) / values.length;
                });

                return results;
            }

            analyzeImage(imageData) {
                const pixels = imageData.data;
                const width = imageData.width;
                const height = imageData.height;

                // 색상 분석
                const colorAnalysis = this.analyzeColors(pixels);
                
                // 공간 분석
                const spaceAnalysis = this.analyzeSpace(pixels, width, height);
                
                // 복잡성 분석
                const complexityAnalysis = this.analyzeComplexity(pixels, width, height);

                return {
                    saturation: colorAnalysis.avgSaturation,
                    brightness: colorAnalysis.avgBrightness,
                    colordiversity: colorAnalysis.colorDiversity,
                    negativespace: spaceAnalysis.negativeSpaceRatio,
                    edgedensity: complexityAnalysis.edgeDensity,
                    texturecomplexity: complexityAnalysis.textureComplexity,
                    symmetry: spaceAnalysis.symmetryScore
                };
            }

            analyzeColors(pixels) {
                const colors = [];
                
                // 픽셀 샘플링
                for (let i = 0; i < pixels.length; i += 16) {
                    const r = pixels[i];
                    const g = pixels[i + 1];
                    const b = pixels[i + 2];
                    
                    if (r !== undefined && g !== undefined && b !== undefined) {
                        colors.push([r, g, b]);
                    }
                }

                // 주요 색상 추출
                const dominantColors = this.extractDominantColors(colors, 5);
                
                // HSV 변환 및 분석
                const hsvColors = dominantColors.map(color => this.rgbToHsv(color));
                
                const avgSaturation = hsvColors.reduce((sum, hsv) => sum + hsv[1], 0) / hsvColors.length;
                const avgBrightness = hsvColors.reduce((sum, hsv) => sum + hsv[2], 0) / hsvColors.length;
                const colorDiversity = this.calculateColorDiversity(dominantColors);

                return {
                    avgSaturation,
                    avgBrightness,
                    colorDiversity
                };
            }

            extractDominantColors(colors, numColors) {
                if (colors.length === 0) return [];
                
                // 간단한 K-means 구현
                const centroids = [];
                for (let i = 0; i < numColors; i++) {
                    centroids.push(colors[Math.floor(Math.random() * colors.length)]);
                }
                
                for (let iter = 0; iter < 10; iter++) {
                    const clusters = Array(numColors).fill().map(() => []);
                    
                    colors.forEach(color => {
                        let minDist = Infinity;
                        let closestCentroid = 0;
                        
                        centroids.forEach((centroid, idx) => {
                            const dist = this.colorDistance(color, centroid);
                            if (dist < minDist) {
                                minDist = dist;
                                closestCentroid = idx;
                            }
                        });
                        
                        clusters[closestCentroid].push(color);
                    });
                    
                    clusters.forEach((cluster, idx) => {
                        if (cluster.length > 0) {
                            const newCentroid = [
                                cluster.reduce((sum, c) => sum + c[0], 0) / cluster.length,
                                cluster.reduce((sum, c) => sum + c[1], 0) / cluster.length,
                                cluster.reduce((sum, c) => sum + c[2], 0) / cluster.length
                            ];
                            centroids[idx] = newCentroid;
                        }
                    });
                }
                
                return centroids;
            }

            colorDistance(color1, color2) {
                return Math.sqrt(
                    Math.pow(color1[0] - color2[0], 2) +
                    Math.pow(color1[1] - color2[1], 2) +
                    Math.pow(color1[2] - color2[2], 2)
                );
            }

            rgbToHsv([r, g, b]) {
                r /= 255;
                g /= 255;
                b /= 255;
                
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const diff = max - min;
                
                let h = 0;
                let s = max === 0 ? 0 : diff / max;
                let v = max;
                
                if (diff !== 0) {
                    switch (max) {
                        case r: h = ((g - b) / diff) % 6; break;
                        case g: h = (b - r) / diff + 2; break;
                        case b: h = (r - g) / diff + 4; break;
                    }
                    h /= 6;
                }
                
                if (h < 0) h += 1;
                
                return [h, s, v];
            }

            calculateColorDiversity(colors) {
                if (colors.length <= 1) return 0;
                
                let totalDistance = 0;
                let comparisons = 0;
                
                for (let i = 0; i < colors.length; i++) {
                    for (let j = i + 1; j < colors.length; j++) {
                        totalDistance += this.colorDistance(colors[i], colors[j]);
                        comparisons++;
                    }
                }
                
                return comparisons > 0 ? (totalDistance / comparisons) / 441.67 : 0;
            }

            analyzeSpace(pixels, width, height) {
                const grayscale = this.convertToGrayscale(pixels, width, height);
                const edges = this.detectEdges(grayscale, width, height);
                
                const totalPixels = width * height;
                const edgePixels = edges.reduce((sum, pixel) => sum + (pixel > 128 ? 1 : 0), 0);
                const negativeSpaceRatio = Math.max(0, (totalPixels - edgePixels * 3) / totalPixels);
                
                const symmetryScore = this.calculateSymmetry(grayscale, width, height);
                
                return {
                    negativeSpaceRatio,
                    symmetryScore
                };
            }

            convertToGrayscale(pixels, width, height) {
                const grayscale = [];
                for (let i = 0; i < pixels.length; i += 4) {
                    const gray = pixels[i] * 0.299 + pixels[i + 1] * 0.587 + pixels[i + 2] * 0.114;
                    grayscale.push(gray);
                }
                return grayscale;
            }

            detectEdges(grayscale, width, height) {
                const edges = new Array(grayscale.length).fill(0);
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = y * width + x;
                        
                        const gx = (
                            grayscale[idx - width - 1] * -1 + grayscale[idx - width + 1] * 1 +
                            grayscale[idx - 1] * -2 + grayscale[idx + 1] * 2 +
                            grayscale[idx + width - 1] * -1 + grayscale[idx + width + 1] * 1
                        );
                        
                        const gy = (
                            grayscale[idx - width - 1] * -1 + grayscale[idx - width] * -2 + grayscale[idx - width + 1] * -1 +
                            grayscale[idx + width - 1] * 1 + grayscale[idx + width] * 2 + grayscale[idx + width + 1] * 1
                        );
                        
                        edges[idx] = Math.sqrt(gx * gx + gy * gy);
                    }
                }
                
                return edges;
            }

            calculateSymmetry(grayscale, width, height) {
                const halfWidth = Math.floor(width / 2);
                let totalDiff = 0;
                let comparisons = 0;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < halfWidth; x++) {
                        const leftIdx = y * width + x;
                        const rightIdx = y * width + (width - 1 - x);
                        
                        if (leftIdx < grayscale.length && rightIdx < grayscale.length) {
                            totalDiff += Math.abs(grayscale[leftIdx] - grayscale[rightIdx]);
                            comparisons++;
                        }
                    }
                }
                
                return comparisons > 0 ? 1 - (totalDiff / comparisons) / 255 : 0;
            }

            analyzeComplexity(pixels, width, height) {
                const grayscale = this.convertToGrayscale(pixels, width, height);
                const edges = this.detectEdges(grayscale, width, height);
                
                const totalPixels = edges.length;
                const edgePixels = edges.reduce((sum, pixel) => sum + (pixel > 50 ? 1 : 0), 0);
                const edgeDensity = edgePixels / totalPixels;
                
                const mean = grayscale.reduce((sum, val) => sum + val, 0) / grayscale.length;
                const variance = grayscale.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / grayscale.length;
                const textureComplexity = Math.sqrt(variance) / 255;
                
                return {
                    edgeDensity,
                    textureComplexity
                };
            }

            performStatisticalAnalysis(experimentalResults, controlResults) {
                const metrics = ['avgSaturation', 'avgBrightness', 'avgColorDiversity', 
                               'avgNegativeSpace', 'avgEdgeDensity', 'avgTextureComplexity', 'avgSymmetry'];
                
                const results = {};
                
                metrics.forEach(metric => {
                    const expData = experimentalResults.images.map(img => {
                        const key = metric.replace('avg', '').toLowerCase();
                        return img[key] || 0;
                    });
                    
                    const ctrlData = controlResults.images.map(img => {
                        const key = metric.replace('avg', '').toLowerCase();
                        return img[key] || 0;
                    });
                    
                    const expMean = expData.reduce((sum, val) => sum + val, 0) / expData.length;
                    const ctrlMean = ctrlData.reduce((sum, val) => sum + val, 0) / ctrlData.length;
                    
                    const ttest = this.performTTest(expData, ctrlData);
                    
                    results[metric] = {
                        experimentalMean: expMean,
                        controlMean: ctrlMean,
                        difference: ((expMean - ctrlMean) / ctrlMean) * 100,
                        tStatistic: ttest.tStat,
                        pValue: ttest.pValue,
                        significant: ttest.pValue < 0.05
                    };
                });
                
                return results;
            }

            performTTest(group1, group2) {
                const n1 = group1.length;
                const n2 = group2.length;
                
                const mean1 = group1.reduce((sum, val) => sum + val, 0) / n1;
                const mean2 = group2.reduce((sum, val) => sum + val, 0) / n2;
                
                const var1 = group1.reduce((sum, val) => sum + Math.pow(val - mean1, 2), 0) / (n1 - 1);
                const var2 = group2.reduce((sum, val) => sum + Math.pow(val - mean2, 2), 0) / (n2 - 1);
                
                const pooledVar = ((n1 - 1) * var1 + (n2 - 1) * var2) / (n1 + n2 - 2);
                const standardError = Math.sqrt(pooledVar * (1/n1 + 1/n2));
                
                const tStat = (mean1 - mean2) / standardError;
                
                // 간단한 p-value 추정 (정확한 계산을 위해서는 t-분포 테이블 필요)
                const df = n1 + n2 - 2;
                let pValue;
                
                if (Math.abs(tStat) > 2.576) pValue = 0.01;
                else if (Math.abs(tStat) > 1.96) pValue = 0.05;
                else if (Math.abs(tStat) > 1.645) pValue = 0.10;
                else pValue = 0.20;
                
                return { tStat, pValue };
            }

            displayResults() {
                this.displayGroupStats();
                this.displayStatisticalSignificance();
                this.generateResearchReport();
                
                // 직접 차트 그리기
                this.drawChart();
                
                document.getElementById('resultsGrid').style.display = 'grid';
                document.getElementById('statisticalAnalysis').style.display = 'block';
                document.getElementById('chartContainer').style.display = 'block';
                document.getElementById('researchReport').style.display = 'block';
                document.getElementById('exportBtn').disabled = false;
            }

            drawChart() {
                const canvas = document.getElementById('comparisonChart');
                const ctx = canvas ? canvas.getContext('2d') : null;
                
                if (!canvas || !ctx) {
                    console.error('캔버스를 찾을 수 없습니다.');
                    return;
                }
                
                console.log('차트 그리기 시작');
                
                // 차트 컨트롤 설정
                this.setupSimpleChartControls();
                
                // 기본 막대 차트 그리기
                this.updateSimpleChart();
            }

            setupSimpleChartControls() {
                const chartTypeSelect = document.getElementById('chartType');
                
                if (chartTypeSelect) {
                    // 기존 이벤트 리스너 제거
                    chartTypeSelect.onchange = null;
                    
                    // 새 이벤트 리스너 추가
                    chartTypeSelect.addEventListener('change', () => {
                        this.updateSimpleChart();
                    });
                    
                    console.log('차트 컨트롤 설정 완료');
                }
            }

            updateSimpleChart() {
                const chartType = document.getElementById('chartType')?.value || 'bar';
                const canvas = document.getElementById('comparisonChart');
                const ctx = canvas ? canvas.getContext('2d') : null;
                
                if (!canvas || !ctx) {
                    console.error('캔버스를 찾을 수 없습니다.');
                    return;
                }
                
                // 캔버스 초기화
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 데이터 준비
                const metrics = ['채도', '명도', '색상다양성', '여백비율', '엣지밀도', '텍스처복잡성', '대칭성'];
                const expData = [
                    this.analysisResults.experimental.aggregated.avgSaturation || 0,
                    this.analysisResults.experimental.aggregated.avgBrightness || 0,
                    this.analysisResults.experimental.aggregated.avgColorDiversity || 0,
                    this.analysisResults.experimental.aggregated.avgNegativeSpace || 0,
                    this.analysisResults.experimental.aggregated.avgEdgeDensity || 0,
                    this.analysisResults.experimental.aggregated.avgTextureComplexity || 0,
                    this.analysisResults.experimental.aggregated.avgSymmetry || 0
                ];
                
                const ctrlData = [
                    this.analysisResults.control.aggregated.avgSaturation || 0,
                    this.analysisResults.control.aggregated.avgBrightness || 0,
                    this.analysisResults.control.aggregated.avgColorDiversity || 0,
                    this.analysisResults.control.aggregated.avgNegativeSpace || 0,
                    this.analysisResults.control.aggregated.avgEdgeDensity || 0,
                    this.analysisResults.control.aggregated.avgTextureComplexity || 0,
                    this.analysisResults.control.aggregated.avgSymmetry || 0
                ];
                
                // 차트 타입에 따라 그리기
                switch(chartType) {
                    case 'bar':
                        this.drawSimpleBarChart(ctx, canvas, metrics, expData, ctrlData);
                        break;
                    case 'boxplot':
                        this.drawSimpleBoxPlot(ctx, canvas);
                        break;
                    case 'scatter':
                        this.drawSimpleScatter(ctx, canvas);
                        break;
                    case 'histogram':
                        this.drawSimpleHistogram(ctx, canvas);
                        break;
                    case 'radar':
                        this.drawSimpleRadar(ctx, canvas, metrics, expData, ctrlData);
                        break;
                    default:
                        this.drawSimpleBarChart(ctx, canvas, metrics, expData, ctrlData);
                }
            }

            drawSimpleBoxPlot(ctx, canvas) {
                // 개별 지표 선택 표시
                const metricSelector = document.getElementById('metricSelector');
                if (metricSelector) {
                    metricSelector.style.display = 'flex';
                }
                
                const selectedMetric = document.getElementById('selectedMetric')?.value || 'saturation';
                const metricKey = selectedMetric.replace('avg', '').toLowerCase();
                
                // 데이터 추출
                const expValues = this.analysisResults.experimental.images.map(img => img[metricKey] || 0).filter(val => val > 0);
                const ctrlValues = this.analysisResults.control.images.map(img => img[metricKey] || 0).filter(val => val > 0);
                
                if (expValues.length === 0 || ctrlValues.length === 0) {
                    ctx.fillStyle = '#e74c3c';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('데이터가 부족합니다', canvas.width / 2, canvas.height / 2);
                    return;
                }
                
                // 박스플롯 통계 계산
                const expStats = this.calculateBoxStats(expValues);
                const ctrlStats = this.calculateBoxStats(ctrlValues);
                
                const allValues = [...expValues, ...ctrlValues];
                const minVal = Math.min(...allValues);
                const maxVal = Math.max(...allValues);
                const range = maxVal - minVal;
                
                const padding = 80;
                const chartHeight = canvas.height - 2 * padding;
                const boxWidth = 80;
                const centerX1 = canvas.width / 3;
                const centerX2 = (canvas.width * 2) / 3;
                
                // 배경
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Y축 그리기
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, padding + chartHeight);
                ctx.stroke();
                
                // Y축 눈금과 격자
                for (let i = 0; i <= 5; i++) {
                    const y = padding + chartHeight - (chartHeight * i / 5);
                    const value = minVal + (range * i / 5);
                    
                    // 격자선
                    ctx.strokeStyle = '#ecf0f1';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(canvas.width - padding, y);
                    ctx.stroke();
                    
                    // 라벨
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText(value.toFixed(3), padding - 10, y + 3);
                }
                
                // 박스플롯 그리기
                this.drawSingleBoxPlot(ctx, expStats, centerX1, padding, chartHeight, minVal, range, '#27ae60', '스칸디나비아');
                this.drawSingleBoxPlot(ctx, ctrlStats, centerX2, padding, chartHeight, minVal, range, '#e67e22', '비교 문화권');
                
                // 제목
                const metricNames = {
                    'saturation': '평균 채도',
                    'brightness': '평균 명도',
                    'colordiversity': '색상 다양성',
                    'negativespace': '여백 비율',
                    'edgedensity': '엣지 밀도',
                    'texturecomplexity': '텍스처 복잡성',
                    'symmetry': '대칭성'
                };
                
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${metricNames[metricKey]} 박스플롯 비교`, canvas.width / 2, 30);
                
                // 설명 업데이트
                const descElement = document.getElementById('chartDescription');
                if (descElement) {
                    descElement.textContent = '박스 플롯: 데이터의 분포와 이상치를 보여줍니다. 상자는 1사분위수에서 3사분위수까지의 범위를, 가운데 선은 중앙값을 나타냅니다.';
                }
            }

            calculateBoxStats(values) {
                const sorted = [...values].sort((a, b) => a - b);
                const n = sorted.length;
                
                if (n === 0) return null;
                
                const q1Index = Math.floor(n * 0.25);
                const medianIndex = Math.floor(n * 0.5);
                const q3Index = Math.floor(n * 0.75);
                
                const q1 = sorted[q1Index];
                const median = sorted[medianIndex];
                const q3 = sorted[q3Index];
                const iqr = q3 - q1;
                
                return {
                    min: sorted[0],
                    q1,
                    median,
                    q3,
                    max: sorted[n - 1],
                    lowerWhisker: Math.max(sorted[0], q1 - 1.5 * iqr),
                    upperWhisker: Math.min(sorted[n - 1], q3 + 1.5 * iqr),
                    outliers: sorted.filter(v => v < q1 - 1.5 * iqr || v > q3 + 1.5 * iqr)
                };
            }

            drawSingleBoxPlot(ctx, stats, centerX, startY, chartHeight, minVal, range, color, label) {
                if (!stats) return;
                
                const boxWidth = 60;
                const valueToY = (value) => startY + chartHeight - ((value - minVal) / range) * chartHeight;
                
                // 수염 그리기
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                
                // 위쪽 수염
                ctx.beginPath();
                ctx.moveTo(centerX, valueToY(stats.upperWhisker));
                ctx.lineTo(centerX, valueToY(stats.q3));
                ctx.stroke();
                
                // 아래쪽 수염
                ctx.beginPath();
                ctx.moveTo(centerX, valueToY(stats.q1));
                ctx.lineTo(centerX, valueToY(stats.lowerWhisker));
                ctx.stroke();
                
                // 수염 끝 표시
                ctx.beginPath();
                ctx.moveTo(centerX - 15, valueToY(stats.upperWhisker));
                ctx.lineTo(centerX + 15, valueToY(stats.upperWhisker));
                ctx.moveTo(centerX - 15, valueToY(stats.lowerWhisker));
                ctx.lineTo(centerX + 15, valueToY(stats.lowerWhisker));
                ctx.stroke();
                
                // 박스 그리기
                const boxY = valueToY(stats.q3);
                const boxHeight = valueToY(stats.q1) - valueToY(stats.q3);
                
                ctx.fillStyle = color + '40';
                ctx.fillRect(centerX - boxWidth/2, boxY, boxWidth, boxHeight);
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.strokeRect(centerX - boxWidth/2, boxY, boxWidth, boxHeight);
                
                // 중앙값 선
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX - boxWidth/2, valueToY(stats.median));
                ctx.lineTo(centerX + boxWidth/2, valueToY(stats.median));
                ctx.stroke();
                
                // 이상치 표시
                ctx.fillStyle = color;
                stats.outliers.forEach(outlier => {
                    ctx.beginPath();
                    ctx.arc(centerX, valueToY(outlier), 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                // 라벨
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(label, centerX, startY + chartHeight + 30);
            }

            drawSimpleScatter(ctx, canvas) {
                // 개별 지표 선택 표시
                const metricSelector = document.getElementById('metricSelector');
                if (metricSelector) {
                    metricSelector.style.display = 'flex';
                }
                
                const selectedMetric = document.getElementById('selectedMetric')?.value || 'saturation';
                const metricKey = selectedMetric.replace('avg', '').toLowerCase();
                
                // 다른 지표와의 상관관계 (여백 비율과 비교)
                const correlationMetric = 'negativespace';
                
                const expDataX = this.analysisResults.experimental.images.map(img => img[metricKey] || 0);
                const expDataY = this.analysisResults.experimental.images.map(img => img[correlationMetric] || 0);
                const ctrlDataX = this.analysisResults.control.images.map(img => img[metricKey] || 0);
                const ctrlDataY = this.analysisResults.control.images.map(img => img[correlationMetric] || 0);
                
                const allX = [...expDataX, ...ctrlDataX].filter(v => v > 0);
                const allY = [...expDataY, ...ctrlDataY].filter(v => v > 0);
                
                if (allX.length === 0 || allY.length === 0) {
                    ctx.fillStyle = '#e74c3c';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('데이터가 부족합니다', canvas.width / 2, canvas.height / 2);
                    return;
                }
                
                const minX = Math.min(...allX);
                const maxX = Math.max(...allX);
                const minY = Math.min(...allY);
                const maxY = Math.max(...allY);
                
                const padding = 80;
                const chartWidth = canvas.width - 2 * padding;
                const chartHeight = canvas.height - 2 * padding;
                
                // 배경
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 축과 격자 그리기
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, padding + chartHeight);
                ctx.lineTo(padding + chartWidth, padding + chartHeight);
                ctx.stroke();
                
                // 격자
                ctx.strokeStyle = '#ecf0f1';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 5; i++) {
                    // 세로 격자
                    const x = padding + (chartWidth * i / 5);
                    ctx.beginPath();
                    ctx.moveTo(x, padding);
                    ctx.lineTo(x, padding + chartHeight);
                    ctx.stroke();
                    
                    // 가로 격자
                    const y = padding + (chartHeight * i / 5);
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(padding + chartWidth, y);
                    ctx.stroke();
                }
                
                // 점들 그리기
                for (let i = 0; i < expDataX.length; i++) {
                    if (expDataX[i] > 0 && expDataY[i] > 0) {
                        const x = padding + ((expDataX[i] - minX) / (maxX - minX)) * chartWidth;
                        const y = padding + chartHeight - ((expDataY[i] - minY) / (maxY - minY)) * chartHeight;
                        
                        ctx.fillStyle = '#27ae60';
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }
                
                for (let i = 0; i < ctrlDataX.length; i++) {
                    if (ctrlDataX[i] > 0 && ctrlDataY[i] > 0) {
                        const x = padding + ((ctrlDataX[i] - minX) / (maxX - minX)) * chartWidth;
                        const y = padding + chartHeight - ((ctrlDataY[i] - minY) / (maxY - minY)) * chartHeight;
                        
                        ctx.fillStyle = '#e67e22';
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }
                
                // 축 라벨
                const metricNames = {
                    'saturation': '평균 채도',
                    'brightness': '평균 명도',
                    'colordiversity': '색상 다양성',
                    'negativespace': '여백 비율',
                    'edgedensity': '엣지 밀도',
                    'texturecomplexity': '텍스처 복잡성',
                    'symmetry': '대칭성'
                };
                
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(metricNames[metricKey], canvas.width/2, canvas.height - 20);
                
                ctx.save();
                ctx.translate(15, canvas.height/2);
                ctx.rotate(-Math.PI/2);
                ctx.fillText(metricNames[correlationMetric], 0, 0);
                ctx.restore();
                
                // 제목
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${metricNames[metricKey]} vs ${metricNames[correlationMetric]}`, canvas.width / 2, 30);
                
                // 범례
                const legendY = canvas.height - 60;
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(canvas.width - 200, legendY, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('스칸디나비아', canvas.width - 175, legendY + 12);
                
                ctx.fillStyle = '#e67e22';
                ctx.fillRect(canvas.width - 200, legendY + 20, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.fillText('비교 문화권', canvas.width - 175, legendY + 32);
                
                // 설명 업데이트
                const descElement = document.getElementById('chartDescription');
                if (descElement) {
                    descElement.textContent = '산점도: 두 지표 간의 상관관계를 분석합니다. 각 점은 하나의 이미지를 나타내며, 패턴을 통해 관련성을 파악할 수 있습니다.';
                }
            }

            drawSimpleHistogram(ctx, canvas) {
                // 개별 지표 선택 표시
                const metricSelector = document.getElementById('metricSelector');
                if (metricSelector) {
                    metricSelector.style.display = 'flex';
                }
                
                const selectedMetric = document.getElementById('selectedMetric')?.value || 'saturation';
                const metricKey = selectedMetric.replace('avg', '').toLowerCase();
                
                const expValues = this.analysisResults.experimental.images.map(img => img[metricKey] || 0).filter(val => val > 0);
                const ctrlValues = this.analysisResults.control.images.map(img => img[metricKey] || 0).filter(val => val > 0);
                
                if (expValues.length === 0 || ctrlValues.length === 0) {
                    ctx.fillStyle = '#e74c3c';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('데이터가 부족합니다', canvas.width / 2, canvas.height / 2);
                    return;
                }
                
                const allValues = [...expValues, ...ctrlValues];
                const minVal = Math.min(...allValues);
                const maxVal = Math.max(...allValues);
                const range = maxVal - minVal;
                const bins = 8;
                const binWidth = range / bins;
                
                // 히스토그램 계산
                const expHist = new Array(bins).fill(0);
                const ctrlHist = new Array(bins).fill(0);
                
                expValues.forEach(value => {
                    const binIndex = Math.min(Math.floor((value - minVal) / binWidth), bins - 1);
                    expHist[binIndex]++;
                });
                
                ctrlValues.forEach(value => {
                    const binIndex = Math.min(Math.floor((value - minVal) / binWidth), bins - 1);
                    ctrlHist[binIndex]++;
                });
                
                const maxCount = Math.max(...expHist, ...ctrlHist, 1);
                const padding = 80;
                const chartWidth = canvas.width - 2 * padding;
                const chartHeight = canvas.height - 2 * padding;
                const barWidth = chartWidth / bins;
                
                // 배경
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 축 그리기
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, padding + chartHeight);
                ctx.lineTo(padding + chartWidth, padding + chartHeight);
                ctx.stroke();
                
                // 히스토그램 그리기
                for (let i = 0; i < bins; i++) {
                    const x = padding + i * barWidth;
                    
                    // 실험군
                    const expHeight = (expHist[i] / maxCount) * chartHeight;
                    ctx.fillStyle = '#27ae6080';
                    ctx.fillRect(x + 2, padding + chartHeight - expHeight, barWidth * 0.4, expHeight);
                    
                    // 대조군
                    const ctrlHeight = (ctrlHist[i] / maxCount) * chartHeight;
                    ctx.fillStyle = '#e67e2280';
                    ctx.fillRect(x + barWidth * 0.5, padding + chartHeight - ctrlHeight, barWidth * 0.4, ctrlHeight);
                    
                    // X축 라벨 (일부만)
                    if (i % 2 === 0) {
                        const binValue = minVal + i * binWidth;
                        ctx.fillStyle = '#2c3e50';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(binValue.toFixed(2), x + barWidth/2, padding + chartHeight + 20);
                    }
                }
                
                // Y축 눈금
                for (let i = 0; i <= 5; i++) {
                    const y = padding + chartHeight - (chartHeight * i / 5);
                    const count = Math.round(maxCount * i / 5);
                    
                    ctx.strokeStyle = '#ecf0f1';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(padding + chartWidth, y);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText(count.toString(), padding - 10, y + 3);
                }
                
                // 제목
                const metricNames = {
                    'saturation': '평균 채도',
                    'brightness': '평균 명도',
                    'colordiversity': '색상 다양성',
                    'negativespace': '여백 비율',
                    'edgedensity': '엣지 밀도',
                    'texturecomplexity': '텍스처 복잡성',
                    'symmetry': '대칭성'
                };
                
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${metricNames[metricKey]} 분포 비교`, canvas.width / 2, 30);
                
                // 범례
                const legendY = canvas.height - 60;
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(canvas.width - 200, legendY, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('스칸디나비아', canvas.width - 175, legendY + 12);
                
                ctx.fillStyle = '#e67e22';
                ctx.fillRect(canvas.width - 200, legendY + 20, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.fillText('비교 문화권', canvas.width - 175, legendY + 32);
                
                // 설명 업데이트
                const descElement = document.getElementById('chartDescription');
                if (descElement) {
                    descElement.textContent = '히스토그램: 선택한 지표의 값 분포를 비교합니다. 두 그룹의 분포 패턴이 어떻게 다른지 시각적으로 확인할 수 있습니다.';
                }
            }

            drawSimpleRadar(ctx, canvas, metrics, expData, ctrlData) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(canvas.width, canvas.height) / 4;
                const numMetrics = metrics.length;
                
                // 데이터 정규화
                const maxValue = Math.max(...expData, ...ctrlData, 0.1);
                const normalizedExp = expData.map(val => val / maxValue);
                const normalizedCtrl = ctrlData.map(val => val / maxValue);
                
                // 격자 그리기
                ctx.strokeStyle = '#ecf0f1';
                ctx.lineWidth = 1;
                
                for (let level = 0.2; level <= 1; level += 0.2) {
                    ctx.beginPath();
                    for (let i = 0; i <= numMetrics; i++) {
                        const angle = (i * 2 * Math.PI) / numMetrics - Math.PI / 2;
                        const x = centerX + Math.cos(angle) * radius * level;
                        const y = centerY + Math.sin(angle) * radius * level;
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                // 축 그리기
                ctx.strokeStyle = '#bdc3c7';
                for (let i = 0; i < numMetrics; i++) {
                    const angle = (i * 2 * Math.PI) / numMetrics - Math.PI / 2;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                    
                    // 라벨
                    const labelX = centerX + Math.cos(angle) * (radius + 25);
                    const labelY = centerY + Math.sin(angle) * (radius + 25);
                    
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(metrics[i], labelX, labelY);
                }
                
                // 실험군 데이터
                ctx.strokeStyle = '#27ae60';
                ctx.fillStyle = '#27ae6040';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i <= numMetrics; i++) {
                    const dataIndex = i % numMetrics;
                    const angle = (i * 2 * Math.PI) / numMetrics - Math.PI / 2;
                    const value = normalizedExp[dataIndex];
                    const x = centerX + Math.cos(angle) * radius * value;
                    const y = centerY + Math.sin(angle) * radius * value;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                ctx.fill();
                
                // 대조군 데이터
                ctx.strokeStyle = '#e67e22';
                ctx.fillStyle = '#e67e2240';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i <= numMetrics; i++) {
                    const dataIndex = i % numMetrics;
                    const angle = (i * 2 * Math.PI) / numMetrics - Math.PI / 2;
                    const value = normalizedCtrl[dataIndex];
                    const x = centerX + Math.cos(angle) * radius * value;
                    const y = centerY + Math.sin(angle) * radius * value;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                ctx.fill();
                
                // 제목
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('레이더 차트: 종합 지표 비교', canvas.width / 2, 30);
                
                // 범례
                const legendY = canvas.height - 40;
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(canvas.width - 200, legendY, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('스칸디나비아', canvas.width - 175, legendY + 12);
                
                ctx.fillStyle = '#e67e22';
                ctx.fillRect(canvas.width - 200, legendY + 20, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.fillText('비교 문화권', canvas.width - 175, legendY + 32);
                
                // 설명 업데이트
                const descElement = document.getElementById('chartDescription');
                if (descElement) {
                    descElement.textContent = '레이더 차트: 모든 지표를 종합적으로 비교합니다. 중심에서 멀수록 높은 값을 나타내며, 전반적인 패턴 차이를 파악할 수 있습니다.';
                }
            }

            drawSimpleBarChart(ctx, canvas, metrics, expData, ctrlData) {
                const padding = 80;
                const chartWidth = canvas.width - 2 * padding;
                const chartHeight = canvas.height - 2 * padding;
                const barWidth = chartWidth / (metrics.length * 2.5);
                const maxValue = Math.max(...expData, ...ctrlData, 0.1); // 최소값 보장
                
                console.log('차트 그리기 파라미터:', { padding, chartWidth, chartHeight, barWidth, maxValue });
                
                // 배경
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 축 그리기
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, padding + chartHeight);
                ctx.lineTo(padding + chartWidth, padding + chartHeight);
                ctx.stroke();
                
                // 막대 그리기
                metrics.forEach((metric, index) => {
                    const x = padding + index * barWidth * 2.5;
                    
                    // 실험군 막대 (스칸디나비아)
                    const expHeight = Math.max((expData[index] / maxValue) * chartHeight, 2); // 최소 높이
                    ctx.fillStyle = '#27ae60';
                    ctx.fillRect(x, padding + chartHeight - expHeight, barWidth, expHeight);
                    
                    // 대조군 막대 (비교 문화권)
                    const ctrlHeight = Math.max((ctrlData[index] / maxValue) * chartHeight, 2); // 최소 높이
                    ctx.fillStyle = '#e67e22';
                    ctx.fillRect(x + barWidth + 5, padding + chartHeight - ctrlHeight, barWidth, ctrlHeight);
                    
                    // 값 표시
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    
                    if (expHeight > 15) {
                        ctx.fillText(expData[index].toFixed(2), x + barWidth/2, padding + chartHeight - expHeight - 5);
                    }
                    if (ctrlHeight > 15) {
                        ctx.fillText(ctrlData[index].toFixed(2), x + barWidth + 5 + barWidth/2, padding + chartHeight - ctrlHeight - 5);
                    }
                    
                    // X축 라벨 (회전)
                    ctx.save();
                    ctx.translate(x + barWidth, padding + chartHeight + 15);
                    ctx.rotate(-Math.PI / 6); // 30도 회전
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '11px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(metric, 0, 0);
                    ctx.restore();
                });
                
                // Y축 눈금 및 라벨
                for (let i = 0; i <= 5; i++) {
                    const y = padding + chartHeight - (chartHeight * i / 5);
                    const value = (maxValue * i / 5).toFixed(2);
                    
                    // 눈금선
                    ctx.strokeStyle = '#ecf0f1';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(padding + chartWidth, y);
                    ctx.stroke();
                    
                    // 라벨
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText(value, padding - 10, y + 3);
                }
                
                // 제목
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('스칸디나비아 vs 비교 문화권 - 지표별 평균값 비교', canvas.width / 2, 30);
                
                // 범례
                const legendY = canvas.height - 40;
                
                // 스칸디나비아
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(canvas.width - 200, legendY, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('스칸디나비아', canvas.width - 175, legendY + 12);
                
                // 비교 문화권
                ctx.fillStyle = '#e67e22';
                ctx.fillRect(canvas.width - 200, legendY + 20, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.fillText('비교 문화권', canvas.width - 175, legendY + 32);
                
                // 차트 설명 업데이트
                const descElement = document.getElementById('chartDescription');
                if (descElement) {
                    descElement.textContent = '막대 그래프: 각 지표별로 두 그룹의 평균값을 비교합니다. 녹색은 스칸디나비아 디자인, 주황색은 비교 문화권을 나타냅니다.';
                }
                
                console.log('차트 그리기 완료');
            }

            initializeChart() {
                // 첫 번째 차트 초기화 - 기본으로 막대 그래프
                const canvas = document.getElementById('comparisonChart');
                const ctx = canvas.getContext('2d');
                
                if (!canvas || !ctx) {
                    throw new Error('캔버스를 찾을 수 없습니다.');
                }
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                this.drawBarChart(ctx, canvas);
                this.updateChartDescription('bar');
            }

            drawDefaultChart() {
                // 오류 발생 시 기본 차트 그리기
                try {
                    const canvas = document.getElementById('comparisonChart');
                    const ctx = canvas.getContext('2d');
                    
                    if (canvas && ctx) {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = '#2c3e50';
                        ctx.font = '16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('차트를 불러오는 중입니다...', canvas.width / 2, canvas.height / 2);
                        
                        // 1초 후 기본 막대 차트 시도
                        setTimeout(() => {
                            try {
                                this.drawBarChart(ctx, canvas);
                                this.updateChartDescription('bar');
                            } catch (e) {
                                console.error('기본 차트 그리기 실패:', e);
                            }
                        }, 1000);
                    }
                } catch (error) {
                    console.error('기본 차트 그리기 오류:', error);
                }
            }

            setupChartControls() {
                const chartTypeSelect = document.getElementById('chartType');
                const metricSelect = document.getElementById('selectedMetric');
                
                if (!chartTypeSelect || !metricSelect) {
                    console.error('차트 컨트롤 요소를 찾을 수 없습니다.');
                    return;
                }
                
                // 기존 이벤트 리스너 제거 (중복 방지)
                chartTypeSelect.onchange = null;
                metricSelect.onchange = null;
                
                // 새 이벤트 리스너 설정 - 안전한 방식으로
                const updateChartSafely = () => {
                    try {
                        this.updateChart();
                    } catch (error) {
                        console.error('차트 업데이트 오류:', error);
                    }
                };
                
                chartTypeSelect.addEventListener('change', updateChartSafely);
                metricSelect.addEventListener('change', updateChartSafely);
                
                console.log('차트 컨트롤이 성공적으로 설정되었습니다.');
            }

            displayGroupStats() {
                const expStats = document.getElementById('experimentalStats');
                const ctrlStats = document.getElementById('controlStats');
                
                const metrics = [
                    { key: 'avgSaturation', label: '평균 채도', format: (val) => val.toFixed(3) },
                    { key: 'avgBrightness', label: '평균 명도', format: (val) => val.toFixed(3) },
                    { key: 'avgColorDiversity', label: '색상 다양성', format: (val) => val.toFixed(3) },
                    { key: 'avgNegativeSpace', label: '여백 비율', format: (val) => val.toFixed(3) },
                    { key: 'avgEdgeDensity', label: '엣지 밀도', format: (val) => val.toFixed(3) },
                    { key: 'avgTextureComplexity', label: '텍스처 복잡성', format: (val) => val.toFixed(3) },
                    { key: 'avgSymmetry', label: '대칭성', format: (val) => val.toFixed(3) }
                ];
                
                expStats.innerHTML = '';
                ctrlStats.innerHTML = '';
                
                metrics.forEach(metric => {
                    const expValue = this.analysisResults.experimental.aggregated[metric.key];
                    const ctrlValue = this.analysisResults.control.aggregated[metric.key];
                    
                    expStats.innerHTML += `
                        <div class="stat-item">
                            <div class="stat-label">${metric.label}</div>
                            <div class="stat-value">${metric.format(expValue)}</div>
                        </div>
                    `;
                    
                    ctrlStats.innerHTML += `
                        <div class="stat-item">
                            <div class="stat-label">${metric.label}</div>
                            <div class="stat-value">${metric.format(ctrlValue)}</div>
                        </div>
                    `;
                });
            }

            displayStatisticalSignificance() {
                const tableBody = document.querySelector('#significanceTable tbody');
                tableBody.innerHTML = '';
                
                const metricNames = {
                    'avgSaturation': '평균 채도',
                    'avgBrightness': '평균 명도',
                    'avgColorDiversity': '색상 다양성',
                    'avgNegativeSpace': '여백 비율',
                    'avgEdgeDensity': '엣지 밀도',
                    'avgTextureComplexity': '텍스처 복잡성',
                    'avgSymmetry': '대칭성'
                };
                
                Object.keys(this.analysisResults.statistical).forEach(metric => {
                    const result = this.analysisResults.statistical[metric];
                    const significanceClass = result.significant ? 'significant' : 'not-significant';
                    const significanceText = result.significant ? '유의미 ✓' : '유의미하지 않음 ✗';
                    
                    tableBody.innerHTML += `
                        <tr>
                            <td>${metricNames[metric]}</td>
                            <td>${result.experimentalMean.toFixed(3)}</td>
                            <td>${result.controlMean.toFixed(3)}</td>
                            <td>${result.difference.toFixed(1)}%</td>
                            <td>${result.pValue.toFixed(3)}</td>
                            <td class="${significanceClass}">${significanceText}</td>
                        </tr>
                    `;
                });
            }

            drawComparisonChart() {
                const canvas = document.getElementById('comparisonChart');
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const metrics = ['채도', '명도', '색상다양성', '여백비율', '엣지밀도', '텍스처복잡성', '대칭성'];
                const expData = [
                    this.analysisResults.experimental.aggregated.avgSaturation,
                    this.analysisResults.experimental.aggregated.avgBrightness,
                    this.analysisResults.experimental.aggregated.avgColorDiversity,
                    this.analysisResults.experimental.aggregated.avgNegativeSpace,
                    this.analysisResults.experimental.aggregated.avgEdgeDensity,
                    this.analysisResults.experimental.aggregated.avgTextureComplexity,
                    this.analysisResults.experimental.aggregated.avgSymmetry
                ];
                
                const ctrlData = [
                    this.analysisResults.control.aggregated.avgSaturation,
                    this.analysisResults.control.aggregated.avgBrightness,
                    this.analysisResults.control.aggregated.avgColorDiversity,
                    this.analysisResults.control.aggregated.avgNegativeSpace,
                    this.analysisResults.control.aggregated.avgEdgeDensity,
                    this.analysisResults.control.aggregated.avgTextureComplexity,
                    this.analysisResults.control.aggregated.avgSymmetry
                ];
                
                const barWidth = canvas.width / (metrics.length * 2 + 1);
                const maxValue = Math.max(...expData, ...ctrlData);
                const chartHeight = canvas.height - 80;
                
                metrics.forEach((metric, index) => {
                    const x = (index * 2 + 1) * barWidth;
                    
                    // 실험군 막대
                    const expHeight = (expData[index] / maxValue) * chartHeight;
                    ctx.fillStyle = '#27ae60';
                    ctx.fillRect(x, canvas.height - expHeight - 40, barWidth * 0.8, expHeight);
                    
                    // 대조군 막대
                    const ctrlHeight = (ctrlData[index] / maxValue) * chartHeight;
                    ctx.fillStyle = '#e67e22';
                    ctx.fillRect(x + barWidth, canvas.height - ctrlHeight - 40, barWidth * 0.8, ctrlHeight);
                    
                    // 라벨
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(metric, x + barWidth, canvas.height - 5);
                });
                
                // 범례
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(50, 20, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.font = '14px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('스칸디나비아', 80, 32);
                
                ctx.fillStyle = '#e67e22';
                ctx.fillRect(200, 20, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.fillText('비교 문화권', 230, 32);
            }

            generateResearchReport() {
                const keyFindings = document.getElementById('keyFindings');
                const conclusions = document.getElementById('conclusions');
                
                // 주요 발견사항 생성
                const significantFindings = [];
                Object.keys(this.analysisResults.statistical).forEach(metric => {
                    const result = this.analysisResults.statistical[metric];
                    if (result.significant) {
                        const direction = result.difference > 0 ? '높게' : '낮게';
                        const metricName = this.getMetricName(metric);
                        significantFindings.push(`• ${metricName}: 스칸디나비아 디자인이 ${Math.abs(result.difference).toFixed(1)}% ${direction} 나타남 (p=${result.pValue.toFixed(3)})`);
                    }
                });
                
                if (significantFindings.length > 0) {
                    keyFindings.innerHTML = `
                        <p><strong>통계적으로 유의미한 차이가 발견된 지표:</strong></p>
                        <ul style="margin-left: 20px; margin-top: 10px;">
                            ${significantFindings.join('<br>')}
                        </ul>
                    `;
                } else {
                    keyFindings.innerHTML = `
                        <p>분석 결과, 두 그룹 간에 통계적으로 유의미한 차이를 발견하지 못했습니다. 
                        이는 표본 크기가 작거나, 선택된 이미지의 특성, 또는 분석 방법의 한계 때문일 수 있습니다.</p>
                    `;
                }
                
                // 결론 생성
                const lagomCharacteristics = this.analyzeLagomCharacteristics();
                conclusions.innerHTML = lagomCharacteristics;
            }

            getMetricName(metric) {
                const names = {
                    'avgSaturation': '평균 채도',
                    'avgBrightness': '평균 명도',
                    'avgColorDiversity': '색상 다양성',
                    'avgNegativeSpace': '여백 비율',
                    'avgEdgeDensity': '엣지 밀도',
                    'avgTextureComplexity': '텍스처 복잡성',
                    'avgSymmetry': '대칭성'
                };
                return names[metric] || metric;
            }

            updateChartDescription(chartType) {
                const descriptions = {
                    'bar': '막대 그래프는 두 그룹 간의 평균값 차이를 직관적으로 비교할 수 있습니다. 각 지표별로 스칸디나비아 디자인(녹색)과 비교 문화권(주황색)의 값을 나란히 표시합니다.',
                    'boxplot': '박스 플롯은 데이터의 분포와 이상치를 한눈에 파악할 수 있습니다. 상자는 1사분위수(Q1)에서 3사분위수(Q3)까지의 범위를 나타내며, 가운데 선은 중앙값입니다.',
                    'scatter': '산점도 매트릭스는 여러 지표 간의 상관관계를 동시에 분석할 수 있습니다. 대각선의 히스토그램은 각 지표의 분포를, 나머지는 지표 간 상관관계를 보여줍니다.',
                    'histogram': '히스토그램은 선택한 지표의 값 분포를 비교합니다. 두 그룹의 분포 패턴이 다른지, 겹치는 구간이 있는지 등을 시각적으로 확인할 수 있습니다.',
                    'radar': '레이더 차트는 모든 지표를 하나의 차트에서 종합적으로 비교할 수 있습니다. 중심에서 멀수록 높은 값을 나타내며, 두 그룹의 전반적인 패턴 차이를 파악하기 좋습니다.'
                };
                
                const descElement = document.getElementById('chartDescription');
                if (descElement) {
                    descElement.textContent = descriptions[chartType] || '차트 설명을 불러올 수 없습니다.';
                }
            }

            drawBarChart(ctx, canvas) {
                const metrics = ['채도', '명도', '색상다양성', '여백비율', '엣지밀도', '텍스처복잡성', '대칭성'];
                const expData = [
                    this.analysisResults.experimental.aggregated.avgSaturation,
                    this.analysisResults.experimental.aggregated.avgBrightness,
                    this.analysisResults.experimental.aggregated.avgColorDiversity,
                    this.analysisResults.experimental.aggregated.avgNegativeSpace,
                    this.analysisResults.experimental.aggregated.avgEdgeDensity,
                    this.analysisResults.experimental.aggregated.avgTextureComplexity,
                    this.analysisResults.experimental.aggregated.avgSymmetry
                ];
                
                const ctrlData = [
                    this.analysisResults.control.aggregated.avgSaturation,
                    this.analysisResults.control.aggregated.avgBrightness,
                    this.analysisResults.control.aggregated.avgColorDiversity,
                    this.analysisResults.control.aggregated.avgNegativeSpace,
                    this.analysisResults.control.aggregated.avgEdgeDensity,
                    this.analysisResults.control.aggregated.avgTextureComplexity,
                    this.analysisResults.control.aggregated.avgSymmetry
                ];
                
                const barWidth = canvas.width / (metrics.length * 2 + 1);
                const maxValue = Math.max(...expData, ...ctrlData);
                const chartHeight = canvas.height - 120;
                const startY = 80;
                
                metrics.forEach((metric, index) => {
                    const x = (index * 2 + 1) * barWidth;
                    
                    // 실험군 막대
                    const expHeight = (expData[index] / maxValue) * chartHeight;
                    ctx.fillStyle = '#27ae60';
                    ctx.fillRect(x, startY + chartHeight - expHeight, barWidth * 0.7, expHeight);
                    
                    // 대조군 막대
                    const ctrlHeight = (ctrlData[index] / maxValue) * chartHeight;
                    ctx.fillStyle = '#e67e22';
                    ctx.fillRect(x + barWidth * 0.8, startY + chartHeight - ctrlHeight, barWidth * 0.7, ctrlHeight);
                    
                    // 값 표시
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(expData[index].toFixed(2), x + barWidth * 0.35, startY + chartHeight - expHeight - 5);
                    ctx.fillText(ctrlData[index].toFixed(2), x + barWidth * 1.15, startY + chartHeight - ctrlHeight - 5);
                    
                    // 라벨
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(metric, x + barWidth, canvas.height - 20);
                });
                
                // 범례
                this.drawLegend(ctx, canvas);
            }

            drawLegend(ctx, canvas) {
                // 범례
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(canvas.width - 180, canvas.height - 60, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.font = '14px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('스칸디나비아', canvas.width - 155, canvas.height - 48);
                
                ctx.fillStyle = '#e67e22';
                ctx.fillRect(canvas.width - 180, canvas.height - 35, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.fillText('비교 문화권', canvas.width - 155, canvas.height - 23);
            }

            drawBoxPlot(ctx, canvas, metric) {
                // 박스플롯 구현 - 간단화된 버전
                ctx.fillStyle = '#2c3e50';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${this.getMetricName(metric)} 박스플롯`, canvas.width / 2, canvas.height / 2);
                ctx.font = '12px Arial';
                ctx.fillText('(박스플롯 구현 중)', canvas.width / 2, canvas.height / 2 + 30);
            }

            drawScatterMatrix(ctx, canvas) {
                // 산점도 매트릭스 - 간단화된 버전
                ctx.fillStyle = '#2c3e50';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('산점도 매트릭스', canvas.width / 2, canvas.height / 2);
                ctx.font = '12px Arial';
                ctx.fillText('(지표 간 상관관계 분석)', canvas.width / 2, canvas.height / 2 + 30);
            }

            drawHistogram(ctx, canvas, metric) {
                // 히스토그램 - 간단화된 버전
                ctx.fillStyle = '#2c3e50';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${this.getMetricName(metric)} 분포`, canvas.width / 2, canvas.height / 2);
                ctx.font = '12px Arial';
                ctx.fillText('(히스토그램 구현 중)', canvas.width / 2, canvas.height / 2 + 30);
            }

            drawRadarChart(ctx, canvas) {
                // 레이더 차트 - 간단화된 버전
                ctx.fillStyle = '#2c3e50';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('레이더 차트', canvas.width / 2, canvas.height / 2);
                ctx.font = '12px Arial';
                ctx.fillText('(종합 지표 비교)', canvas.width / 2, canvas.height / 2 + 30);
            }

            analyzeLagomCharacteristics() {
                const stats = this.analysisResults.statistical;
                let conclusion = '';
                
                // 라곰 특성 분석
                const lagomIndicators = [];
                
                if (stats.avgSaturation && stats.avgSaturation.difference < 0) {
                    lagomIndicators.push('낮은 채도를 통한 절제된 색상 사용');
                }
                
                if (stats.avgNegativeSpace && stats.avgNegativeSpace.difference > 0) {
                    lagomIndicators.push('충분한 여백을 통한 미니멀한 공간 구성');
                }
                
                if (stats.avgTextureComplexity && stats.avgTextureComplexity.difference < 0) {
                    lagomIndicators.push('낮은 복잡성을 통한 단순하고 기능적인 디자인');
                }
                
                if (lagomIndicators.length > 0) {
                    conclusion = `
                        <p>본 연구를 통해 '라곰(Lagom)'으로 대표되는 스칸디나비아 디자인의 특성이 정량적으로 확인되었습니다:</p>
                        <ul style="margin-left: 20px; margin-top: 10px;">
                            ${lagomIndicators.map(indicator => `<li>${indicator}</li>`).join('')}
                        </ul>
                        <p style="margin-top: 15px;">이러한 결과는 추상적이고 문화적인 개념인 '라곰'이 실제로 측정 가능한 시각적 특징으로 구현되고 있음을 시사합니다. 
                        본 연구는 문화적 미학을 데이터 과학적 접근으로 해석하는 새로운 융합 연구 방법론의 가능성을 제시하였습니다.</p>
                    `;
                } else {
                    conclusion = `
                        <p>본 연구에서는 스칸디나비아 디자인과 비교 문화권 간의 명확한 차이를 통계적으로 입증하지 못했습니다. 
                        이는 다음과 같은 요인들로 인해 발생할 수 있습니다:</p>
                        <ul style="margin-left: 20px; margin-top: 10px;">
                            <li>표본 크기의 한계 (각 그룹당 더 많은 이미지 필요)</li>
                            <li>이미지 선정 기준의 개선 필요</li>
                            <li>분석 알고리즘의 정교화 필요</li>
                            <li>추가적인 분석 지표 도입 필요</li>
                        </ul>
                        <p style="margin-top: 15px;">향후 연구에서는 더 큰 데이터셋과 개선된 분석 방법을 통해 
                        라곰의 시각적 특성을 더욱 정확하게 정량화할 수 있을 것으로 기대됩니다.</p>
                    `;
                }
                
                return conclusion;
            }
        }

        // 전역 함수들
        function clearGroup(groupType) {
            if (groupType === 'experimental') {
                researcher.experimentalImages = [];
                document.getElementById('experimentalInput').value = '';
            } else {
                researcher.controlImages = [];
                document.getElementById('controlInput').value = '';
            }
            researcher.updateImageCount(groupType);
            researcher.checkAnalysisReady();
        }

        function startAnalysis() {
            researcher.startAnalysis();
        }

        function exportResults() {
            // CSV 형태로 결과 내보내기
            const data = researcher.analysisResults;
            if (!data) return;
            
            let csv = 'Group,Filename,Saturation,Brightness,ColorDiversity,NegativeSpace,EdgeDensity,TextureComplexity,Symmetry\n';
            
            data.experimental.images.forEach(img => {
                csv += `Scandinavian,${img.filename},${img.saturation},${img.brightness},${img.colordiversity},${img.negativespace},${img.edgedensity},${img.texturecomplexity},${img.symmetry}\n`;
            });
            
            data.control.images.forEach(img => {
                csv += `Comparative,${img.filename},${img.saturation},${img.brightness},${img.colordiversity},${img.negativespace},${img.edgedensity},${img.texturecomplexity},${img.symmetry}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'scandinavian_design_analysis_results.csv';
            link.click();
        }

        function exportPDF() {
            alert('PDF 내보내기 기능은 실제 구현에서는 jsPDF 라이브러리를 사용하여 구현할 수 있습니다.');
        }

        function exportCSV() {
            exportResults();
        }

        function exportChart() {
            const canvas = document.getElementById('comparisonChart');
            const link = document.createElement('a');
            link.download = 'comparison_chart.png';
            link.href = canvas.toDataURL();
            link.click();
        }

        function updateChart() {
            // 이 함수는 더 이상 필요하지 않습니다. 
            // 차트 업데이트는 클래스 내부에서 처리됩니다.
            console.log('차트 업데이트는 분석 완료 후 자동으로 처리됩니다.');
        }

        // 앱 초기화
        let researcher;
        document.addEventListener('DOMContentLoaded', () => {
            researcher = new ScandinavianDesignResearcher();
        });
    </script>
</body>
</html>