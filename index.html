<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë¬¸í™”ë³„ ë””ìì¸ ì–‘ì‹ ë¹„êµ ë¶„ì„ ì‹œìŠ¤í…œ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f8f9fa;
            line-height: 1.6;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px 0;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
            font-weight: 400;
        }

        .header .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            margin-bottom: 20px;
        }

        .keywords {
            font-size: 0.9rem;
            opacity: 0.8;
            font-style: italic;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .research-phases {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .phase-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            border-left: 4px solid #3498db;
            transition: transform 0.2s ease;
        }

        .phase-card:hover {
            transform: translateY(-2px);
        }

        .phase-card.active {
            border-left-color: #e74c3c;
            background: linear-gradient(135deg, #fff 0%, #f8f9ff 100%);
        }

        .phase-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }

        .phase-number {
            background: #3498db;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
            font-weight: bold;
        }

        .team-sections {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .team-container {
            background: white;
            border-radius: 16px;
            padding: 25px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.1);
        }

        .team-container.nature {
            border-top: 5px solid #27ae60;
        }

        .team-container.ornate {
            border-top: 5px solid #e74c3c;
        }

        .team-header {
            font-size: 1.6rem;
            font-weight: 700;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 15px;
            background: linear-gradient(135deg, #f8f9fa 0%, #ecf0f1 100%);
            border-radius: 10px;
        }

        .team-icon {
            margin-right: 15px;
            font-size: 2rem;
        }

        .styles-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .style-upload-group {
            background: #fafbfc;
            border-radius: 12px;
            padding: 20px;
            border: 2px solid #ecf0f1;
        }

        .style-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: #2c3e50;
            display: flex;
            align-items: center;
        }

        .style-icon {
            margin-right: 10px;
            font-size: 1.3rem;
        }

        .upload-area {
            border: 2px dashed #bdc3c7;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
        }

        .upload-area:hover {
            border-color: #3498db;
            background: #f8f9ff;
        }

        .upload-area.dragover {
            border-color: #2ecc71;
            background: #f0fff4;
            transform: scale(1.02);
        }

        .upload-btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 0.95rem;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s ease;
        }

        .upload-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }

        .upload-btn.clear {
            background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
        }

        .upload-btn.clear:hover {
            box-shadow: 0 5px 15px rgba(149, 165, 166, 0.3);
        }

        .image-count {
            margin-top: 10px;
            font-weight: 600;
            color: #2c3e50;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .count-badge {
            background: #ecf0f1;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.85rem;
        }

        .analysis-section {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }

        .analysis-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .analyze-btn {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .analyze-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(39, 174, 96, 0.3);
        }

        .analyze-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .progress-container {
            background: #ecf0f1;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: #d5dbdb;
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            transition: width 0.3s ease;
            border-radius: 6px;
        }

        .progress-text {
            text-align: center;
            font-weight: 600;
            color: #2c3e50;
        }

        .results-container {
            margin-top: 30px;
        }

        .individual-results {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .style-result-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border-left: 4px solid #3498db;
        }

        .style-result-card.lagom {
            border-left-color: #2ecc71;
        }

        .style-result-card.hanok {
            border-left-color: #27ae60;
        }

        .style-result-card.baroque {
            border-left-color: #e74c3c;
        }

        .style-result-card.rococo {
            border-left-color: #c0392b;
        }

        .team-comparison {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .stat-label {
            font-size: 0.9rem;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #2c3e50;
        }

        .statistical-analysis {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }

        .significance-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .significance-table th,
        .significance-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ecf0f1;
        }

        .significance-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #2c3e50;
        }

        .significant {
            color: #27ae60;
            font-weight: bold;
        }

        .not-significant {
            color: #e74c3c;
        }

        .chart-container {
            margin: 20px 0;
            text-align: center;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }

        .chart-controls {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .chart-selector, .metric-selector {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .chart-selector label, .metric-selector label {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9rem;
        }

        .chart-selector select, .metric-selector select {
            padding: 8px 15px;
            border: 2px solid #bdc3c7;
            border-radius: 6px;
            background: white;
            font-size: 0.9rem;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }

        .chart-selector select:focus, .metric-selector select:focus {
            outline: none;
            border-color: #3498db;
        }

        .chart-canvas {
            max-width: 100%;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            background: white;
            margin: 20px 0;
        }

        .chart-description {
            background: #f8f9ff;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            color: #2c3e50;
            font-size: 0.9rem;
            line-height: 1.5;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .research-report {
            background: white;
            border-radius: 12px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            line-height: 1.8;
        }

        .report-section {
            margin-bottom: 30px;
        }

        .report-section h3 {
            color: #2c3e50;
            font-size: 1.4rem;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #ecf0f1;
        }

        .export-controls {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            margin-top: 20px;
        }

        .export-btn {
            background: linear-gradient(135deg, #8e44ad 0%, #9b59b6 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 6px;
            margin: 0 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .export-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(142, 68, 173, 0.3);
        }

        @media (max-width: 768px) {
            .team-sections {
                grid-template-columns: 1fr;
            }
            
            .styles-grid {
                grid-template-columns: 1fr;
            }
        }

        .methodology-info {
            background: #e8f5e8;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            border-left: 4px solid #27ae60;
        }

        .warning-box {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            color: #856404;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ë¬¸í™”ë³„ ë””ìì¸ ì–‘ì‹ ë¹„êµ ë¶„ì„ ì‹œìŠ¤í…œ</h1>
        <div class="subtitle">ë™ì„œì–‘ ê±´ì¶• ì–‘ì‹ì˜ ì •ëŸ‰ì  íŠ¹ì„± ë¶„ì„ ë° ë¹„êµ ì—°êµ¬</div>
        <div class="keywords">
            Keywords: Scandinavian Design, Korean Hanok, Baroque, Rococo, Computer Vision, Quantitative Analysis
        </div>
    </div>

    <div class="container">
        <!-- ì—°êµ¬ ë‹¨ê³„ ì„¤ëª… -->
        <div class="research-phases">
            <div class="phase-card active">
                <div class="phase-title">
                    <span class="phase-number">1</span>
                    ë°ì´í„°ì…‹ êµ¬ì¶•
                </div>
                <p>4ê°€ì§€ ì–‘ì‹(ë¼ê³°, í•œì˜¥, ë°”ë¡œí¬, ë¡œì½”ì½”)ì˜ ì´ë¯¸ì§€ë¥¼ ì²´ê³„ì ìœ¼ë¡œ ìˆ˜ì§‘í•˜ì—¬ ë¹„êµ ë¶„ì„ì„ ìœ„í•œ ë°ì´í„°ë² ì´ìŠ¤ë¥¼ êµ¬ì¶•í•©ë‹ˆë‹¤.</p>
            </div>
            <div class="phase-card">
                <div class="phase-title">
                    <span class="phase-number">2</span>
                    ê°œë³„ ë¶„ì„
                </div>
                <p>ê° ì–‘ì‹ë³„ë¡œ ìƒ‰ìƒ, ê³µê°„, ë³µì¡ì„± ë“±ì˜ ì‹œê°ì  íŠ¹ì„±ì„ ë…ë¦½ì ìœ¼ë¡œ ë¶„ì„í•˜ì—¬ ê³ ìœ í•œ íŠ¹ì§•ì„ ì¶”ì¶œí•©ë‹ˆë‹¤.</p>
            </div>
            <div class="phase-card">
                <div class="phase-title">
                    <span class="phase-number">3</span>
                    íŒ€ ë¹„êµ ë¶„ì„
                </div>
                <p>ì ˆì œì  ìì—° ì¹œí™”í˜•ê³¼ ì¥ì‹ì  í™”ë ¤í•¨ ê³¼ì‹œí˜•ìœ¼ë¡œ ê·¸ë£¹í™”í•˜ì—¬ ëŒ€ì¡°ì ì¸ ë¯¸í•™ì  íŠ¹ì„±ì„ ë¹„êµ ë¶„ì„í•©ë‹ˆë‹¤.</p>
            </div>
            <div class="phase-card">
                <div class="phase-title">
                    <span class="phase-number">4</span>
                    ì¢…í•© ë³´ê³ ì„œ
                </div>
                <p>ë¶„ì„ ê²°ê³¼ë¥¼ ì‹œê°í™”í•˜ê³  í†µê³„ì  ê²€ì¦ì„ í†µí•´ ë¬¸í™”ê°„ ë””ìì¸ íŠ¹ì„±ì˜ ì°¨ì´ë¥¼ ê³¼í•™ì ìœ¼ë¡œ ì…ì¦í•©ë‹ˆë‹¤.</p>
            </div>
        </div>

        <!-- ì´ë¯¸ì§€ ì—…ë¡œë“œ ì„¹ì…˜ -->
        <div class="team-sections">
            <!-- íŒ€ 1: ì ˆì œì  ìì—° ì¹œí™”í˜• -->
            <div class="team-container nature">
                <div class="team-header">
                    <span class="team-icon">ğŸŒ¿</span>
                    ì ˆì œì  ìì—° ì¹œí™”í˜•
                </div>
                
                <div class="styles-grid">
                    <!-- ë¼ê³°(ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„) -->
                    <div class="style-upload-group">
                        <div class="style-title">
                            <span class="style-icon">ğŸ‡¸ğŸ‡ª</span>
                            ë¼ê³°(ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„) ì–‘ì‹
                        </div>
                        <div class="upload-area" id="lagomUpload">
                            <p>ğŸ“· ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„ ë””ìì¸ ì´ë¯¸ì§€</p>
                            <p style="font-size: 0.85rem; color: #7f8c8d; margin-top: 8px;">
                                ë“œë˜ê·¸ ì•¤ ë“œë¡­ ë˜ëŠ” í´ë¦­
                            </p>
                            <input type="file" id="lagomInput" multiple accept="image/*" style="display: none;">
                            <button class="upload-btn" onclick="document.getElementById('lagomInput').click()">
                                ì´ë¯¸ì§€ ì„ íƒ
                            </button>
                            <button class="upload-btn clear" onclick="clearStyle('lagom')">
                                ì´ˆê¸°í™”
                            </button>
                        </div>
                        <div class="image-count">
                            <span>ì—…ë¡œë“œëœ ì´ë¯¸ì§€:</span>
                            <span class="count-badge" id="lagomCount">0ì¥</span>
                        </div>
                    </div>

                    <!-- í•œì˜¥ -->
                    <div class="style-upload-group">
                        <div class="style-title">
                            <span class="style-icon">ğŸ›ï¸</span>
                            í•œì˜¥ ì–‘ì‹
                        </div>
                        <div class="upload-area" id="hanokUpload">
                            <p>ğŸ“· í•œì˜¥ ë””ìì¸ ì´ë¯¸ì§€</p>
                            <p style="font-size: 0.85rem; color: #7f8c8d; margin-top: 8px;">
                                ë“œë˜ê·¸ ì•¤ ë“œë¡­ ë˜ëŠ” í´ë¦­
                            </p>
                            <input type="file" id="hanokInput" multiple accept="image/*" style="display: none;">
                            <button class="upload-btn" onclick="document.getElementById('hanokInput').click()">
                                ì´ë¯¸ì§€ ì„ íƒ
                            </button>
                            <button class="upload-btn clear" onclick="clearStyle('hanok')">
                                ì´ˆê¸°í™”
                            </button>
                        </div>
                        <div class="image-count">
                            <span>ì—…ë¡œë“œëœ ì´ë¯¸ì§€:</span>
                            <span class="count-badge" id="hanokCount">0ì¥</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- íŒ€ 2: ì¥ì‹ì  í™”ë ¤í•¨ ê³¼ì‹œí˜• -->
            <div class="team-container ornate">
                <div class="team-header">
                    <span class="team-icon">ğŸ‘‘</span>
                    ì¥ì‹ì  í™”ë ¤í•¨ ê³¼ì‹œí˜•
                </div>
                
                <div class="styles-grid">
                    <!-- ë°”ë¡œí¬ -->
                    <div class="style-upload-group">
                        <div class="style-title">
                            <span class="style-icon">ğŸ­</span>
                            ë°”ë¡œí¬ ì–‘ì‹
                        </div>
                        <div class="upload-area" id="baroqueUpload">
                            <p>ğŸ“· ë°”ë¡œí¬ ë””ìì¸ ì´ë¯¸ì§€</p>
                            <p style="font-size: 0.85rem; color: #7f8c8d; margin-top: 8px;">
                                ë“œë˜ê·¸ ì•¤ ë“œë¡­ ë˜ëŠ” í´ë¦­
                            </p>
                            <input type="file" id="baroqueInput" multiple accept="image/*" style="display: none;">
                            <button class="upload-btn" onclick="document.getElementById('baroqueInput').click()">
                                ì´ë¯¸ì§€ ì„ íƒ
                            </button>
                            <button class="upload-btn clear" onclick="clearStyle('baroque')">
                                ì´ˆê¸°í™”
                            </button>
                        </div>
                        <div class="image-count">
                            <span>ì—…ë¡œë“œëœ ì´ë¯¸ì§€:</span>
                            <span class="count-badge" id="baroqueCount">0ì¥</span>
                        </div>
                    </div>

                    <!-- ë¡œì½”ì½” -->
                    <div class="style-upload-group">
                        <div class="style-title">
                            <span class="style-icon">ğŸŒ¹</span>
                            ë¡œì½”ì½” ì–‘ì‹
                        </div>
                        <div class="upload-area" id="rococoUpload">
                            <p>ğŸ“· ë¡œì½”ì½” ë””ìì¸ ì´ë¯¸ì§€</p>
                            <p style="font-size: 0.85rem; color: #7f8c8d; margin-top: 8px;">
                                ë“œë˜ê·¸ ì•¤ ë“œë¡­ ë˜ëŠ” í´ë¦­
                            </p>
                            <input type="file" id="rococoInput" multiple accept="image/*" style="display: none;">
                            <button class="upload-btn" onclick="document.getElementById('rococoInput').click()">
                                ì´ë¯¸ì§€ ì„ íƒ
                            </button>
                            <button class="upload-btn clear" onclick="clearStyle('rococo')">
                                ì´ˆê¸°í™”
                            </button>
                        </div>
                        <div class="image-count">
                            <span>ì—…ë¡œë“œëœ ì´ë¯¸ì§€:</span>
                            <span class="count-badge" id="rococoCount">0ì¥</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ë¶„ì„ ì‹¤í–‰ ì„¹ì…˜ -->
        <div class="analysis-section">
            <h3>ğŸ“Š ì •ëŸ‰ì  ë¶„ì„ ì‹¤í–‰</h3>
            <div class="warning-box">
                <strong>âš ï¸ ì—°êµ¬ ì¡°ê±´:</strong> ê° ì–‘ì‹ë‹¹ ìµœì†Œ 3ì¥ ì´ìƒì˜ ì´ë¯¸ì§€ê°€ í•„ìš”í•©ë‹ˆë‹¤. ë” ë§ì€ ì´ë¯¸ì§€ì¼ìˆ˜ë¡ í†µê³„ì ìœ¼ë¡œ ì‹ ë¢°ì„± ìˆëŠ” ê²°ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
            </div>
            
            <div class="analysis-controls">
                <button class="analyze-btn" id="analyzeBtn" onclick="startAnalysis()" disabled>
                    ğŸ”¬ ë¶„ì„ ì‹œì‘
                </button>
                <button class="export-btn" onclick="exportResults()" disabled id="exportBtn">
                    ğŸ“„ ê²°ê³¼ ë‚´ë³´ë‚´ê¸°
                </button>
            </div>

            <div class="progress-container" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">ë¶„ì„ ì¤€ë¹„ ì¤‘...</div>
            </div>
        </div>

        <!-- ë¶„ì„ ê²°ê³¼ ì„¹ì…˜ -->
        <div class="results-container" id="resultsContainer" style="display: none;">
            <!-- ê°œë³„ ì–‘ì‹ ë¶„ì„ ê²°ê³¼ -->
            <div class="individual-results">
                <h3>ğŸ“ˆ ê°œë³„ ì–‘ì‹ ë¶„ì„ ê²°ê³¼</h3>
                <div class="results-grid" id="individualResults">
                    <!-- ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
                </div>
            </div>

            <!-- íŒ€ ë¹„êµ ë¶„ì„ ê²°ê³¼ -->
            <div class="team-comparison">
                <h3>ğŸ” íŒ€ ë¹„êµ ë¶„ì„</h3>
                <div class="results-grid" id="teamComparison">
                    <!-- ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
                </div>
            </div>

            <!-- í†µê³„ì  ê²€ì¦ ê²°ê³¼ -->
            <div class="statistical-analysis" id="statisticalAnalysis">
                <h3>ğŸ“Š í†µê³„ì  ìœ ì˜ì„± ê²€ì¦ (t-test)</h3>
                <div class="methodology-info">
                    <strong>ê²€ì¦ ë°©ë²•:</strong> ë…ë¦½í‘œë³¸ t-ê²€ì • (Independent Samples t-test)<br>
                    <strong>ìœ ì˜ìˆ˜ì¤€:</strong> Î± = 0.05 (p-value < 0.05ì¼ ë•Œ í†µê³„ì ìœ¼ë¡œ ìœ ì˜ë¯¸í•¨)
                </div>
                <table class="significance-table" id="significanceTable">
                    <thead>
                        <tr>
                            <th>ë¶„ì„ ì§€í‘œ</th>
                            <th>ì ˆì œì  ìì—° ì¹œí™”í˜•</th>
                            <th>ì¥ì‹ì  í™”ë ¤í•¨ ê³¼ì‹œí˜•</th>
                            <th>ì°¨ì´ìœ¨ (%)</th>
                            <th>p-value</th>
                            <th>í†µê³„ì  ìœ ì˜ì„±</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- ê²°ê³¼ê°€ ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
                    </tbody>
                </table>
            </div>

            <!-- ì‹œê°í™” ì°¨íŠ¸ -->
            <div class="chart-container" id="chartContainer">
                <h3>ğŸ“Š ë¹„êµ ë¶„ì„ ì‹œê°í™”</h3>
                
                <div class="chart-controls">
                    <div class="chart-selector">
                        <label for="chartType">ì°¨íŠ¸ ìœ í˜•:</label>
                        <select id="chartType" onchange="updateChart()">
                            <option value="bar4">4ê°€ì§€ ì–‘ì‹ ë¹„êµ</option>
                            <option value="barTeam">íŒ€ë³„ ë¹„êµ</option>
                            <option value="radar">ë ˆì´ë” ì°¨íŠ¸</option>
                            <option value="boxplot">ë°•ìŠ¤í”Œë¡¯</option>
                            <option value="scatter">ì‚°ì ë„</option>
                            <option value="histogram">íˆìŠ¤í† ê·¸ë¨</option>
                        </select>
                    </div>
                    
                    <div class="metric-selector" id="metricSelector" style="display: none;">
                        <label for="selectedMetric">ë¶„ì„ ì§€í‘œ:</label>
                        <select id="selectedMetric" onchange="updateChart()">
                            <option value="saturation">í‰ê·  ì±„ë„</option>
                            <option value="brightness">í‰ê·  ëª…ë„</option>
                            <option value="colordiversity">ìƒ‰ìƒ ë‹¤ì–‘ì„±</option>
                            <option value="negativespace">ì—¬ë°± ë¹„ìœ¨</option>
                            <option value="edgedensity">ì—£ì§€ ë°€ë„</option>
                            <option value="texturecomplexity">í…ìŠ¤ì²˜ ë³µì¡ì„±</option>
                            <option value="symmetry">ëŒ€ì¹­ì„±</option>
                        </select>
                    </div>
                    
                    <button class="upload-btn" onclick="exportChart()">
                        ğŸ’¾ ì°¨íŠ¸ ì €ì¥
                    </button>
                </div>
                
                <canvas id="comparisonChart" class="chart-canvas" width="1000" height="600"></canvas>
                
                <!-- ì°¨íŠ¸ ì„¤ëª… -->
                <div class="chart-description" id="chartDescription">
                    ì°¨íŠ¸ ìœ í˜•ì„ ì„ íƒí•˜ì—¬ ë°ì´í„°ë¥¼ ì‹œê°í™”í•´ë³´ì„¸ìš”.
                </div>
            </div>

            <!-- ì—°êµ¬ ë³´ê³ ì„œ -->
            <div class="research-report" id="researchReport">
                <h2>ì—°êµ¬ ê²°ê³¼ ë³´ê³ ì„œ</h2>
                
                <div class="report-section">
                    <h3>1. ì—°êµ¬ ëª©ì  ë° ë°©ë²•</h3>
                    <p>ë³¸ ì—°êµ¬ëŠ” ë™ì„œì–‘ì˜ ëŒ€í‘œì ì¸ ê±´ì¶• ì–‘ì‹ì„ ì»´í“¨í„° ë¹„ì „ ê¸°ìˆ ì„ í†µí•´ ì •ëŸ‰í™”í•˜ê³ , 
                    ë¬¸í™”ê¶Œë³„ ë¯¸í•™ì  íŠ¹ì„±ì„ ê°ê´€ì ìœ¼ë¡œ ë¹„êµ ë¶„ì„í•˜ëŠ” ê²ƒì„ ëª©ì ìœ¼ë¡œ í•œë‹¤. 
                    ì´ë¯¸ì§€ ë¶„ì„ ì•Œê³ ë¦¬ì¦˜ì„ í™œìš©í•˜ì—¬ ìƒ‰ìƒ, ê³µê°„, ë³µì¡ì„± ë“±ì˜ ì‹œê°ì  íŠ¹ì§•ì„ ìˆ˜ì¹˜í™”í•˜ê³ , 
                    í†µê³„ì  ê²€ì¦ì„ í†µí•´ ê·¸ ì°¨ì´ì˜ ìœ ì˜ë¯¸ì„±ì„ ê²€ì¦í•˜ì˜€ë‹¤.</p>
                </div>

                <div class="report-section">
                    <h3>2. ì£¼ìš” ì—°êµ¬ ê²°ê³¼</h3>
                    <div id="keyFindings">
                        <!-- ì£¼ìš” ë°œê²¬ì‚¬í•­ì´ ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
                    </div>
                </div>

                <div class="report-section">
                    <h3>3. ê²°ë¡  ë° ì˜ì˜</h3>
                    <div id="conclusions">
                        <!-- ê²°ë¡ ì´ ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
                    </div>
                </div>
            </div>

            <!-- ë‚´ë³´ë‚´ê¸° ì»¨íŠ¸ë¡¤ -->
            <div class="export-controls">
                <button class="export-btn" onclick="exportPDF()">ğŸ“‘ PDF ë³´ê³ ì„œ ë‹¤ìš´ë¡œë“œ</button>
                <button class="export-btn" onclick="exportCSV()">ğŸ“Š ì›ì‹œ ë°ì´í„° CSV ë‹¤ìš´ë¡œë“œ</button>
                <button class="export-btn" onclick="exportChart()">ğŸ“ˆ ì°¨íŠ¸ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ</button>
            </div>
        </div>
    </div>

    <script>
        class DesignAnalyzer {
            constructor() {
                this.styles = {
                    lagom: [],
                    hanok: [],
                    baroque: [],
                    rococo: []
                };
                
                this.teams = {
                    nature: ['lagom', 'hanok'],
                    ornate: ['baroque', 'rococo']
                };
                
                this.analysisResults = null;
                this.setupEventListeners();
            }

            setupEventListeners() {
                // ê° ìŠ¤íƒ€ì¼ë³„ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
                Object.keys(this.styles).forEach(style => {
                    const input = document.getElementById(`${style}Input`);
                    const upload = document.getElementById(`${style}Upload`);
                    
                    input.addEventListener('change', (e) => {
                        this.handleImageUpload(e.target.files, style);
                    });
                    
                    this.setupDragAndDrop(upload, style);
                });
            }

            setupDragAndDrop(uploadArea, style) {
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });

                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });

                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    this.handleImageUpload(e.dataTransfer.files, style);
                });
            }

            async handleImageUpload(files, style) {
                for (const file of files) {
                    if (file.type.startsWith('image/')) {
                        try {
                            const image = await this.loadImage(file);
                            const analysisData = await this.preprocessImage(image, file.name);
                            this.styles[style].push(analysisData);
                        } catch (error) {
                            console.error('ì´ë¯¸ì§€ ë¡œë“œ ì˜¤ë¥˜:', error);
                        }
                    }
                }

                this.updateImageCount(style);
                this.checkAnalysisReady();
            }

            loadImage(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.onerror = reject;
                        img.src = e.target.result;
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            async preprocessImage(image, filename) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = 512;
                canvas.height = 512;
                ctx.drawImage(image, 0, 0, 512, 512);
                
                const imageData = ctx.getImageData(0, 0, 512, 512);
                
                return {
                    filename: filename,
                    imageData: imageData,
                    canvas: canvas
                };
            }

            updateImageCount(style) {
                const count = this.styles[style].length;
                const countElement = document.getElementById(`${style}Count`);
                countElement.textContent = `${count}ì¥`;
            }

            checkAnalysisReady() {
                const analyzeBtn = document.getElementById('analyzeBtn');
                const allStylesHaveImages = Object.keys(this.styles).every(
                    style => this.styles[style].length >= 3
                );
                analyzeBtn.disabled = !allStylesHaveImages;
            }

            async startAnalysis() {
                const progressContainer = document.getElementById('progressContainer');
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');

                progressContainer.style.display = 'block';
                
                try {
                    const results = {
                        individual: {},
                        teams: {},
                        statistical: {}
                    };
                    
                    // 1. ê°œë³„ ì–‘ì‹ ë¶„ì„
                    let progress = 0;
                    const styleKeys = Object.keys(this.styles);
                    
                    for (let i = 0; i < styleKeys.length; i++) {
                        const style = styleKeys[i];
                        progressText.textContent = `${this.getStyleName(style)} ì–‘ì‹ ë¶„ì„ ì¤‘...`;
                        progress = ((i + 1) / styleKeys.length) * 50;
                        progressFill.style.width = `${progress}%`;
                        
                        results.individual[style] = await this.analyzeImageGroup(this.styles[style]);
                    }
                    
                    // 2. íŒ€ë³„ í†µí•© ë¶„ì„
                    progressText.textContent = 'íŒ€ë³„ ë¹„êµ ë¶„ì„ ì¤‘...';
                    progressFill.style.width = '75%';
                    
                    // ì ˆì œì  ìì—° ì¹œí™”í˜• íŒ€ ë¶„ì„
                    const natureImages = [];
                    this.teams.nature.forEach(style => {
                        natureImages.push(...this.styles[style]);
                    });
                    results.teams.nature = await this.analyzeImageGroup(natureImages);
                    
                    // ì¥ì‹ì  í™”ë ¤í•¨ ê³¼ì‹œí˜• íŒ€ ë¶„ì„
                    const ornateImages = [];
                    this.teams.ornate.forEach(style => {
                        ornateImages.push(...this.styles[style]);
                    });
                    results.teams.ornate = await this.analyzeImageGroup(ornateImages);
                    
                    // 3. í†µê³„ ë¶„ì„
                    progressText.textContent = 'í†µê³„ì  ê²€ì¦ ìˆ˜í–‰ ì¤‘...';
                    progressFill.style.width = '90%';
                    
                    results.statistical = this.performStatisticalAnalysis(results.teams.nature, results.teams.ornate);
                    
                    // 4. ê²°ê³¼ ì €ì¥ ë° í‘œì‹œ
                    progressText.textContent = 'ê²°ê³¼ ìƒì„± ì¤‘...';
                    progressFill.style.width = '100%';
                    
                    this.analysisResults = results;
                    this.displayResults();
                    
                    progressText.textContent = 'ë¶„ì„ ì™„ë£Œ!';
                    setTimeout(() => {
                        progressContainer.style.display = 'none';
                    }, 2000);
                    
                    // ê²°ê³¼ ì»¨í…Œì´ë„ˆ í‘œì‹œ
                    document.getElementById('resultsContainer').style.display = 'block';
                    document.getElementById('exportBtn').disabled = false;
                    
                } catch (error) {
                    console.error('ë¶„ì„ ì˜¤ë¥˜:', error);
                    progressText.textContent = 'ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
                }
            }

            async analyzeImageGroup(images) {
                const results = {
                    images: [],
                    aggregated: {
                        avgSaturation: 0,
                        avgBrightness: 0,
                        avgColorDiversity: 0,
                        avgNegativeSpace: 0,
                        avgEdgeDensity: 0,
                        avgTextureComplexity: 0,
                        avgSymmetry: 0
                    }
                };

                for (const imageData of images) {
                    const analysis = this.analyzeImage(imageData.imageData);
                    results.images.push({
                        filename: imageData.filename,
                        ...analysis
                    });
                }

                const metrics = ['avgSaturation', 'avgBrightness', 'avgColorDiversity', 
                               'avgNegativeSpace', 'avgEdgeDensity', 'avgTextureComplexity', 'avgSymmetry'];
                
                metrics.forEach(metric => {
                    const key = metric.replace('avg', '').toLowerCase();
                    const values = results.images.map(img => img[key] || 0);
                    results.aggregated[metric] = values.reduce((sum, val) => sum + val, 0) / values.length;
                });

                return results;
            }

            analyzeImage(imageData) {
                const pixels = imageData.data;
                const width = imageData.width;
                const height = imageData.height;

                const colorAnalysis = this.analyzeColors(pixels);
                const spaceAnalysis = this.analyzeSpace(pixels, width, height);
                const complexityAnalysis = this.analyzeComplexity(pixels, width, height);

                return {
                    saturation: colorAnalysis.avgSaturation,
                    brightness: colorAnalysis.avgBrightness,
                    colordiversity: colorAnalysis.colorDiversity,
                    negativespace: spaceAnalysis.negativeSpaceRatio,
                    edgedensity: complexityAnalysis.edgeDensity,
                    texturecomplexity: complexityAnalysis.textureComplexity,
                    symmetry: spaceAnalysis.symmetryScore
                };
            }

            analyzeColors(pixels) {
                const colors = [];
                
                for (let i = 0; i < pixels.length; i += 16) {
                    const r = pixels[i];
                    const g = pixels[i + 1];
                    const b = pixels[i + 2];
                    
                    if (r !== undefined && g !== undefined && b !== undefined) {
                        colors.push([r, g, b]);
                    }
                }

                const dominantColors = this.extractDominantColors(colors, 5);
                const hsvColors = dominantColors.map(color => this.rgbToHsv(color));
                
                const avgSaturation = hsvColors.reduce((sum, hsv) => sum + hsv[1], 0) / hsvColors.length;
                const avgBrightness = hsvColors.reduce((sum, hsv) => sum + hsv[2], 0) / hsvColors.length;
                const colorDiversity = this.calculateColorDiversity(dominantColors);

                return {
                    avgSaturation,
                    avgBrightness,
                    colorDiversity
                };
            }

            extractDominantColors(colors, numColors) {
                if (colors.length === 0) return [];
                
                const centroids = [];
                for (let i = 0; i < numColors; i++) {
                    centroids.push(colors[Math.floor(Math.random() * colors.length)]);
                }
                
                for (let iter = 0; iter < 10; iter++) {
                    const clusters = Array(numColors).fill().map(() => []);
                    
                    colors.forEach(color => {
                        let minDist = Infinity;
                        let closestCentroid = 0;
                        
                        centroids.forEach((centroid, idx) => {
                            const dist = this.colorDistance(color, centroid);
                            if (dist < minDist) {
                                minDist = dist;
                                closestCentroid = idx;
                            }
                        });
                        
                        clusters[closestCentroid].push(color);
                    });
                    
                    clusters.forEach((cluster, idx) => {
                        if (cluster.length > 0) {
                            const newCentroid = [
                                cluster.reduce((sum, c) => sum + c[0], 0) / cluster.length,
                                cluster.reduce((sum, c) => sum + c[1], 0) / cluster.length,
                                cluster.reduce((sum, c) => sum + c[2], 0) / cluster.length
                            ];
                            centroids[idx] = newCentroid;
                        }
                    });
                }
                
                return centroids;
            }

            colorDistance(color1, color2) {
                return Math.sqrt(
                    Math.pow(color1[0] - color2[0], 2) +
                    Math.pow(color1[1] - color2[1], 2) +
                    Math.pow(color1[2] - color2[2], 2)
                );
            }

            rgbToHsv([r, g, b]) {
                r /= 255;
                g /= 255;
                b /= 255;
                
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const diff = max - min;
                
                let h = 0;
                let s = max === 0 ? 0 : diff / max;
                let v = max;
                
                if (diff !== 0) {
                    switch (max) {
                        case r: h = ((g - b) / diff) % 6; break;
                        case g: h = (b - r) / diff + 2; break;
                        case b: h = (r - g) / diff + 4; break;
                    }
                    h /= 6;
                }
                
                if (h < 0) h += 1;
                
                return [h, s, v];
            }

            calculateColorDiversity(colors) {
                if (colors.length <= 1) return 0;
                
                let totalDistance = 0;
                let comparisons = 0;
                
                for (let i = 0; i < colors.length; i++) {
                    for (let j = i + 1; j < colors.length; j++) {
                        totalDistance += this.colorDistance(colors[i], colors[j]);
                        comparisons++;
                    }
                }
                
                return comparisons > 0 ? (totalDistance / comparisons) / 441.67 : 0;
            }

            analyzeSpace(pixels, width, height) {
                const grayscale = this.convertToGrayscale(pixels, width, height);
                const edges = this.detectEdges(grayscale, width, height);
                
                const totalPixels = width * height;
                const edgePixels = edges.reduce((sum, pixel) => sum + (pixel > 128 ? 1 : 0), 0);
                const negativeSpaceRatio = Math.max(0, (totalPixels - edgePixels * 3) / totalPixels);
                
                const symmetryScore = this.calculateSymmetry(grayscale, width, height);
                
                return {
                    negativeSpaceRatio,
                    symmetryScore
                };
            }

            convertToGrayscale(pixels, width, height) {
                const grayscale = [];
                for (let i = 0; i < pixels.length; i += 4) {
                    const gray = pixels[i] * 0.299 + pixels[i + 1] * 0.587 + pixels[i + 2] * 0.114;
                    grayscale.push(gray);
                }
                return grayscale;
            }

            detectEdges(grayscale, width, height) {
                const edges = new Array(grayscale.length).fill(0);
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = y * width + x;
                        
                        const gx = (
                            grayscale[idx - width - 1] * -1 + grayscale[idx - width + 1] * 1 +
                            grayscale[idx - 1] * -2 + grayscale[idx + 1] * 2 +
                            grayscale[idx + width - 1] * -1 + grayscale[idx + width + 1] * 1
                        );
                        
                        const gy = (
                            grayscale[idx - width - 1] * -1 + grayscale[idx - width] * -2 + grayscale[idx - width + 1] * -1 +
                            grayscale[idx + width - 1] * 1 + grayscale[idx + width] * 2 + grayscale[idx + width + 1] * 1
                        );
                        
                        edges[idx] = Math.sqrt(gx * gx + gy * gy);
                    }
                }
                
                return edges;
            }

            calculateSymmetry(grayscale, width, height) {
                const halfWidth = Math.floor(width / 2);
                let totalDiff = 0;
                let comparisons = 0;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < halfWidth; x++) {
                        const leftIdx = y * width + x;
                        const rightIdx = y * width + (width - 1 - x);
                        
                        if (leftIdx < grayscale.length && rightIdx < grayscale.length) {
                            totalDiff += Math.abs(grayscale[leftIdx] - grayscale[rightIdx]);
                            comparisons++;
                        }
                    }
                }
                
                return comparisons > 0 ? 1 - (totalDiff / comparisons) / 255 : 0;
            }

            analyzeComplexity(pixels, width, height) {
                const grayscale = this.convertToGrayscale(pixels, width, height);
                const edges = this.detectEdges(grayscale, width, height);
                
                const totalPixels = edges.length;
                const edgePixels = edges.reduce((sum, pixel) => sum + (pixel > 50 ? 1 : 0), 0);
                const edgeDensity = edgePixels / totalPixels;
                
                const mean = grayscale.reduce((sum, val) => sum + val, 0) / grayscale.length;
                const variance = grayscale.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / grayscale.length;
                const textureComplexity = Math.sqrt(variance) / 255;
                
                return {
                    edgeDensity,
                    textureComplexity
                };
            }

            performStatisticalAnalysis(natureResults, ornateResults) {
                const metrics = ['avgSaturation', 'avgBrightness', 'avgColorDiversity', 
                               'avgNegativeSpace', 'avgEdgeDensity', 'avgTextureComplexity', 'avgSymmetry'];
                
                const results = {};
                
                metrics.forEach(metric => {
                    const natureData = natureResults.images.map(img => {
                        const key = metric.replace('avg', '').toLowerCase();
                        return img[key] || 0;
                    });
                    
                    const ornateData = ornateResults.images.map(img => {
                        const key = metric.replace('avg', '').toLowerCase();
                        return img[key] || 0;
                    });
                    
                    const natureMean = natureData.reduce((sum, val) => sum + val, 0) / natureData.length;
                    const ornateMean = ornateData.reduce((sum, val) => sum + val, 0) / ornateData.length;
                    
                    const ttest = this.performTTest(natureData, ornateData);
                    
                    results[metric] = {
                        natureMean: natureMean,
                        ornateMean: ornateMean,
                        difference: ((natureMean - ornateMean) / ornateMean) * 100,
                        tStatistic: ttest.tStat,
                        pValue: ttest.pValue,
                        significant: ttest.pValue < 0.05
                    };
                });
                
                return results;
            }

            performTTest(group1, group2) {
                const n1 = group1.length;
                const n2 = group2.length;
                
                const mean1 = group1.reduce((sum, val) => sum + val, 0) / n1;
                const mean2 = group2.reduce((sum, val) => sum + val, 0) / n2;
                
                const var1 = group1.reduce((sum, val) => sum + Math.pow(val - mean1, 2), 0) / (n1 - 1);
                const var2 = group2.reduce((sum, val) => sum + Math.pow(val - mean2, 2), 0) / (n2 - 1);
                
                const pooledVar = ((n1 - 1) * var1 + (n2 - 1) * var2) / (n1 + n2 - 2);
                const standardError = Math.sqrt(pooledVar * (1/n1 + 1/n2));
                
                const tStat = (mean1 - mean2) / standardError;
                
                const df = n1 + n2 - 2;
                let pValue;
                
                if (Math.abs(tStat) > 2.576) pValue = 0.01;
                else if (Math.abs(tStat) > 1.96) pValue = 0.05;
                else if (Math.abs(tStat) > 1.645) pValue = 0.10;
                else pValue = 0.20;
                
                return { tStat, pValue };
            }

            displayResults() {
                this.displayIndividualResults();
                this.displayTeamComparison();
                this.displayStatisticalSignificance();
                this.generateResearchReport();
                this.updateChart();
            }

            displayIndividualResults() {
                const container = document.getElementById('individualResults');
                container.innerHTML = '';
                
                Object.keys(this.analysisResults.individual).forEach(style => {
                    const results = this.analysisResults.individual[style];
                    const card = document.createElement('div');
                    card.className = `style-result-card ${style}`;
                    
                    card.innerHTML = `
                        <h4>${this.getStyleName(style)}</h4>
                        <div class="stats-grid">
                            <div class="stat-item">
                                <div class="stat-label">í‰ê·  ì±„ë„</div>
                                <div class="stat-value">${results.aggregated.avgSaturation.toFixed(3)}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">í‰ê·  ëª…ë„</div>
                                <div class="stat-value">${results.aggregated.avgBrightness.toFixed(3)}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">ìƒ‰ìƒ ë‹¤ì–‘ì„±</div>
                                <div class="stat-value">${results.aggregated.avgColorDiversity.toFixed(3)}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">ì—¬ë°± ë¹„ìœ¨</div>
                                <div class="stat-value">${results.aggregated.avgNegativeSpace.toFixed(3)}</div>
                            </div>
                        </div>
                    `;
                    
                    container.appendChild(card);
                });
            }

            displayTeamComparison() {
                const container = document.getElementById('teamComparison');
                container.innerHTML = '';
                
                const teamNames = {
                    nature: 'ì ˆì œì  ìì—° ì¹œí™”í˜•',
                    ornate: 'ì¥ì‹ì  í™”ë ¤í•¨ ê³¼ì‹œí˜•'
                };
                
                ['nature', 'ornate'].forEach(team => {
                    const results = this.analysisResults.teams[team];
                    const card = document.createElement('div');
                    card.className = `style-result-card ${team}`;
                    
                    card.innerHTML = `
                        <h4>${teamNames[team]}</h4>
                        <div class="stats-grid">
                            <div class="stat-item">
                                <div class="stat-label">í‰ê·  ì±„ë„</div>
                                <div class="stat-value">${results.aggregated.avgSaturation.toFixed(3)}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">í‰ê·  ëª…ë„</div>
                                <div class="stat-value">${results.aggregated.avgBrightness.toFixed(3)}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">ìƒ‰ìƒ ë‹¤ì–‘ì„±</div>
                                <div class="stat-value">${results.aggregated.avgColorDiversity.toFixed(3)}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">ì—¬ë°± ë¹„ìœ¨</div>
                                <div class="stat-value">${results.aggregated.avgNegativeSpace.toFixed(3)}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">ì—£ì§€ ë°€ë„</div>
                                <div class="stat-value">${results.aggregated.avgEdgeDensity.toFixed(3)}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">í…ìŠ¤ì²˜ ë³µì¡ì„±</div>
                                <div class="stat-value">${results.aggregated.avgTextureComplexity.toFixed(3)}</div>
                            </div>
                        </div>
                    `;
                    
                    container.appendChild(card);
                });
            }

            displayStatisticalSignificance() {
                const tableBody = document.querySelector('#significanceTable tbody');
                tableBody.innerHTML = '';
                
                const metricNames = {
                    'avgSaturation': 'í‰ê·  ì±„ë„',
                    'avgBrightness': 'í‰ê·  ëª…ë„',
                    'avgColorDiversity': 'ìƒ‰ìƒ ë‹¤ì–‘ì„±',
                    'avgNegativeSpace': 'ì—¬ë°± ë¹„ìœ¨',
                    'avgEdgeDensity': 'ì—£ì§€ ë°€ë„',
                    'avgTextureComplexity': 'í…ìŠ¤ì²˜ ë³µì¡ì„±',
                    'avgSymmetry': 'ëŒ€ì¹­ì„±'
                };
                
                Object.keys(this.analysisResults.statistical).forEach(metric => {
                    const result = this.analysisResults.statistical[metric];
                    const significanceClass = result.significant ? 'significant' : 'not-significant';
                    const significanceText = result.significant ? 'ìœ ì˜ë¯¸ âœ“' : 'ìœ ì˜ë¯¸í•˜ì§€ ì•ŠìŒ âœ—';
                    
                    tableBody.innerHTML += `
                        <tr>
                            <td>${metricNames[metric]}</td>
                            <td>${result.natureMean.toFixed(3)}</td>
                            <td>${result.ornateMean.toFixed(3)}</td>
                            <td>${result.difference.toFixed(1)}%</td>
                            <td>${result.pValue.toFixed(3)}</td>
                            <td class="${significanceClass}">${significanceText}</td>
                        </tr>
                    `;
                });
            }

            generateResearchReport() {
                const keyFindings = document.getElementById('keyFindings');
                const conclusions = document.getElementById('conclusions');
                
                const significantFindings = [];
                Object.keys(this.analysisResults.statistical).forEach(metric => {
                    const result = this.analysisResults.statistical[metric];
                    if (result.significant) {
                        const direction = result.difference > 0 ? 'ë†’ê²Œ' : 'ë‚®ê²Œ';
                        const metricName = this.getMetricName(metric);
                        significantFindings.push(`â€¢ ${metricName}: ì ˆì œì  ìì—° ì¹œí™”í˜•ì´ ${Math.abs(result.difference).toFixed(1)}% ${direction} ë‚˜íƒ€ë‚¨ (p=${result.pValue.toFixed(3)})`);
                    }
                });
                
                if (significantFindings.length > 0) {
                    keyFindings.innerHTML = `
                        <p><strong>í†µê³„ì ìœ¼ë¡œ ìœ ì˜ë¯¸í•œ ì°¨ì´ê°€ ë°œê²¬ëœ ì§€í‘œ:</strong></p>
                        <ul style="margin-left: 20px; margin-top: 10px;">
                            ${significantFindings.join('<br>')}
                        </ul>
                    `;
                } else {
                    keyFindings.innerHTML = `
                        <p>ë¶„ì„ ê²°ê³¼, ë‘ ê·¸ë£¹ ê°„ì— í†µê³„ì ìœ¼ë¡œ ìœ ì˜ë¯¸í•œ ì°¨ì´ë¥¼ ë°œê²¬í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.</p>
                    `;
                }
                
                conclusions.innerHTML = `
                    <p>ë³¸ ì—°êµ¬ë¥¼ í†µí•´ ë™ì„œì–‘ ê±´ì¶• ì–‘ì‹ì˜ ì‹œê°ì  íŠ¹ì„±ì„ ì •ëŸ‰ì ìœ¼ë¡œ ë¶„ì„í•˜ê³  ë¹„êµí•  ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤. 
                    ì»´í“¨í„° ë¹„ì „ ê¸°ìˆ ì„ í™œìš©í•œ ì´ëŸ¬í•œ ì ‘ê·¼ì€ ë¬¸í™”ì  ë¯¸í•™ì„ ê°ê´€ì ìœ¼ë¡œ ì´í•´í•˜ëŠ” ìƒˆë¡œìš´ ë°©ë²•ë¡ ì„ ì œì‹œí•©ë‹ˆë‹¤.</p>
                `;
            }

            updateChart() {
                const chartType = document.getElementById('chartType').value;
                const canvas = document.getElementById('comparisonChart');
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const metricSelector = document.getElementById('metricSelector');
                
                switch(chartType) {
                    case 'bar4':
                        metricSelector.style.display = 'none';
                        this.draw4StylesBarChart(ctx, canvas);
                        break;
                    case 'barTeam':
                        metricSelector.style.display = 'none';
                        this.drawTeamBarChart(ctx, canvas);
                        break;
                    case 'radar':
                        metricSelector.style.display = 'none';
                        this.drawRadarChart(ctx, canvas);
                        break;
                    case 'boxplot':
                        metricSelector.style.display = 'flex';
                        this.drawBoxplot(ctx, canvas);
                        break;
                    case 'scatter':
                        metricSelector.style.display = 'flex';
                        this.drawScatter(ctx, canvas);
                        break;
                    case 'histogram':
                        metricSelector.style.display = 'flex';
                        this.drawHistogram(ctx, canvas);
                        break;
                    default:
                        this.draw4StylesBarChart(ctx, canvas);
                }
                
                this.updateChartDescription(chartType);
            }

            draw4StylesBarChart(ctx, canvas) {
                const styles = ['lagom', 'hanok', 'baroque', 'rococo'];
                const colors = {
                    lagom: '#27ae60',
                    hanok: '#2ecc71',
                    baroque: '#e74c3c',
                    rococo: '#c0392b'
                };
                
                const metrics = ['ì±„ë„', 'ëª…ë„', 'ìƒ‰ìƒë‹¤ì–‘ì„±', 'ì—¬ë°±ë¹„ìœ¨', 'ì—£ì§€ë°€ë„', 'í…ìŠ¤ì²˜ë³µì¡ì„±', 'ëŒ€ì¹­ì„±'];
                const metricKeys = ['avgSaturation', 'avgBrightness', 'avgColorDiversity', 
                                   'avgNegativeSpace', 'avgEdgeDensity', 'avgTextureComplexity', 'avgSymmetry'];
                
                const padding = 80;
                const chartWidth = canvas.width - 2 * padding;
                const chartHeight = canvas.height - 2 * padding;
                const groupWidth = chartWidth / metrics.length;
                const barWidth = groupWidth / (styles.length + 1);
                
                // ë°°ê²½
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ì¶• ê·¸ë¦¬ê¸°
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, padding + chartHeight);
                ctx.lineTo(padding + chartWidth, padding + chartHeight);
                ctx.stroke();
                
                // ë°ì´í„° ê·¸ë¦¬ê¸°
                let maxValue = 0;
                styles.forEach(style => {
                    metricKeys.forEach(key => {
                        const value = this.analysisResults.individual[style].aggregated[key];
                        maxValue = Math.max(maxValue, value);
                    });
                });
                
                metrics.forEach((metric, metricIndex) => {
                    const x = padding + metricIndex * groupWidth;
                    
                    styles.forEach((style, styleIndex) => {
                        const value = this.analysisResults.individual[style].aggregated[metricKeys[metricIndex]];
                        const height = (value / maxValue) * chartHeight;
                        const barX = x + styleIndex * barWidth + barWidth/2;
                        
                        ctx.fillStyle = colors[style];
                        ctx.fillRect(barX, padding + chartHeight - height, barWidth * 0.8, height);
                    });
                    
                    // Xì¶• ë¼ë²¨
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '11px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(metric, x + groupWidth/2, padding + chartHeight + 20);
                });
                
                // ì œëª©
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('4ê°€ì§€ ì–‘ì‹ë³„ ì§€í‘œ ë¹„êµ', canvas.width / 2, 30);
                
                // ë²”ë¡€
                const legendY = 50;
                let legendX = canvas.width - 350;
                
                styles.forEach((style, index) => {
                    ctx.fillStyle = colors[style];
                    ctx.fillRect(legendX + index * 80, legendY, 15, 15);
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(this.getStyleName(style), legendX + index * 80 + 20, legendY + 12);
                });
            }

            drawTeamBarChart(ctx, canvas) {
                const metrics = ['ì±„ë„', 'ëª…ë„', 'ìƒ‰ìƒë‹¤ì–‘ì„±', 'ì—¬ë°±ë¹„ìœ¨', 'ì—£ì§€ë°€ë„', 'í…ìŠ¤ì²˜ë³µì¡ì„±', 'ëŒ€ì¹­ì„±'];
                const metricKeys = ['avgSaturation', 'avgBrightness', 'avgColorDiversity', 
                                   'avgNegativeSpace', 'avgEdgeDensity', 'avgTextureComplexity', 'avgSymmetry'];
                
                const padding = 80;
                const chartWidth = canvas.width - 2 * padding;
                const chartHeight = canvas.height - 2 * padding;
                const barWidth = chartWidth / (metrics.length * 2.5);
                
                // ë°°ê²½
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ì¶• ê·¸ë¦¬ê¸°
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, padding + chartHeight);
                ctx.lineTo(padding + chartWidth, padding + chartHeight);
                ctx.stroke();
                
                // ë°ì´í„° ìµœëŒ€ê°’ ì°¾ê¸°
                let maxValue = 0;
                metricKeys.forEach(key => {
                    maxValue = Math.max(maxValue, 
                        this.analysisResults.teams.nature.aggregated[key],
                        this.analysisResults.teams.ornate.aggregated[key]
                    );
                });
                
                // ë§‰ëŒ€ ê·¸ë¦¬ê¸°
                metrics.forEach((metric, index) => {
                    const x = padding + index * barWidth * 2.5;
                    
                    // ì ˆì œì  ìì—° ì¹œí™”í˜•
                    const natureValue = this.analysisResults.teams.nature.aggregated[metricKeys[index]];
                    const natureHeight = (natureValue / maxValue) * chartHeight;
                    ctx.fillStyle = '#27ae60';
                    ctx.fillRect(x, padding + chartHeight - natureHeight, barWidth, natureHeight);
                    
                    // ì¥ì‹ì  í™”ë ¤í•¨ ê³¼ì‹œí˜•
                    const ornateValue = this.analysisResults.teams.ornate.aggregated[metricKeys[index]];
                    const ornateHeight = (ornateValue / maxValue) * chartHeight;
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillRect(x + barWidth + 5, padding + chartHeight - ornateHeight, barWidth, ornateHeight);
                    
                    // Xì¶• ë¼ë²¨
                    ctx.save();
                    ctx.translate(x + barWidth, padding + chartHeight + 15);
                    ctx.rotate(-Math.PI / 6);
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '11px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(metric, 0, 0);
                    ctx.restore();
                });
                
                // Yì¶• ëˆˆê¸ˆ
                for (let i = 0; i <= 5; i++) {
                    const y = padding + chartHeight - (chartHeight * i / 5);
                    const value = (maxValue * i / 5).toFixed(2);
                    
                    ctx.strokeStyle = '#ecf0f1';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(padding + chartWidth, y);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText(value, padding - 10, y + 3);
                }
                
                // ì œëª©
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('íŒ€ë³„ ë¹„êµ: ì ˆì œì  ìì—° ì¹œí™”í˜• vs ì¥ì‹ì  í™”ë ¤í•¨ ê³¼ì‹œí˜•', canvas.width / 2, 30);
                
                // ë²”ë¡€
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(canvas.width - 250, 50, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('ì ˆì œì  ìì—° ì¹œí™”í˜•', canvas.width - 225, 62);
                
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(canvas.width - 250, 70, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.fillText('ì¥ì‹ì  í™”ë ¤í•¨ ê³¼ì‹œí˜•', canvas.width - 225, 82);
            }

            drawRadarChart(ctx, canvas) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(canvas.width, canvas.height) / 3;
                
                const metrics = ['ì±„ë„', 'ëª…ë„', 'ìƒ‰ìƒë‹¤ì–‘ì„±', 'ì—¬ë°±ë¹„ìœ¨', 'ì—£ì§€ë°€ë„', 'í…ìŠ¤ì²˜ë³µì¡ì„±', 'ëŒ€ì¹­ì„±'];
                const metricKeys = ['avgSaturation', 'avgBrightness', 'avgColorDiversity', 
                                   'avgNegativeSpace', 'avgEdgeDensity', 'avgTextureComplexity', 'avgSymmetry'];
                const numMetrics = metrics.length;
                
                // ë°°ê²½
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ê²©ì ê·¸ë¦¬ê¸°
                ctx.strokeStyle = '#ecf0f1';
                ctx.lineWidth = 1;
                
                for (let level = 0.2; level <= 1; level += 0.2) {
                    ctx.beginPath();
                    for (let i = 0; i <= numMetrics; i++) {
                        const angle = (i * 2 * Math.PI) / numMetrics - Math.PI / 2;
                        const x = centerX + Math.cos(angle) * radius * level;
                        const y = centerY + Math.sin(angle) * radius * level;
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                // ì¶• ê·¸ë¦¬ê¸°
                ctx.strokeStyle = '#bdc3c7';
                for (let i = 0; i < numMetrics; i++) {
                    const angle = (i * 2 * Math.PI) / numMetrics - Math.PI / 2;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                    
                    // ë¼ë²¨
                    const labelX = centerX + Math.cos(angle) * (radius + 25);
                    const labelY = centerY + Math.sin(angle) * (radius + 25);
                    
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '11px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(metrics[i], labelX, labelY);
                }
                
                // ë°ì´í„° ì •ê·œí™”
                let maxValues = {};
                metricKeys.forEach(key => {
                    maxValues[key] = Math.max(
                        this.analysisResults.teams.nature.aggregated[key],
                        this.analysisResults.teams.ornate.aggregated[key]
                    );
                });
                
                // ì ˆì œì  ìì—° ì¹œí™”í˜• ë°ì´í„°
                ctx.strokeStyle = '#27ae60';
                ctx.fillStyle = '#27ae6040';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i <= numMetrics; i++) {
                    const dataIndex = i % numMetrics;
                    const angle = (i * 2 * Math.PI) / numMetrics - Math.PI / 2;
                    const value = this.analysisResults.teams.nature.aggregated[metricKeys[dataIndex]] / maxValues[metricKeys[dataIndex]];
                    const x = centerX + Math.cos(angle) * radius * value;
                    const y = centerY + Math.sin(angle) * radius * value;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                ctx.fill();
                
                // ì¥ì‹ì  í™”ë ¤í•¨ ê³¼ì‹œí˜• ë°ì´í„°
                ctx.strokeStyle = '#e74c3c';
                ctx.fillStyle = '#e74c3c40';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i <= numMetrics; i++) {
                    const dataIndex = i % numMetrics;
                    const angle = (i * 2 * Math.PI) / numMetrics - Math.PI / 2;
                    const value = this.analysisResults.teams.ornate.aggregated[metricKeys[dataIndex]] / maxValues[metricKeys[dataIndex]];
                    const x = centerX + Math.cos(angle) * radius * value;
                    const y = centerY + Math.sin(angle) * radius * value;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                ctx.fill();
                
                // ì œëª©
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ë ˆì´ë” ì°¨íŠ¸: ì¢…í•© ì§€í‘œ ë¹„êµ', canvas.width / 2, 30);
                
                // ë²”ë¡€
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(50, 50, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('ì ˆì œì  ìì—° ì¹œí™”í˜•', 75, 62);
                
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(50, 70, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.fillText('ì¥ì‹ì  í™”ë ¤í•¨ ê³¼ì‹œí˜•', 75, 82);
            }

            drawBoxplot(ctx, canvas) {
                const selectedMetric = document.getElementById('selectedMetric')?.value || 'saturation';
                const metricKey = selectedMetric.replace('avg', '').toLowerCase();
                
                // ê° ìŠ¤íƒ€ì¼ë³„ ë°ì´í„° ì¶”ì¶œ
                const data = {};
                Object.keys(this.styles).forEach(style => {
                    data[style] = this.analysisResults.individual[style].images.map(img => img[metricKey] || 0).filter(val => val > 0);
                });
                
                if (Object.values(data).some(arr => arr.length === 0)) {
                    ctx.fillStyle = '#e74c3c';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('ë°ì´í„°ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤', canvas.width / 2, canvas.height / 2);
                    return;
                }
                
                // ë°•ìŠ¤í”Œë¡¯ í†µê³„ ê³„ì‚°
                const stats = {};
                Object.keys(data).forEach(style => {
                    stats[style] = this.calculateBoxStats(data[style]);
                });
                
                const allValues = Object.values(data).flat();
                const minVal = Math.min(...allValues);
                const maxVal = Math.max(...allValues);
                const range = maxVal - minVal;
                
                const padding = 80;
                const chartHeight = canvas.height - 2 * padding;
                const styles = ['lagom', 'hanok', 'baroque', 'rococo'];
                const colors = {
                    lagom: '#27ae60',
                    hanok: '#2ecc71',
                    baroque: '#e74c3c',
                    rococo: '#c0392b'
                };
                
                // ë°°ê²½
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Yì¶• ê·¸ë¦¬ê¸°
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, padding + chartHeight);
                ctx.stroke();
                
                // Yì¶• ëˆˆê¸ˆê³¼ ê²©ì
                for (let i = 0; i <= 5; i++) {
                    const y = padding + chartHeight - (chartHeight * i / 5);
                    const value = minVal + (range * i / 5);
                    
                    // ê²©ìì„ 
                    ctx.strokeStyle = '#ecf0f1';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(canvas.width - padding, y);
                    ctx.stroke();
                    
                    // ë¼ë²¨
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText(value.toFixed(3), padding - 10, y + 3);
                }
                
                // ê° ìŠ¤íƒ€ì¼ë³„ ë°•ìŠ¤í”Œë¡¯ ê·¸ë¦¬ê¸°
                const boxWidth = 60;
                const spacing = (canvas.width - 2 * padding) / (styles.length + 1);
                
                styles.forEach((style, index) => {
                    const centerX = padding + (index + 1) * spacing;
                    this.drawSingleBoxPlot(ctx, stats[style], centerX, padding, chartHeight, minVal, range, colors[style], this.getStyleName(style));
                });
                
                // ì œëª©
                const metricNames = {
                    'saturation': 'í‰ê·  ì±„ë„',
                    'brightness': 'í‰ê·  ëª…ë„',
                    'colordiversity': 'ìƒ‰ìƒ ë‹¤ì–‘ì„±',
                    'negativespace': 'ì—¬ë°± ë¹„ìœ¨',
                    'edgedensity': 'ì—£ì§€ ë°€ë„',
                    'texturecomplexity': 'í…ìŠ¤ì²˜ ë³µì¡ì„±',
                    'symmetry': 'ëŒ€ì¹­ì„±'
                };
                
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${metricNames[metricKey]} ë°•ìŠ¤í”Œë¡¯ ë¹„êµ`, canvas.width / 2, 30);
            }

            drawScatter(ctx, canvas) {
                const selectedMetric = document.getElementById('selectedMetric')?.value || 'saturation';
                const metricKey = selectedMetric.replace('avg', '').toLowerCase();
                const correlationMetric = 'negativespace'; // ì—¬ë°± ë¹„ìœ¨ê³¼ ë¹„êµ
                
                // íŒ€ë³„ ë°ì´í„° ì¶”ì¶œ
                const natureDataX = this.analysisResults.teams.nature.images.map(img => img[metricKey] || 0);
                const natureDataY = this.analysisResults.teams.nature.images.map(img => img[correlationMetric] || 0);
                const ornateDataX = this.analysisResults.teams.ornate.images.map(img => img[metricKey] || 0);
                const ornateDataY = this.analysisResults.teams.ornate.images.map(img => img[correlationMetric] || 0);
                
                const allX = [...natureDataX, ...ornateDataX].filter(v => v > 0);
                const allY = [...natureDataY, ...ornateDataY].filter(v => v > 0);
                
                if (allX.length === 0 || allY.length === 0) {
                    ctx.fillStyle = '#e74c3c';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('ë°ì´í„°ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤', canvas.width / 2, canvas.height / 2);
                    return;
                }
                
                const minX = Math.min(...allX);
                const maxX = Math.max(...allX);
                const minY = Math.min(...allY);
                const maxY = Math.max(...allY);
                
                const padding = 80;
                const chartWidth = canvas.width - 2 * padding;
                const chartHeight = canvas.height - 2 * padding;
                
                // ë°°ê²½
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ì¶•ê³¼ ê²©ì ê·¸ë¦¬ê¸°
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, padding + chartHeight);
                ctx.lineTo(padding + chartWidth, padding + chartHeight);
                ctx.stroke();
                
                // ê²©ì
                ctx.strokeStyle = '#ecf0f1';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 5; i++) {
                    // ì„¸ë¡œ ê²©ì
                    const x = padding + (chartWidth * i / 5);
                    ctx.beginPath();
                    ctx.moveTo(x, padding);
                    ctx.lineTo(x, padding + chartHeight);
                    ctx.stroke();
                    
                    // ê°€ë¡œ ê²©ì
                    const y = padding + (chartHeight * i / 5);
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(padding + chartWidth, y);
                    ctx.stroke();
                }
                
                // ì ë“¤ ê·¸ë¦¬ê¸°
                for (let i = 0; i < natureDataX.length; i++) {
                    if (natureDataX[i] > 0 && natureDataY[i] > 0) {
                        const x = padding + ((natureDataX[i] - minX) / (maxX - minX)) * chartWidth;
                        const y = padding + chartHeight - ((natureDataY[i] - minY) / (maxY - minY)) * chartHeight;
                        
                        ctx.fillStyle = '#27ae60';
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }
                
                for (let i = 0; i < ornateDataX.length; i++) {
                    if (ornateDataX[i] > 0 && ornateDataY[i] > 0) {
                        const x = padding + ((ornateDataX[i] - minX) / (maxX - minX)) * chartWidth;
                        const y = padding + chartHeight - ((ornateDataY[i] - minY) / (maxY - minY)) * chartHeight;
                        
                        ctx.fillStyle = '#e74c3c';
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }
                
                // ì¶• ë¼ë²¨
                const metricNames = {
                    'saturation': 'í‰ê·  ì±„ë„',
                    'brightness': 'í‰ê·  ëª…ë„',
                    'colordiversity': 'ìƒ‰ìƒ ë‹¤ì–‘ì„±',
                    'negativespace': 'ì—¬ë°± ë¹„ìœ¨',
                    'edgedensity': 'ì—£ì§€ ë°€ë„',
                    'texturecomplexity': 'í…ìŠ¤ì²˜ ë³µì¡ì„±',
                    'symmetry': 'ëŒ€ì¹­ì„±'
                };
                
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(metricNames[metricKey], canvas.width/2, canvas.height - 20);
                
                ctx.save();
                ctx.translate(15, canvas.height/2);
                ctx.rotate(-Math.PI/2);
                ctx.fillText(metricNames[correlationMetric], 0, 0);
                ctx.restore();
                
                // ì œëª©
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${metricNames[metricKey]} vs ${metricNames[correlationMetric]}`, canvas.width / 2, 30);
                
                // ë²”ë¡€
                const legendY = canvas.height - 60;
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(canvas.width - 250, legendY, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('ì ˆì œì  ìì—° ì¹œí™”í˜•', canvas.width - 225, legendY + 12);
                
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(canvas.width - 250, legendY + 20, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.fillText('ì¥ì‹ì  í™”ë ¤í•¨ ê³¼ì‹œí˜•', canvas.width - 225, legendY + 32);
            }

            drawHistogram(ctx, canvas) {
                const selectedMetric = document.getElementById('selectedMetric')?.value || 'saturation';
                const metricKey = selectedMetric.replace('avg', '').toLowerCase();
                
                const natureValues = this.analysisResults.teams.nature.images.map(img => img[metricKey] || 0).filter(val => val > 0);
                const ornateValues = this.analysisResults.teams.ornate.images.map(img => img[metricKey] || 0).filter(val => val > 0);
                
                if (natureValues.length === 0 || ornateValues.length === 0) {
                    ctx.fillStyle = '#e74c3c';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('ë°ì´í„°ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤', canvas.width / 2, canvas.height / 2);
                    return;
                }
                
                const allValues = [...natureValues, ...ornateValues];
                const minVal = Math.min(...allValues);
                const maxVal = Math.max(...allValues);
                const range = maxVal - minVal;
                const bins = 8;
                const binWidth = range / bins;
                
                // íˆìŠ¤í† ê·¸ë¨ ê³„ì‚°
                const natureHist = new Array(bins).fill(0);
                const ornateHist = new Array(bins).fill(0);
                
                natureValues.forEach(value => {
                    const binIndex = Math.min(Math.floor((value - minVal) / binWidth), bins - 1);
                    natureHist[binIndex]++;
                });
                
                ornateValues.forEach(value => {
                    const binIndex = Math.min(Math.floor((value - minVal) / binWidth), bins - 1);
                    ornateHist[binIndex]++;
                });
                
                const maxCount = Math.max(...natureHist, ...ornateHist, 1);
                const padding = 80;
                const chartWidth = canvas.width - 2 * padding;
                const chartHeight = canvas.height - 2 * padding;
                const barWidth = chartWidth / bins;
                
                // ë°°ê²½
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ì¶• ê·¸ë¦¬ê¸°
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, padding + chartHeight);
                ctx.lineTo(padding + chartWidth, padding + chartHeight);
                ctx.stroke();
                
                // íˆìŠ¤í† ê·¸ë¨ ê·¸ë¦¬ê¸°
                for (let i = 0; i < bins; i++) {
                    const x = padding + i * barWidth;
                    
                    // ì ˆì œì  ìì—° ì¹œí™”í˜•
                    const natureHeight = (natureHist[i] / maxCount) * chartHeight;
                    ctx.fillStyle = '#27ae6080';
                    ctx.fillRect(x + 2, padding + chartHeight - natureHeight, barWidth * 0.4, natureHeight);
                    
                    // ì¥ì‹ì  í™”ë ¤í•¨ ê³¼ì‹œí˜•
                    const ornateHeight = (ornateHist[i] / maxCount) * chartHeight;
                    ctx.fillStyle = '#e74c3c80';
                    ctx.fillRect(x + barWidth * 0.5, padding + chartHeight - ornateHeight, barWidth * 0.4, ornateHeight);
                    
                    // Xì¶• ë¼ë²¨ (ì¼ë¶€ë§Œ)
                    if (i % 2 === 0) {
                        const binValue = minVal + i * binWidth;
                        ctx.fillStyle = '#2c3e50';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(binValue.toFixed(2), x + barWidth/2, padding + chartHeight + 20);
                    }
                }
                
                // Yì¶• ëˆˆê¸ˆ
                for (let i = 0; i <= 5; i++) {
                    const y = padding + chartHeight - (chartHeight * i / 5);
                    const count = Math.round(maxCount * i / 5);
                    
                    ctx.strokeStyle = '#ecf0f1';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(padding + chartWidth, y);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText(count.toString(), padding - 10, y + 3);
                }
                
                // ì œëª©
                const metricNames = {
                    'saturation': 'í‰ê·  ì±„ë„',
                    'brightness': 'í‰ê·  ëª…ë„',
                    'colordiversity': 'ìƒ‰ìƒ ë‹¤ì–‘ì„±',
                    'negativespace': 'ì—¬ë°± ë¹„ìœ¨',
                    'edgedensity': 'ì—£ì§€ ë°€ë„',
                    'texturecomplexity': 'í…ìŠ¤ì²˜ ë³µì¡ì„±',
                    'symmetry': 'ëŒ€ì¹­ì„±'
                };
                
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${metricNames[metricKey]} ë¶„í¬ ë¹„êµ`, canvas.width / 2, 30);
                
                // ë²”ë¡€
                const legendY = canvas.height - 60;
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(canvas.width - 250, legendY, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('ì ˆì œì  ìì—° ì¹œí™”í˜•', canvas.width - 225, legendY + 12);
                
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(canvas.width - 250, legendY + 20, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.fillText('ì¥ì‹ì  í™”ë ¤í•¨ ê³¼ì‹œí˜•', canvas.width - 225, legendY + 32);
            }

            calculateBoxStats(values) {
                const sorted = [...values].sort((a, b) => a - b);
                const n = sorted.length;
                
                if (n === 0) return null;
                
                const q1Index = Math.floor(n * 0.25);
                const medianIndex = Math.floor(n * 0.5);
                const q3Index = Math.floor(n * 0.75);
                
                const q1 = sorted[q1Index];
                const median = sorted[medianIndex];
                const q3 = sorted[q3Index];
                const iqr = q3 - q1;
                
                return {
                    min: sorted[0],
                    q1,
                    median,
                    q3,
                    max: sorted[n - 1],
                    lowerWhisker: Math.max(sorted[0], q1 - 1.5 * iqr),
                    upperWhisker: Math.min(sorted[n - 1], q3 + 1.5 * iqr),
                    outliers: sorted.filter(v => v < q1 - 1.5 * iqr || v > q3 + 1.5 * iqr)
                };
            }

            drawSingleBoxPlot(ctx, stats, centerX, startY, chartHeight, minVal, range, color, label) {
                if (!stats) return;
                
                const boxWidth = 50;
                const valueToY = (value) => startY + chartHeight - ((value - minVal) / range) * chartHeight;
                
                // ìˆ˜ì—¼ ê·¸ë¦¬ê¸°
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                
                // ìœ„ìª½ ìˆ˜ì—¼
                ctx.beginPath();
                ctx.moveTo(centerX, valueToY(stats.upperWhisker));
                ctx.lineTo(centerX, valueToY(stats.q3));
                ctx.stroke();
                
                // ì•„ë˜ìª½ ìˆ˜ì—¼
                ctx.beginPath();
                ctx.moveTo(centerX, valueToY(stats.q1));
                ctx.lineTo(centerX, valueToY(stats.lowerWhisker));
                ctx.stroke();
                
                // ìˆ˜ì—¼ ë í‘œì‹œ
                ctx.beginPath();
                ctx.moveTo(centerX - 15, valueToY(stats.upperWhisker));
                ctx.lineTo(centerX + 15, valueToY(stats.upperWhisker));
                ctx.moveTo(centerX - 15, valueToY(stats.lowerWhisker));
                ctx.lineTo(centerX + 15, valueToY(stats.lowerWhisker));
                ctx.stroke();
                
                // ë°•ìŠ¤ ê·¸ë¦¬ê¸°
                const boxY = valueToY(stats.q3);
                const boxHeight = valueToY(stats.q1) - valueToY(stats.q3);
                
                ctx.fillStyle = color + '40';
                ctx.fillRect(centerX - boxWidth/2, boxY, boxWidth, boxHeight);
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.strokeRect(centerX - boxWidth/2, boxY, boxWidth, boxHeight);
                
                // ì¤‘ì•™ê°’ ì„ 
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX - boxWidth/2, valueToY(stats.median));
                ctx.lineTo(centerX + boxWidth/2, valueToY(stats.median));
                ctx.stroke();
                
                // ì´ìƒì¹˜ í‘œì‹œ
                ctx.fillStyle = color;
                stats.outliers.forEach(outlier => {
                    ctx.beginPath();
                    ctx.arc(centerX, valueToY(outlier), 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                // ë¼ë²¨
                ctx.fillStyle = '#2c3e50';
                ctx.font = '11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(label, centerX, startY + chartHeight + 30);
            }

            updateChartDescription(chartType) {
                const descriptions = {
                    'bar4': 'ë§‰ëŒ€ ê·¸ë˜í”„ëŠ” 4ê°€ì§€ ì–‘ì‹ì˜ ê° ì§€í‘œë³„ í‰ê· ê°’ì„ ë¹„êµí•©ë‹ˆë‹¤.',
                    'barTeam': 'íŒ€ë³„ ë¹„êµ ë§‰ëŒ€ ê·¸ë˜í”„ëŠ” ì ˆì œì  ìì—° ì¹œí™”í˜•ê³¼ ì¥ì‹ì  í™”ë ¤í•¨ ê³¼ì‹œí˜•ì˜ ì°¨ì´ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤.',
                    'radar': 'ë ˆì´ë” ì°¨íŠ¸ëŠ” ëª¨ë“  ì§€í‘œë¥¼ ì¢…í•©ì ìœ¼ë¡œ ë¹„êµí•©ë‹ˆë‹¤. ì¤‘ì‹¬ì—ì„œ ë©€ìˆ˜ë¡ ë†’ì€ ê°’ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.',
                    'boxplot': 'ë°•ìŠ¤í”Œë¡¯ì€ ë°ì´í„°ì˜ ë¶„í¬ì™€ ì´ìƒì¹˜ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤. ìƒìëŠ” 1ì‚¬ë¶„ìœ„ìˆ˜ì—ì„œ 3ì‚¬ë¶„ìœ„ìˆ˜ê¹Œì§€ì˜ ë²”ìœ„ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.',
                    'scatter': 'ì‚°ì ë„ëŠ” ë‘ ì§€í‘œ ê°„ì˜ ìƒê´€ê´€ê³„ë¥¼ ë¶„ì„í•©ë‹ˆë‹¤. ê° ì ì€ í•˜ë‚˜ì˜ ì´ë¯¸ì§€ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.',
                    'histogram': 'íˆìŠ¤í† ê·¸ë¨ì€ ì„ íƒí•œ ì§€í‘œì˜ ê°’ ë¶„í¬ë¥¼ ë¹„êµí•©ë‹ˆë‹¤. ë‘ ê·¸ë£¹ì˜ ë¶„í¬ íŒ¨í„´ ì°¨ì´ë¥¼ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.'
                };
                
                const descElement = document.getElementById('chartDescription');
                if (descElement) {
                    descElement.textContent = descriptions[chartType] || 'ì°¨íŠ¸ ì„¤ëª…ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
                }
            }

            getStyleName(style) {
                const names = {
                    lagom: 'ë¼ê³°',
                    hanok: 'í•œì˜¥',
                    baroque: 'ë°”ë¡œí¬',
                    rococo: 'ë¡œì½”ì½”'
                };
                return names[style] || style;
            }

            getMetricName(metric) {
                const names = {
                    'avgSaturation': 'í‰ê·  ì±„ë„',
                    'avgBrightness': 'í‰ê·  ëª…ë„',
                    'avgColorDiversity': 'ìƒ‰ìƒ ë‹¤ì–‘ì„±',
                    'avgNegativeSpace': 'ì—¬ë°± ë¹„ìœ¨',
                    'avgEdgeDensity': 'ì—£ì§€ ë°€ë„',
                    'avgTextureComplexity': 'í…ìŠ¤ì²˜ ë³µì¡ì„±',
                    'avgSymmetry': 'ëŒ€ì¹­ì„±'
                };
                return names[metric] || metric;
            }
        }

        // ì „ì—­ í•¨ìˆ˜ë“¤
        let analyzer;

        function clearStyle(style) {
            analyzer.styles[style] = [];
            document.getElementById(`${style}Input`).value = '';
            analyzer.updateImageCount(style);
            analyzer.checkAnalysisReady();
        }

        function startAnalysis() {
            analyzer.startAnalysis();
        }

        function exportResults() {
            const data = analyzer.analysisResults;
            if (!data) return;
            
            let csv = 'Style,Team,Filename,Saturation,Brightness,ColorDiversity,NegativeSpace,EdgeDensity,TextureComplexity,Symmetry\n';
            
            Object.keys(data.individual).forEach(style => {
                const team = analyzer.teams.nature.includes(style) ? 'Nature' : 'Ornate';
                data.individual[style].images.forEach(img => {
                    csv += `${style},${team},${img.filename},${img.saturation},${img.brightness},${img.colordiversity},${img.negativespace},${img.edgedensity},${img.texturecomplexity},${img.symmetry}\n`;
                });
            });
            
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'design_analysis_results.csv';
            link.click();
        }

        function exportPDF() {
            alert('PDF ë‚´ë³´ë‚´ê¸° ê¸°ëŠ¥ì€ ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” jsPDF ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ì—¬ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
        }

        function exportCSV() {
            exportResults();
        }

        function exportChart() {
            const canvas = document.getElementById('comparisonChart');
            const link = document.createElement('a');
            link.download = 'comparison_chart.png';
            link.href = canvas.toDataURL();
            link.click();
        }

        function updateChart() {
            if (analyzer && analyzer.analysisResults) {
                analyzer.updateChart();
            }
        }

        // ì•± ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', () => {
            analyzer = new DesignAnalyzer();
        });
    </script>
</body>
</html>
