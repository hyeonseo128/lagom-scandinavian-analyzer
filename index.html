<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>문화별 디자인 양식 비교 분석 시스템</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f8f9fa;
            line-height: 1.6;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px 0;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
            font-weight: 400;
        }

        .header .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            margin-bottom: 20px;
        }

        .keywords {
            font-size: 0.9rem;
            opacity: 0.8;
            font-style: italic;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .research-phases {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .phase-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            border-left: 4px solid #3498db;
            transition: transform 0.2s ease;
        }

        .phase-card:hover {
            transform: translateY(-2px);
        }

        .phase-card.active {
            border-left-color: #e74c3c;
            background: linear-gradient(135deg, #fff 0%, #f8f9ff 100%);
        }

        .phase-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }

        .phase-number {
            background: #3498db;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
            font-weight: bold;
        }

        .team-sections {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .team-container {
            background: white;
            border-radius: 16px;
            padding: 25px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.1);
        }

        .team-container.nature {
            border-top: 5px solid #27ae60;
        }

        .team-container.ornate {
            border-top: 5px solid #e74c3c;
        }

        .team-header {
            font-size: 1.6rem;
            font-weight: 700;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 15px;
            background: linear-gradient(135deg, #f8f9fa 0%, #ecf0f1 100%);
            border-radius: 10px;
        }

        .team-icon {
            margin-right: 15px;
            font-size: 2rem;
        }

        .styles-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .style-upload-group {
            background: #fafbfc;
            border-radius: 12px;
            padding: 20px;
            border: 2px solid #ecf0f1;
        }

        .style-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: #2c3e50;
            display: flex;
            align-items: center;
        }

        .style-icon {
            margin-right: 10px;
            font-size: 1.3rem;
        }

        .upload-area {
            border: 2px dashed #bdc3c7;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
        }

        .upload-area:hover {
            border-color: #3498db;
            background: #f8f9ff;
        }

        .upload-area.dragover {
            border-color: #2ecc71;
            background: #f0fff4;
            transform: scale(1.02);
        }

        .upload-btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 0.95rem;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s ease;
        }

        .upload-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }

        .upload-btn.clear {
            background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
        }

        .upload-btn.clear:hover {
            box-shadow: 0 5px 15px rgba(149, 165, 166, 0.3);
        }

        .image-count {
            margin-top: 10px;
            font-weight: 600;
            color: #2c3e50;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .count-badge {
            background: #ecf0f1;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.85rem;
        }

        .analysis-section {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }

        .analysis-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .analyze-btn {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .analyze-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(39, 174, 96, 0.3);
        }

        .analyze-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .progress-container {
            background: #ecf0f1;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: #d5dbdb;
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            transition: width 0.3s ease;
            border-radius: 6px;
        }

        .progress-text {
            text-align: center;
            font-weight: 600;
            color: #2c3e50;
        }

        .results-container {
            margin-top: 30px;
        }

        .individual-results {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .style-result-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border-left: 4px solid #3498db;
        }

        .style-result-card.lagom {
            border-left-color: #2ecc71;
        }

        .style-result-card.hanok {
            border-left-color: #27ae60;
        }

        .style-result-card.baroque {
            border-left-color: #e74c3c;
        }

        .style-result-card.rococo {
            border-left-color: #c0392b;
        }

        .team-comparison {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .stat-label {
            font-size: 0.9rem;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #2c3e50;
        }

        .statistical-analysis {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }

        .significance-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .significance-table th,
        .significance-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ecf0f1;
        }

        .significance-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #2c3e50;
        }

        .significant {
            color: #27ae60;
            font-weight: bold;
        }

        .not-significant {
            color: #e74c3c;
        }

        .chart-container {
            margin: 20px 0;
            text-align: center;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }

        .chart-controls {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .chart-selector, .metric-selector {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .chart-selector label, .metric-selector label {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9rem;
        }

        .chart-selector select, .metric-selector select {
            padding: 8px 15px;
            border: 2px solid #bdc3c7;
            border-radius: 6px;
            background: white;
            font-size: 0.9rem;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }

        .chart-selector select:focus, .metric-selector select:focus {
            outline: none;
            border-color: #3498db;
        }

        .chart-canvas {
            max-width: 100%;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            background: white;
            margin: 20px 0;
        }

        .chart-description {
            background: #f8f9ff;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            color: #2c3e50;
            font-size: 0.9rem;
            line-height: 1.5;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .research-report {
            background: white;
            border-radius: 12px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            line-height: 1.8;
        }

        .report-section {
            margin-bottom: 30px;
        }

        .report-section h3 {
            color: #2c3e50;
            font-size: 1.4rem;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #ecf0f1;
        }

        .export-controls {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            margin-top: 20px;
        }

        .export-btn {
            background: linear-gradient(135deg, #8e44ad 0%, #9b59b6 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 6px;
            margin: 0 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .export-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(142, 68, 173, 0.3);
        }

        @media (max-width: 768px) {
            .team-sections {
                grid-template-columns: 1fr;
            }
            
            .styles-grid {
                grid-template-columns: 1fr;
            }
        }

        .methodology-info {
            background: #e8f5e8;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            border-left: 4px solid #27ae60;
        }

        .warning-box {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            color: #856404;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>문화별 디자인 양식 비교 분석 시스템</h1>
        <div class="subtitle">동서양 건축 양식의 정량적 특성 분석 및 비교 연구</div>
        <div class="keywords">
            Keywords: Scandinavian Design, Korean Hanok, Baroque, Rococo, Computer Vision, Quantitative Analysis
        </div>
    </div>

    <div class="container">
        <!-- 연구 단계 설명 -->
        <div class="research-phases">
            <div class="phase-card active">
                <div class="phase-title">
                    <span class="phase-number">1</span>
                    데이터셋 구축
                </div>
                <p>4가지 양식(라곰, 한옥, 바로크, 로코코)의 이미지를 체계적으로 수집하여 비교 분석을 위한 데이터베이스를 구축합니다.</p>
            </div>
            <div class="phase-card">
                <div class="phase-title">
                    <span class="phase-number">2</span>
                    개별 분석
                </div>
                <p>각 양식별로 색상, 공간, 복잡성 등의 시각적 특성을 독립적으로 분석하여 고유한 특징을 추출합니다.</p>
            </div>
            <div class="phase-card">
                <div class="phase-title">
                    <span class="phase-number">3</span>
                    팀 비교 분석
                </div>
                <p>절제적 자연 친화형과 장식적 화려함 과시형으로 그룹화하여 대조적인 미학적 특성을 비교 분석합니다.</p>
            </div>
            <div class="phase-card">
                <div class="phase-title">
                    <span class="phase-number">4</span>
                    종합 보고서
                </div>
                <p>분석 결과를 시각화하고 통계적 검증을 통해 문화간 디자인 특성의 차이를 과학적으로 입증합니다.</p>
            </div>
        </div>

        <!-- 이미지 업로드 섹션 -->
        <div class="team-sections">
            <!-- 팀 1: 절제적 자연 친화형 -->
            <div class="team-container nature">
                <div class="team-header">
                    <span class="team-icon">🌿</span>
                    절제적 자연 친화형
                </div>
                
                <div class="styles-grid">
                    <!-- 라곰(스칸디나비아) -->
                    <div class="style-upload-group">
                        <div class="style-title">
                            <span class="style-icon">🇸🇪</span>
                            라곰(스칸디나비아) 양식
                        </div>
                        <div class="upload-area" id="lagomUpload">
                            <p>📷 스칸디나비아 디자인 이미지</p>
                            <p style="font-size: 0.85rem; color: #7f8c8d; margin-top: 8px;">
                                드래그 앤 드롭 또는 클릭
                            </p>
                            <input type="file" id="lagomInput" multiple accept="image/*" style="display: none;">
                            <button class="upload-btn" onclick="document.getElementById('lagomInput').click()">
                                이미지 선택
                            </button>
                            <button class="upload-btn clear" onclick="clearStyle('lagom')">
                                초기화
                            </button>
                        </div>
                        <div class="image-count">
                            <span>업로드된 이미지:</span>
                            <span class="count-badge" id="lagomCount">0장</span>
                        </div>
                    </div>

                    <!-- 한옥 -->
                    <div class="style-upload-group">
                        <div class="style-title">
                            <span class="style-icon">🏛️</span>
                            한옥 양식
                        </div>
                        <div class="upload-area" id="hanokUpload">
                            <p>📷 한옥 디자인 이미지</p>
                            <p style="font-size: 0.85rem; color: #7f8c8d; margin-top: 8px;">
                                드래그 앤 드롭 또는 클릭
                            </p>
                            <input type="file" id="hanokInput" multiple accept="image/*" style="display: none;">
                            <button class="upload-btn" onclick="document.getElementById('hanokInput').click()">
                                이미지 선택
                            </button>
                            <button class="upload-btn clear" onclick="clearStyle('hanok')">
                                초기화
                            </button>
                        </div>
                        <div class="image-count">
                            <span>업로드된 이미지:</span>
                            <span class="count-badge" id="hanokCount">0장</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 팀 2: 장식적 화려함 과시형 -->
            <div class="team-container ornate">
                <div class="team-header">
                    <span class="team-icon">👑</span>
                    장식적 화려함 과시형
                </div>
                
                <div class="styles-grid">
                    <!-- 바로크 -->
                    <div class="style-upload-group">
                        <div class="style-title">
                            <span class="style-icon">🎭</span>
                            바로크 양식
                        </div>
                        <div class="upload-area" id="baroqueUpload">
                            <p>📷 바로크 디자인 이미지</p>
                            <p style="font-size: 0.85rem; color: #7f8c8d; margin-top: 8px;">
                                드래그 앤 드롭 또는 클릭
                            </p>
                            <input type="file" id="baroqueInput" multiple accept="image/*" style="display: none;">
                            <button class="upload-btn" onclick="document.getElementById('baroqueInput').click()">
                                이미지 선택
                            </button>
                            <button class="upload-btn clear" onclick="clearStyle('baroque')">
                                초기화
                            </button>
                        </div>
                        <div class="image-count">
                            <span>업로드된 이미지:</span>
                            <span class="count-badge" id="baroqueCount">0장</span>
                        </div>
                    </div>

                    <!-- 로코코 -->
                    <div class="style-upload-group">
                        <div class="style-title">
                            <span class="style-icon">🌹</span>
                            로코코 양식
                        </div>
                        <div class="upload-area" id="rococoUpload">
                            <p>📷 로코코 디자인 이미지</p>
                            <p style="font-size: 0.85rem; color: #7f8c8d; margin-top: 8px;">
                                드래그 앤 드롭 또는 클릭
                            </p>
                            <input type="file" id="rococoInput" multiple accept="image/*" style="display: none;">
                            <button class="upload-btn" onclick="document.getElementById('rococoInput').click()">
                                이미지 선택
                            </button>
                            <button class="upload-btn clear" onclick="clearStyle('rococo')">
                                초기화
                            </button>
                        </div>
                        <div class="image-count">
                            <span>업로드된 이미지:</span>
                            <span class="count-badge" id="rococoCount">0장</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 분석 실행 섹션 -->
        <div class="analysis-section">
            <h3>📊 정량적 분석 실행</h3>
            <div class="warning-box">
                <strong>⚠️ 연구 조건:</strong> 각 양식당 최소 3장 이상의 이미지가 필요합니다. 더 많은 이미지일수록 통계적으로 신뢰성 있는 결과를 얻을 수 있습니다.
            </div>
            
            <div class="analysis-controls">
                <button class="analyze-btn" id="analyzeBtn" onclick="startAnalysis()" disabled>
                    🔬 분석 시작
                </button>
                <button class="export-btn" onclick="exportResults()" disabled id="exportBtn">
                    📄 결과 내보내기
                </button>
            </div>

            <div class="progress-container" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">분석 준비 중...</div>
            </div>
        </div>

        <!-- 분석 결과 섹션 -->
        <div class="results-container" id="resultsContainer" style="display: none;">
            <!-- 개별 양식 분석 결과 -->
            <div class="individual-results">
                <h3>📈 개별 양식 분석 결과</h3>
                <div class="results-grid" id="individualResults">
                    <!-- 동적으로 생성됩니다 -->
                </div>
            </div>

            <!-- 팀 비교 분석 결과 -->
            <div class="team-comparison">
                <h3>🔍 팀 비교 분석</h3>
                <div class="results-grid" id="teamComparison">
                    <!-- 동적으로 생성됩니다 -->
                </div>
            </div>

            <!-- 통계적 검증 결과 -->
            <div class="statistical-analysis" id="statisticalAnalysis">
                <h3>📊 통계적 유의성 검증 (t-test)</h3>
                <div class="methodology-info">
                    <strong>검증 방법:</strong> 독립표본 t-검정 (Independent Samples t-test)<br>
                    <strong>유의수준:</strong> α = 0.05 (p-value < 0.05일 때 통계적으로 유의미함)
                </div>
                <table class="significance-table" id="significanceTable">
                    <thead>
                        <tr>
                            <th>분석 지표</th>
                            <th>절제적 자연 친화형</th>
                            <th>장식적 화려함 과시형</th>
                            <th>차이율 (%)</th>
                            <th>p-value</th>
                            <th>통계적 유의성</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- 결과가 동적으로 생성됩니다 -->
                    </tbody>
                </table>
            </div>

            <!-- 시각화 차트 -->
            <div class="chart-container" id="chartContainer">
                <h3>📊 비교 분석 시각화</h3>
                
                <div class="chart-controls">
                    <div class="chart-selector">
                        <label for="chartType">차트 유형:</label>
                        <select id="chartType" onchange="updateChart()">
                            <option value="bar4">4가지 양식 비교</option>
                            <option value="barTeam">팀별 비교</option>
                            <option value="radar">레이더 차트</option>
                            <option value="boxplot">박스플롯</option>
                            <option value="scatter">산점도</option>
                            <option value="histogram">히스토그램</option>
                        </select>
                    </div>
                    
                    <div class="metric-selector" id="metricSelector" style="display: none;">
                        <label for="selectedMetric">분석 지표:</label>
                        <select id="selectedMetric" onchange="updateChart()">
                            <option value="saturation">평균 채도</option>
                            <option value="brightness">평균 명도</option>
                            <option value="colordiversity">색상 다양성</option>
                            <option value="negativespace">여백 비율</option>
                            <option value="edgedensity">엣지 밀도</option>
                            <option value="texturecomplexity">텍스처 복잡성</option>
                            <option value="symmetry">대칭성</option>
                        </select>
                    </div>
                    
                    <button class="upload-btn" onclick="exportChart()">
                        💾 차트 저장
                    </button>
                </div>
                
                <canvas id="comparisonChart" class="chart-canvas" width="1000" height="600"></canvas>
                
                <!-- 차트 설명 -->
                <div class="chart-description" id="chartDescription">
                    차트 유형을 선택하여 데이터를 시각화해보세요.
                </div>
            </div>

            <!-- 연구 보고서 -->
            <div class="research-report" id="researchReport">
                <h2>연구 결과 보고서</h2>
                
                <div class="report-section">
                    <h3>1. 연구 목적 및 방법</h3>
                    <p>본 연구는 동서양의 대표적인 건축 양식을 컴퓨터 비전 기술을 통해 정량화하고, 
                    문화권별 미학적 특성을 객관적으로 비교 분석하는 것을 목적으로 한다. 
                    이미지 분석 알고리즘을 활용하여 색상, 공간, 복잡성 등의 시각적 특징을 수치화하고, 
                    통계적 검증을 통해 그 차이의 유의미성을 검증하였다.</p>
                </div>

                <div class="report-section">
                    <h3>2. 주요 연구 결과</h3>
                    <div id="keyFindings">
                        <!-- 주요 발견사항이 동적으로 생성됩니다 -->
                    </div>
                </div>

                <div class="report-section">
                    <h3>3. 결론 및 의의</h3>
                    <div id="conclusions">
                        <!-- 결론이 동적으로 생성됩니다 -->
                    </div>
                </div>
            </div>

            <!-- 내보내기 컨트롤 -->
            <div class="export-controls">
                <button class="export-btn" onclick="exportPDF()">📑 PDF 보고서 다운로드</button>
                <button class="export-btn" onclick="exportCSV()">📊 원시 데이터 CSV 다운로드</button>
                <button class="export-btn" onclick="exportChart()">📈 차트 이미지 다운로드</button>
            </div>
        </div>
    </div>

    <script>
        class DesignAnalyzer {
            constructor() {
                this.styles = {
                    lagom: [],
                    hanok: [],
                    baroque: [],
                    rococo: []
                };
                
                this.teams = {
                    nature: ['lagom', 'hanok'],
                    ornate: ['baroque', 'rococo']
                };
                
                this.analysisResults = null;
                this.setupEventListeners();
            }

            setupEventListeners() {
                // 각 스타일별 이벤트 리스너 설정
                Object.keys(this.styles).forEach(style => {
                    const input = document.getElementById(`${style}Input`);
                    const upload = document.getElementById(`${style}Upload`);
                    
                    input.addEventListener('change', (e) => {
                        this.handleImageUpload(e.target.files, style);
                    });
                    
                    this.setupDragAndDrop(upload, style);
                });
            }

            setupDragAndDrop(uploadArea, style) {
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });

                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });

                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    this.handleImageUpload(e.dataTransfer.files, style);
                });
            }

            async handleImageUpload(files, style) {
                for (const file of files) {
                    if (file.type.startsWith('image/')) {
                        try {
                            const image = await this.loadImage(file);
                            const analysisData = await this.preprocessImage(image, file.name);
                            this.styles[style].push(analysisData);
                        } catch (error) {
                            console.error('이미지 로드 오류:', error);
                        }
                    }
                }

                this.updateImageCount(style);
                this.checkAnalysisReady();
            }

            loadImage(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.onerror = reject;
                        img.src = e.target.result;
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            async preprocessImage(image, filename) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = 512;
                canvas.height = 512;
                ctx.drawImage(image, 0, 0, 512, 512);
                
                const imageData = ctx.getImageData(0, 0, 512, 512);
                
                return {
                    filename: filename,
                    imageData: imageData,
                    canvas: canvas
                };
            }

            updateImageCount(style) {
                const count = this.styles[style].length;
                const countElement = document.getElementById(`${style}Count`);
                countElement.textContent = `${count}장`;
            }

            checkAnalysisReady() {
                const analyzeBtn = document.getElementById('analyzeBtn');
                const allStylesHaveImages = Object.keys(this.styles).every(
                    style => this.styles[style].length >= 3
                );
                analyzeBtn.disabled = !allStylesHaveImages;
            }

            async startAnalysis() {
                const progressContainer = document.getElementById('progressContainer');
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');

                progressContainer.style.display = 'block';
                
                try {
                    const results = {
                        individual: {},
                        teams: {},
                        statistical: {}
                    };
                    
                    // 1. 개별 양식 분석
                    let progress = 0;
                    const styleKeys = Object.keys(this.styles);
                    
                    for (let i = 0; i < styleKeys.length; i++) {
                        const style = styleKeys[i];
                        progressText.textContent = `${this.getStyleName(style)} 양식 분석 중...`;
                        progress = ((i + 1) / styleKeys.length) * 50;
                        progressFill.style.width = `${progress}%`;
                        
                        results.individual[style] = await this.analyzeImageGroup(this.styles[style]);
                    }
                    
                    // 2. 팀별 통합 분석
                    progressText.textContent = '팀별 비교 분석 중...';
                    progressFill.style.width = '75%';
                    
                    // 절제적 자연 친화형 팀 분석
                    const natureImages = [];
                    this.teams.nature.forEach(style => {
                        natureImages.push(...this.styles[style]);
                    });
                    results.teams.nature = await this.analyzeImageGroup(natureImages);
                    
                    // 장식적 화려함 과시형 팀 분석
                    const ornateImages = [];
                    this.teams.ornate.forEach(style => {
                        ornateImages.push(...this.styles[style]);
                    });
                    results.teams.ornate = await this.analyzeImageGroup(ornateImages);
                    
                    // 3. 통계 분석
                    progressText.textContent = '통계적 검증 수행 중...';
                    progressFill.style.width = '90%';
                    
                    results.statistical = this.performStatisticalAnalysis(results.teams.nature, results.teams.ornate);
                    
                    // 4. 결과 저장 및 표시
                    progressText.textContent = '결과 생성 중...';
                    progressFill.style.width = '100%';
                    
                    this.analysisResults = results;
                    this.displayResults();
                    
                    progressText.textContent = '분석 완료!';
                    setTimeout(() => {
                        progressContainer.style.display = 'none';
                    }, 2000);
                    
                    // 결과 컨테이너 표시
                    document.getElementById('resultsContainer').style.display = 'block';
                    document.getElementById('exportBtn').disabled = false;
                    
                } catch (error) {
                    console.error('분석 오류:', error);
                    progressText.textContent = '분석 중 오류가 발생했습니다.';
                }
            }

            async analyzeImageGroup(images) {
                const results = {
                    images: [],
                    aggregated: {
                        avgSaturation: 0,
                        avgBrightness: 0,
                        avgColorDiversity: 0,
                        avgNegativeSpace: 0,
                        avgEdgeDensity: 0,
                        avgTextureComplexity: 0,
                        avgSymmetry: 0
                    }
                };

                for (const imageData of images) {
                    const analysis = this.analyzeImage(imageData.imageData);
                    results.images.push({
                        filename: imageData.filename,
                        ...analysis
                    });
                }

                const metrics = ['avgSaturation', 'avgBrightness', 'avgColorDiversity', 
                               'avgNegativeSpace', 'avgEdgeDensity', 'avgTextureComplexity', 'avgSymmetry'];
                
                metrics.forEach(metric => {
                    const key = metric.replace('avg', '').toLowerCase();
                    const values = results.images.map(img => img[key] || 0);
                    results.aggregated[metric] = values.reduce((sum, val) => sum + val, 0) / values.length;
                });

                return results;
            }

            analyzeImage(imageData) {
                const pixels = imageData.data;
                const width = imageData.width;
                const height = imageData.height;

                const colorAnalysis = this.analyzeColors(pixels);
                const spaceAnalysis = this.analyzeSpace(pixels, width, height);
                const complexityAnalysis = this.analyzeComplexity(pixels, width, height);

                return {
                    saturation: colorAnalysis.avgSaturation,
                    brightness: colorAnalysis.avgBrightness,
                    colordiversity: colorAnalysis.colorDiversity,
                    negativespace: spaceAnalysis.negativeSpaceRatio,
                    edgedensity: complexityAnalysis.edgeDensity,
                    texturecomplexity: complexityAnalysis.textureComplexity,
                    symmetry: spaceAnalysis.symmetryScore
                };
            }

            analyzeColors(pixels) {
                const colors = [];
                
                for (let i = 0; i < pixels.length; i += 16) {
                    const r = pixels[i];
                    const g = pixels[i + 1];
                    const b = pixels[i + 2];
                    
                    if (r !== undefined && g !== undefined && b !== undefined) {
                        colors.push([r, g, b]);
                    }
                }

                const dominantColors = this.extractDominantColors(colors, 5);
                const hsvColors = dominantColors.map(color => this.rgbToHsv(color));
                
                const avgSaturation = hsvColors.reduce((sum, hsv) => sum + hsv[1], 0) / hsvColors.length;
                const avgBrightness = hsvColors.reduce((sum, hsv) => sum + hsv[2], 0) / hsvColors.length;
                const colorDiversity = this.calculateColorDiversity(dominantColors);

                return {
                    avgSaturation,
                    avgBrightness,
                    colorDiversity
                };
            }

            extractDominantColors(colors, numColors) {
                if (colors.length === 0) return [];
                
                const centroids = [];
                for (let i = 0; i < numColors; i++) {
                    centroids.push(colors[Math.floor(Math.random() * colors.length)]);
                }
                
                for (let iter = 0; iter < 10; iter++) {
                    const clusters = Array(numColors).fill().map(() => []);
                    
                    colors.forEach(color => {
                        let minDist = Infinity;
                        let closestCentroid = 0;
                        
                        centroids.forEach((centroid, idx) => {
                            const dist = this.colorDistance(color, centroid);
                            if (dist < minDist) {
                                minDist = dist;
                                closestCentroid = idx;
                            }
                        });
                        
                        clusters[closestCentroid].push(color);
                    });
                    
                    clusters.forEach((cluster, idx) => {
                        if (cluster.length > 0) {
                            const newCentroid = [
                                cluster.reduce((sum, c) => sum + c[0], 0) / cluster.length,
                                cluster.reduce((sum, c) => sum + c[1], 0) / cluster.length,
                                cluster.reduce((sum, c) => sum + c[2], 0) / cluster.length
                            ];
                            centroids[idx] = newCentroid;
                        }
                    });
                }
                
                return centroids;
            }

            colorDistance(color1, color2) {
                return Math.sqrt(
                    Math.pow(color1[0] - color2[0], 2) +
                    Math.pow(color1[1] - color2[1], 2) +
                    Math.pow(color1[2] - color2[2], 2)
                );
            }

            rgbToHsv([r, g, b]) {
                r /= 255;
                g /= 255;
                b /= 255;
                
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const diff = max - min;
                
                let h = 0;
                let s = max === 0 ? 0 : diff / max;
                let v = max;
                
                if (diff !== 0) {
                    switch (max) {
                        case r: h = ((g - b) / diff) % 6; break;
                        case g: h = (b - r) / diff + 2; break;
                        case b: h = (r - g) / diff + 4; break;
                    }
                    h /= 6;
                }
                
                if (h < 0) h += 1;
                
                return [h, s, v];
            }

            calculateColorDiversity(colors) {
                if (colors.length <= 1) return 0;
                
                let totalDistance = 0;
                let comparisons = 0;
                
                for (let i = 0; i < colors.length; i++) {
                    for (let j = i + 1; j < colors.length; j++) {
                        totalDistance += this.colorDistance(colors[i], colors[j]);
                        comparisons++;
                    }
                }
                
                return comparisons > 0 ? (totalDistance / comparisons) / 441.67 : 0;
            }

            analyzeSpace(pixels, width, height) {
                const grayscale = this.convertToGrayscale(pixels, width, height);
                const edges = this.detectEdges(grayscale, width, height);
                
                const totalPixels = width * height;
                const edgePixels = edges.reduce((sum, pixel) => sum + (pixel > 128 ? 1 : 0), 0);
                const negativeSpaceRatio = Math.max(0, (totalPixels - edgePixels * 3) / totalPixels);
                
                const symmetryScore = this.calculateSymmetry(grayscale, width, height);
                
                return {
                    negativeSpaceRatio,
                    symmetryScore
                };
            }

            convertToGrayscale(pixels, width, height) {
                const grayscale = [];
                for (let i = 0; i < pixels.length; i += 4) {
                    const gray = pixels[i] * 0.299 + pixels[i + 1] * 0.587 + pixels[i + 2] * 0.114;
                    grayscale.push(gray);
                }
                return grayscale;
            }

            detectEdges(grayscale, width, height) {
                const edges = new Array(grayscale.length).fill(0);
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = y * width + x;
                        
                        const gx = (
                            grayscale[idx - width - 1] * -1 + grayscale[idx - width + 1] * 1 +
                            grayscale[idx - 1] * -2 + grayscale[idx + 1] * 2 +
                            grayscale[idx + width - 1] * -1 + grayscale[idx + width + 1] * 1
                        );
                        
                        const gy = (
                            grayscale[idx - width - 1] * -1 + grayscale[idx - width] * -2 + grayscale[idx - width + 1] * -1 +
                            grayscale[idx + width - 1] * 1 + grayscale[idx + width] * 2 + grayscale[idx + width + 1] * 1
                        );
                        
                        edges[idx] = Math.sqrt(gx * gx + gy * gy);
                    }
                }
                
                return edges;
            }

            calculateSymmetry(grayscale, width, height) {
                const halfWidth = Math.floor(width / 2);
                let totalDiff = 0;
                let comparisons = 0;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < halfWidth; x++) {
                        const leftIdx = y * width + x;
                        const rightIdx = y * width + (width - 1 - x);
                        
                        if (leftIdx < grayscale.length && rightIdx < grayscale.length) {
                            totalDiff += Math.abs(grayscale[leftIdx] - grayscale[rightIdx]);
                            comparisons++;
                        }
                    }
                }
                
                return comparisons > 0 ? 1 - (totalDiff / comparisons) / 255 : 0;
            }

            analyzeComplexity(pixels, width, height) {
                const grayscale = this.convertToGrayscale(pixels, width, height);
                const edges = this.detectEdges(grayscale, width, height);
                
                const totalPixels = edges.length;
                const edgePixels = edges.reduce((sum, pixel) => sum + (pixel > 50 ? 1 : 0), 0);
                const edgeDensity = edgePixels / totalPixels;
                
                const mean = grayscale.reduce((sum, val) => sum + val, 0) / grayscale.length;
                const variance = grayscale.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / grayscale.length;
                const textureComplexity = Math.sqrt(variance) / 255;
                
                return {
                    edgeDensity,
                    textureComplexity
                };
            }

            performStatisticalAnalysis(natureResults, ornateResults) {
                const metrics = ['avgSaturation', 'avgBrightness', 'avgColorDiversity', 
                               'avgNegativeSpace', 'avgEdgeDensity', 'avgTextureComplexity', 'avgSymmetry'];
                
                const results = {};
                
                metrics.forEach(metric => {
                    const natureData = natureResults.images.map(img => {
                        const key = metric.replace('avg', '').toLowerCase();
                        return img[key] || 0;
                    });
                    
                    const ornateData = ornateResults.images.map(img => {
                        const key = metric.replace('avg', '').toLowerCase();
                        return img[key] || 0;
                    });
                    
                    const natureMean = natureData.reduce((sum, val) => sum + val, 0) / natureData.length;
                    const ornateMean = ornateData.reduce((sum, val) => sum + val, 0) / ornateData.length;
                    
                    const ttest = this.performTTest(natureData, ornateData);
                    
                    results[metric] = {
                        natureMean: natureMean,
                        ornateMean: ornateMean,
                        difference: ((natureMean - ornateMean) / ornateMean) * 100,
                        tStatistic: ttest.tStat,
                        pValue: ttest.pValue,
                        significant: ttest.pValue < 0.05
                    };
                });
                
                return results;
            }

            performTTest(group1, group2) {
                const n1 = group1.length;
                const n2 = group2.length;
                
                const mean1 = group1.reduce((sum, val) => sum + val, 0) / n1;
                const mean2 = group2.reduce((sum, val) => sum + val, 0) / n2;
                
                const var1 = group1.reduce((sum, val) => sum + Math.pow(val - mean1, 2), 0) / (n1 - 1);
                const var2 = group2.reduce((sum, val) => sum + Math.pow(val - mean2, 2), 0) / (n2 - 1);
                
                const pooledVar = ((n1 - 1) * var1 + (n2 - 1) * var2) / (n1 + n2 - 2);
                const standardError = Math.sqrt(pooledVar * (1/n1 + 1/n2));
                
                const tStat = (mean1 - mean2) / standardError;
                
                const df = n1 + n2 - 2;
                let pValue;
                
                if (Math.abs(tStat) > 2.576) pValue = 0.01;
                else if (Math.abs(tStat) > 1.96) pValue = 0.05;
                else if (Math.abs(tStat) > 1.645) pValue = 0.10;
                else pValue = 0.20;
                
                return { tStat, pValue };
            }

            displayResults() {
                this.displayIndividualResults();
                this.displayTeamComparison();
                this.displayStatisticalSignificance();
                this.generateResearchReport();
                this.updateChart();
            }

            displayIndividualResults() {
                const container = document.getElementById('individualResults');
                container.innerHTML = '';
                
                Object.keys(this.analysisResults.individual).forEach(style => {
                    const results = this.analysisResults.individual[style];
                    const card = document.createElement('div');
                    card.className = `style-result-card ${style}`;
                    
                    card.innerHTML = `
                        <h4>${this.getStyleName(style)}</h4>
                        <div class="stats-grid">
                            <div class="stat-item">
                                <div class="stat-label">평균 채도</div>
                                <div class="stat-value">${results.aggregated.avgSaturation.toFixed(3)}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">평균 명도</div>
                                <div class="stat-value">${results.aggregated.avgBrightness.toFixed(3)}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">색상 다양성</div>
                                <div class="stat-value">${results.aggregated.avgColorDiversity.toFixed(3)}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">여백 비율</div>
                                <div class="stat-value">${results.aggregated.avgNegativeSpace.toFixed(3)}</div>
                            </div>
                        </div>
                    `;
                    
                    container.appendChild(card);
                });
            }

            displayTeamComparison() {
                const container = document.getElementById('teamComparison');
                container.innerHTML = '';
                
                const teamNames = {
                    nature: '절제적 자연 친화형',
                    ornate: '장식적 화려함 과시형'
                };
                
                ['nature', 'ornate'].forEach(team => {
                    const results = this.analysisResults.teams[team];
                    const card = document.createElement('div');
                    card.className = `style-result-card ${team}`;
                    
                    card.innerHTML = `
                        <h4>${teamNames[team]}</h4>
                        <div class="stats-grid">
                            <div class="stat-item">
                                <div class="stat-label">평균 채도</div>
                                <div class="stat-value">${results.aggregated.avgSaturation.toFixed(3)}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">평균 명도</div>
                                <div class="stat-value">${results.aggregated.avgBrightness.toFixed(3)}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">색상 다양성</div>
                                <div class="stat-value">${results.aggregated.avgColorDiversity.toFixed(3)}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">여백 비율</div>
                                <div class="stat-value">${results.aggregated.avgNegativeSpace.toFixed(3)}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">엣지 밀도</div>
                                <div class="stat-value">${results.aggregated.avgEdgeDensity.toFixed(3)}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">텍스처 복잡성</div>
                                <div class="stat-value">${results.aggregated.avgTextureComplexity.toFixed(3)}</div>
                            </div>
                        </div>
                    `;
                    
                    container.appendChild(card);
                });
            }

            displayStatisticalSignificance() {
                const tableBody = document.querySelector('#significanceTable tbody');
                tableBody.innerHTML = '';
                
                const metricNames = {
                    'avgSaturation': '평균 채도',
                    'avgBrightness': '평균 명도',
                    'avgColorDiversity': '색상 다양성',
                    'avgNegativeSpace': '여백 비율',
                    'avgEdgeDensity': '엣지 밀도',
                    'avgTextureComplexity': '텍스처 복잡성',
                    'avgSymmetry': '대칭성'
                };
                
                Object.keys(this.analysisResults.statistical).forEach(metric => {
                    const result = this.analysisResults.statistical[metric];
                    const significanceClass = result.significant ? 'significant' : 'not-significant';
                    const significanceText = result.significant ? '유의미 ✓' : '유의미하지 않음 ✗';
                    
                    tableBody.innerHTML += `
                        <tr>
                            <td>${metricNames[metric]}</td>
                            <td>${result.natureMean.toFixed(3)}</td>
                            <td>${result.ornateMean.toFixed(3)}</td>
                            <td>${result.difference.toFixed(1)}%</td>
                            <td>${result.pValue.toFixed(3)}</td>
                            <td class="${significanceClass}">${significanceText}</td>
                        </tr>
                    `;
                });
            }

            generateResearchReport() {
                const keyFindings = document.getElementById('keyFindings');
                const conclusions = document.getElementById('conclusions');
                
                const significantFindings = [];
                Object.keys(this.analysisResults.statistical).forEach(metric => {
                    const result = this.analysisResults.statistical[metric];
                    if (result.significant) {
                        const direction = result.difference > 0 ? '높게' : '낮게';
                        const metricName = this.getMetricName(metric);
                        significantFindings.push(`• ${metricName}: 절제적 자연 친화형이 ${Math.abs(result.difference).toFixed(1)}% ${direction} 나타남 (p=${result.pValue.toFixed(3)})`);
                    }
                });
                
                if (significantFindings.length > 0) {
                    keyFindings.innerHTML = `
                        <p><strong>통계적으로 유의미한 차이가 발견된 지표:</strong></p>
                        <ul style="margin-left: 20px; margin-top: 10px;">
                            ${significantFindings.join('<br>')}
                        </ul>
                    `;
                } else {
                    keyFindings.innerHTML = `
                        <p>분석 결과, 두 그룹 간에 통계적으로 유의미한 차이를 발견하지 못했습니다.</p>
                    `;
                }
                
                conclusions.innerHTML = `
                    <p>본 연구를 통해 동서양 건축 양식의 시각적 특성을 정량적으로 분석하고 비교할 수 있었습니다. 
                    컴퓨터 비전 기술을 활용한 이러한 접근은 문화적 미학을 객관적으로 이해하는 새로운 방법론을 제시합니다.</p>
                `;
            }

            updateChart() {
                const chartType = document.getElementById('chartType').value;
                const canvas = document.getElementById('comparisonChart');
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const metricSelector = document.getElementById('metricSelector');
                
                switch(chartType) {
                    case 'bar4':
                        metricSelector.style.display = 'none';
                        this.draw4StylesBarChart(ctx, canvas);
                        break;
                    case 'barTeam':
                        metricSelector.style.display = 'none';
                        this.drawTeamBarChart(ctx, canvas);
                        break;
                    case 'radar':
                        metricSelector.style.display = 'none';
                        this.drawRadarChart(ctx, canvas);
                        break;
                    case 'boxplot':
                        metricSelector.style.display = 'flex';
                        this.drawBoxplot(ctx, canvas);
                        break;
                    case 'scatter':
                        metricSelector.style.display = 'flex';
                        this.drawScatter(ctx, canvas);
                        break;
                    case 'histogram':
                        metricSelector.style.display = 'flex';
                        this.drawHistogram(ctx, canvas);
                        break;
                    default:
                        this.draw4StylesBarChart(ctx, canvas);
                }
                
                this.updateChartDescription(chartType);
            }

            draw4StylesBarChart(ctx, canvas) {
                const styles = ['lagom', 'hanok', 'baroque', 'rococo'];
                const colors = {
                    lagom: '#27ae60',
                    hanok: '#2ecc71',
                    baroque: '#e74c3c',
                    rococo: '#c0392b'
                };
                
                const metrics = ['채도', '명도', '색상다양성', '여백비율', '엣지밀도', '텍스처복잡성', '대칭성'];
                const metricKeys = ['avgSaturation', 'avgBrightness', 'avgColorDiversity', 
                                   'avgNegativeSpace', 'avgEdgeDensity', 'avgTextureComplexity', 'avgSymmetry'];
                
                const padding = 80;
                const chartWidth = canvas.width - 2 * padding;
                const chartHeight = canvas.height - 2 * padding;
                const groupWidth = chartWidth / metrics.length;
                const barWidth = groupWidth / (styles.length + 1);
                
                // 배경
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 축 그리기
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, padding + chartHeight);
                ctx.lineTo(padding + chartWidth, padding + chartHeight);
                ctx.stroke();
                
                // 데이터 그리기
                let maxValue = 0;
                styles.forEach(style => {
                    metricKeys.forEach(key => {
                        const value = this.analysisResults.individual[style].aggregated[key];
                        maxValue = Math.max(maxValue, value);
                    });
                });
                
                metrics.forEach((metric, metricIndex) => {
                    const x = padding + metricIndex * groupWidth;
                    
                    styles.forEach((style, styleIndex) => {
                        const value = this.analysisResults.individual[style].aggregated[metricKeys[metricIndex]];
                        const height = (value / maxValue) * chartHeight;
                        const barX = x + styleIndex * barWidth + barWidth/2;
                        
                        ctx.fillStyle = colors[style];
                        ctx.fillRect(barX, padding + chartHeight - height, barWidth * 0.8, height);
                    });
                    
                    // X축 라벨
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '11px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(metric, x + groupWidth/2, padding + chartHeight + 20);
                });
                
                // 제목
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('4가지 양식별 지표 비교', canvas.width / 2, 30);
                
                // 범례
                const legendY = 50;
                let legendX = canvas.width - 350;
                
                styles.forEach((style, index) => {
                    ctx.fillStyle = colors[style];
                    ctx.fillRect(legendX + index * 80, legendY, 15, 15);
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(this.getStyleName(style), legendX + index * 80 + 20, legendY + 12);
                });
            }

            drawTeamBarChart(ctx, canvas) {
                const metrics = ['채도', '명도', '색상다양성', '여백비율', '엣지밀도', '텍스처복잡성', '대칭성'];
                const metricKeys = ['avgSaturation', 'avgBrightness', 'avgColorDiversity', 
                                   'avgNegativeSpace', 'avgEdgeDensity', 'avgTextureComplexity', 'avgSymmetry'];
                
                const padding = 80;
                const chartWidth = canvas.width - 2 * padding;
                const chartHeight = canvas.height - 2 * padding;
                const barWidth = chartWidth / (metrics.length * 2.5);
                
                // 배경
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 축 그리기
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, padding + chartHeight);
                ctx.lineTo(padding + chartWidth, padding + chartHeight);
                ctx.stroke();
                
                // 데이터 최대값 찾기
                let maxValue = 0;
                metricKeys.forEach(key => {
                    maxValue = Math.max(maxValue, 
                        this.analysisResults.teams.nature.aggregated[key],
                        this.analysisResults.teams.ornate.aggregated[key]
                    );
                });
                
                // 막대 그리기
                metrics.forEach((metric, index) => {
                    const x = padding + index * barWidth * 2.5;
                    
                    // 절제적 자연 친화형
                    const natureValue = this.analysisResults.teams.nature.aggregated[metricKeys[index]];
                    const natureHeight = (natureValue / maxValue) * chartHeight;
                    ctx.fillStyle = '#27ae60';
                    ctx.fillRect(x, padding + chartHeight - natureHeight, barWidth, natureHeight);
                    
                    // 장식적 화려함 과시형
                    const ornateValue = this.analysisResults.teams.ornate.aggregated[metricKeys[index]];
                    const ornateHeight = (ornateValue / maxValue) * chartHeight;
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillRect(x + barWidth + 5, padding + chartHeight - ornateHeight, barWidth, ornateHeight);
                    
                    // X축 라벨
                    ctx.save();
                    ctx.translate(x + barWidth, padding + chartHeight + 15);
                    ctx.rotate(-Math.PI / 6);
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '11px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(metric, 0, 0);
                    ctx.restore();
                });
                
                // Y축 눈금
                for (let i = 0; i <= 5; i++) {
                    const y = padding + chartHeight - (chartHeight * i / 5);
                    const value = (maxValue * i / 5).toFixed(2);
                    
                    ctx.strokeStyle = '#ecf0f1';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(padding + chartWidth, y);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText(value, padding - 10, y + 3);
                }
                
                // 제목
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('팀별 비교: 절제적 자연 친화형 vs 장식적 화려함 과시형', canvas.width / 2, 30);
                
                // 범례
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(canvas.width - 250, 50, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('절제적 자연 친화형', canvas.width - 225, 62);
                
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(canvas.width - 250, 70, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.fillText('장식적 화려함 과시형', canvas.width - 225, 82);
            }

            drawRadarChart(ctx, canvas) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(canvas.width, canvas.height) / 3;
                
                const metrics = ['채도', '명도', '색상다양성', '여백비율', '엣지밀도', '텍스처복잡성', '대칭성'];
                const metricKeys = ['avgSaturation', 'avgBrightness', 'avgColorDiversity', 
                                   'avgNegativeSpace', 'avgEdgeDensity', 'avgTextureComplexity', 'avgSymmetry'];
                const numMetrics = metrics.length;
                
                // 배경
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 격자 그리기
                ctx.strokeStyle = '#ecf0f1';
                ctx.lineWidth = 1;
                
                for (let level = 0.2; level <= 1; level += 0.2) {
                    ctx.beginPath();
                    for (let i = 0; i <= numMetrics; i++) {
                        const angle = (i * 2 * Math.PI) / numMetrics - Math.PI / 2;
                        const x = centerX + Math.cos(angle) * radius * level;
                        const y = centerY + Math.sin(angle) * radius * level;
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                // 축 그리기
                ctx.strokeStyle = '#bdc3c7';
                for (let i = 0; i < numMetrics; i++) {
                    const angle = (i * 2 * Math.PI) / numMetrics - Math.PI / 2;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                    
                    // 라벨
                    const labelX = centerX + Math.cos(angle) * (radius + 25);
                    const labelY = centerY + Math.sin(angle) * (radius + 25);
                    
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '11px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(metrics[i], labelX, labelY);
                }
                
                // 데이터 정규화
                let maxValues = {};
                metricKeys.forEach(key => {
                    maxValues[key] = Math.max(
                        this.analysisResults.teams.nature.aggregated[key],
                        this.analysisResults.teams.ornate.aggregated[key]
                    );
                });
                
                // 절제적 자연 친화형 데이터
                ctx.strokeStyle = '#27ae60';
                ctx.fillStyle = '#27ae6040';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i <= numMetrics; i++) {
                    const dataIndex = i % numMetrics;
                    const angle = (i * 2 * Math.PI) / numMetrics - Math.PI / 2;
                    const value = this.analysisResults.teams.nature.aggregated[metricKeys[dataIndex]] / maxValues[metricKeys[dataIndex]];
                    const x = centerX + Math.cos(angle) * radius * value;
                    const y = centerY + Math.sin(angle) * radius * value;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                ctx.fill();
                
                // 장식적 화려함 과시형 데이터
                ctx.strokeStyle = '#e74c3c';
                ctx.fillStyle = '#e74c3c40';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i <= numMetrics; i++) {
                    const dataIndex = i % numMetrics;
                    const angle = (i * 2 * Math.PI) / numMetrics - Math.PI / 2;
                    const value = this.analysisResults.teams.ornate.aggregated[metricKeys[dataIndex]] / maxValues[metricKeys[dataIndex]];
                    const x = centerX + Math.cos(angle) * radius * value;
                    const y = centerY + Math.sin(angle) * radius * value;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                ctx.fill();
                
                // 제목
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('레이더 차트: 종합 지표 비교', canvas.width / 2, 30);
                
                // 범례
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(50, 50, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('절제적 자연 친화형', 75, 62);
                
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(50, 70, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.fillText('장식적 화려함 과시형', 75, 82);
            }

            drawBoxplot(ctx, canvas) {
                const selectedMetric = document.getElementById('selectedMetric')?.value || 'saturation';
                const metricKey = selectedMetric.replace('avg', '').toLowerCase();
                
                // 각 스타일별 데이터 추출
                const data = {};
                Object.keys(this.styles).forEach(style => {
                    data[style] = this.analysisResults.individual[style].images.map(img => img[metricKey] || 0).filter(val => val > 0);
                });
                
                if (Object.values(data).some(arr => arr.length === 0)) {
                    ctx.fillStyle = '#e74c3c';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('데이터가 부족합니다', canvas.width / 2, canvas.height / 2);
                    return;
                }
                
                // 박스플롯 통계 계산
                const stats = {};
                Object.keys(data).forEach(style => {
                    stats[style] = this.calculateBoxStats(data[style]);
                });
                
                const allValues = Object.values(data).flat();
                const minVal = Math.min(...allValues);
                const maxVal = Math.max(...allValues);
                const range = maxVal - minVal;
                
                const padding = 80;
                const chartHeight = canvas.height - 2 * padding;
                const styles = ['lagom', 'hanok', 'baroque', 'rococo'];
                const colors = {
                    lagom: '#27ae60',
                    hanok: '#2ecc71',
                    baroque: '#e74c3c',
                    rococo: '#c0392b'
                };
                
                // 배경
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Y축 그리기
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, padding + chartHeight);
                ctx.stroke();
                
                // Y축 눈금과 격자
                for (let i = 0; i <= 5; i++) {
                    const y = padding + chartHeight - (chartHeight * i / 5);
                    const value = minVal + (range * i / 5);
                    
                    // 격자선
                    ctx.strokeStyle = '#ecf0f1';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(canvas.width - padding, y);
                    ctx.stroke();
                    
                    // 라벨
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText(value.toFixed(3), padding - 10, y + 3);
                }
                
                // 각 스타일별 박스플롯 그리기
                const boxWidth = 60;
                const spacing = (canvas.width - 2 * padding) / (styles.length + 1);
                
                styles.forEach((style, index) => {
                    const centerX = padding + (index + 1) * spacing;
                    this.drawSingleBoxPlot(ctx, stats[style], centerX, padding, chartHeight, minVal, range, colors[style], this.getStyleName(style));
                });
                
                // 제목
                const metricNames = {
                    'saturation': '평균 채도',
                    'brightness': '평균 명도',
                    'colordiversity': '색상 다양성',
                    'negativespace': '여백 비율',
                    'edgedensity': '엣지 밀도',
                    'texturecomplexity': '텍스처 복잡성',
                    'symmetry': '대칭성'
                };
                
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${metricNames[metricKey]} 박스플롯 비교`, canvas.width / 2, 30);
            }

            drawScatter(ctx, canvas) {
                const selectedMetric = document.getElementById('selectedMetric')?.value || 'saturation';
                const metricKey = selectedMetric.replace('avg', '').toLowerCase();
                const correlationMetric = 'negativespace'; // 여백 비율과 비교
                
                // 팀별 데이터 추출
                const natureDataX = this.analysisResults.teams.nature.images.map(img => img[metricKey] || 0);
                const natureDataY = this.analysisResults.teams.nature.images.map(img => img[correlationMetric] || 0);
                const ornateDataX = this.analysisResults.teams.ornate.images.map(img => img[metricKey] || 0);
                const ornateDataY = this.analysisResults.teams.ornate.images.map(img => img[correlationMetric] || 0);
                
                const allX = [...natureDataX, ...ornateDataX].filter(v => v > 0);
                const allY = [...natureDataY, ...ornateDataY].filter(v => v > 0);
                
                if (allX.length === 0 || allY.length === 0) {
                    ctx.fillStyle = '#e74c3c';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('데이터가 부족합니다', canvas.width / 2, canvas.height / 2);
                    return;
                }
                
                const minX = Math.min(...allX);
                const maxX = Math.max(...allX);
                const minY = Math.min(...allY);
                const maxY = Math.max(...allY);
                
                const padding = 80;
                const chartWidth = canvas.width - 2 * padding;
                const chartHeight = canvas.height - 2 * padding;
                
                // 배경
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 축과 격자 그리기
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, padding + chartHeight);
                ctx.lineTo(padding + chartWidth, padding + chartHeight);
                ctx.stroke();
                
                // 격자
                ctx.strokeStyle = '#ecf0f1';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 5; i++) {
                    // 세로 격자
                    const x = padding + (chartWidth * i / 5);
                    ctx.beginPath();
                    ctx.moveTo(x, padding);
                    ctx.lineTo(x, padding + chartHeight);
                    ctx.stroke();
                    
                    // 가로 격자
                    const y = padding + (chartHeight * i / 5);
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(padding + chartWidth, y);
                    ctx.stroke();
                }
                
                // 점들 그리기
                for (let i = 0; i < natureDataX.length; i++) {
                    if (natureDataX[i] > 0 && natureDataY[i] > 0) {
                        const x = padding + ((natureDataX[i] - minX) / (maxX - minX)) * chartWidth;
                        const y = padding + chartHeight - ((natureDataY[i] - minY) / (maxY - minY)) * chartHeight;
                        
                        ctx.fillStyle = '#27ae60';
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }
                
                for (let i = 0; i < ornateDataX.length; i++) {
                    if (ornateDataX[i] > 0 && ornateDataY[i] > 0) {
                        const x = padding + ((ornateDataX[i] - minX) / (maxX - minX)) * chartWidth;
                        const y = padding + chartHeight - ((ornateDataY[i] - minY) / (maxY - minY)) * chartHeight;
                        
                        ctx.fillStyle = '#e74c3c';
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }
                
                // 축 라벨
                const metricNames = {
                    'saturation': '평균 채도',
                    'brightness': '평균 명도',
                    'colordiversity': '색상 다양성',
                    'negativespace': '여백 비율',
                    'edgedensity': '엣지 밀도',
                    'texturecomplexity': '텍스처 복잡성',
                    'symmetry': '대칭성'
                };
                
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(metricNames[metricKey], canvas.width/2, canvas.height - 20);
                
                ctx.save();
                ctx.translate(15, canvas.height/2);
                ctx.rotate(-Math.PI/2);
                ctx.fillText(metricNames[correlationMetric], 0, 0);
                ctx.restore();
                
                // 제목
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${metricNames[metricKey]} vs ${metricNames[correlationMetric]}`, canvas.width / 2, 30);
                
                // 범례
                const legendY = canvas.height - 60;
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(canvas.width - 250, legendY, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('절제적 자연 친화형', canvas.width - 225, legendY + 12);
                
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(canvas.width - 250, legendY + 20, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.fillText('장식적 화려함 과시형', canvas.width - 225, legendY + 32);
            }

            drawHistogram(ctx, canvas) {
                const selectedMetric = document.getElementById('selectedMetric')?.value || 'saturation';
                const metricKey = selectedMetric.replace('avg', '').toLowerCase();
                
                const natureValues = this.analysisResults.teams.nature.images.map(img => img[metricKey] || 0).filter(val => val > 0);
                const ornateValues = this.analysisResults.teams.ornate.images.map(img => img[metricKey] || 0).filter(val => val > 0);
                
                if (natureValues.length === 0 || ornateValues.length === 0) {
                    ctx.fillStyle = '#e74c3c';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('데이터가 부족합니다', canvas.width / 2, canvas.height / 2);
                    return;
                }
                
                const allValues = [...natureValues, ...ornateValues];
                const minVal = Math.min(...allValues);
                const maxVal = Math.max(...allValues);
                const range = maxVal - minVal;
                const bins = 8;
                const binWidth = range / bins;
                
                // 히스토그램 계산
                const natureHist = new Array(bins).fill(0);
                const ornateHist = new Array(bins).fill(0);
                
                natureValues.forEach(value => {
                    const binIndex = Math.min(Math.floor((value - minVal) / binWidth), bins - 1);
                    natureHist[binIndex]++;
                });
                
                ornateValues.forEach(value => {
                    const binIndex = Math.min(Math.floor((value - minVal) / binWidth), bins - 1);
                    ornateHist[binIndex]++;
                });
                
                const maxCount = Math.max(...natureHist, ...ornateHist, 1);
                const padding = 80;
                const chartWidth = canvas.width - 2 * padding;
                const chartHeight = canvas.height - 2 * padding;
                const barWidth = chartWidth / bins;
                
                // 배경
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 축 그리기
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, padding + chartHeight);
                ctx.lineTo(padding + chartWidth, padding + chartHeight);
                ctx.stroke();
                
                // 히스토그램 그리기
                for (let i = 0; i < bins; i++) {
                    const x = padding + i * barWidth;
                    
                    // 절제적 자연 친화형
                    const natureHeight = (natureHist[i] / maxCount) * chartHeight;
                    ctx.fillStyle = '#27ae6080';
                    ctx.fillRect(x + 2, padding + chartHeight - natureHeight, barWidth * 0.4, natureHeight);
                    
                    // 장식적 화려함 과시형
                    const ornateHeight = (ornateHist[i] / maxCount) * chartHeight;
                    ctx.fillStyle = '#e74c3c80';
                    ctx.fillRect(x + barWidth * 0.5, padding + chartHeight - ornateHeight, barWidth * 0.4, ornateHeight);
                    
                    // X축 라벨 (일부만)
                    if (i % 2 === 0) {
                        const binValue = minVal + i * binWidth;
                        ctx.fillStyle = '#2c3e50';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(binValue.toFixed(2), x + barWidth/2, padding + chartHeight + 20);
                    }
                }
                
                // Y축 눈금
                for (let i = 0; i <= 5; i++) {
                    const y = padding + chartHeight - (chartHeight * i / 5);
                    const count = Math.round(maxCount * i / 5);
                    
                    ctx.strokeStyle = '#ecf0f1';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(padding + chartWidth, y);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText(count.toString(), padding - 10, y + 3);
                }
                
                // 제목
                const metricNames = {
                    'saturation': '평균 채도',
                    'brightness': '평균 명도',
                    'colordiversity': '색상 다양성',
                    'negativespace': '여백 비율',
                    'edgedensity': '엣지 밀도',
                    'texturecomplexity': '텍스처 복잡성',
                    'symmetry': '대칭성'
                };
                
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${metricNames[metricKey]} 분포 비교`, canvas.width / 2, 30);
                
                // 범례
                const legendY = canvas.height - 60;
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(canvas.width - 250, legendY, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('절제적 자연 친화형', canvas.width - 225, legendY + 12);
                
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(canvas.width - 250, legendY + 20, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.fillText('장식적 화려함 과시형', canvas.width - 225, legendY + 32);
            }

            calculateBoxStats(values) {
                const sorted = [...values].sort((a, b) => a - b);
                const n = sorted.length;
                
                if (n === 0) return null;
                
                const q1Index = Math.floor(n * 0.25);
                const medianIndex = Math.floor(n * 0.5);
                const q3Index = Math.floor(n * 0.75);
                
                const q1 = sorted[q1Index];
                const median = sorted[medianIndex];
                const q3 = sorted[q3Index];
                const iqr = q3 - q1;
                
                return {
                    min: sorted[0],
                    q1,
                    median,
                    q3,
                    max: sorted[n - 1],
                    lowerWhisker: Math.max(sorted[0], q1 - 1.5 * iqr),
                    upperWhisker: Math.min(sorted[n - 1], q3 + 1.5 * iqr),
                    outliers: sorted.filter(v => v < q1 - 1.5 * iqr || v > q3 + 1.5 * iqr)
                };
            }

            drawSingleBoxPlot(ctx, stats, centerX, startY, chartHeight, minVal, range, color, label) {
                if (!stats) return;
                
                const boxWidth = 50;
                const valueToY = (value) => startY + chartHeight - ((value - minVal) / range) * chartHeight;
                
                // 수염 그리기
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                
                // 위쪽 수염
                ctx.beginPath();
                ctx.moveTo(centerX, valueToY(stats.upperWhisker));
                ctx.lineTo(centerX, valueToY(stats.q3));
                ctx.stroke();
                
                // 아래쪽 수염
                ctx.beginPath();
                ctx.moveTo(centerX, valueToY(stats.q1));
                ctx.lineTo(centerX, valueToY(stats.lowerWhisker));
                ctx.stroke();
                
                // 수염 끝 표시
                ctx.beginPath();
                ctx.moveTo(centerX - 15, valueToY(stats.upperWhisker));
                ctx.lineTo(centerX + 15, valueToY(stats.upperWhisker));
                ctx.moveTo(centerX - 15, valueToY(stats.lowerWhisker));
                ctx.lineTo(centerX + 15, valueToY(stats.lowerWhisker));
                ctx.stroke();
                
                // 박스 그리기
                const boxY = valueToY(stats.q3);
                const boxHeight = valueToY(stats.q1) - valueToY(stats.q3);
                
                ctx.fillStyle = color + '40';
                ctx.fillRect(centerX - boxWidth/2, boxY, boxWidth, boxHeight);
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.strokeRect(centerX - boxWidth/2, boxY, boxWidth, boxHeight);
                
                // 중앙값 선
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX - boxWidth/2, valueToY(stats.median));
                ctx.lineTo(centerX + boxWidth/2, valueToY(stats.median));
                ctx.stroke();
                
                // 이상치 표시
                ctx.fillStyle = color;
                stats.outliers.forEach(outlier => {
                    ctx.beginPath();
                    ctx.arc(centerX, valueToY(outlier), 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                // 라벨
                ctx.fillStyle = '#2c3e50';
                ctx.font = '11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(label, centerX, startY + chartHeight + 30);
            }

            updateChartDescription(chartType) {
                const descriptions = {
                    'bar4': '막대 그래프는 4가지 양식의 각 지표별 평균값을 비교합니다.',
                    'barTeam': '팀별 비교 막대 그래프는 절제적 자연 친화형과 장식적 화려함 과시형의 차이를 보여줍니다.',
                    'radar': '레이더 차트는 모든 지표를 종합적으로 비교합니다. 중심에서 멀수록 높은 값을 나타냅니다.',
                    'boxplot': '박스플롯은 데이터의 분포와 이상치를 보여줍니다. 상자는 1사분위수에서 3사분위수까지의 범위를 나타냅니다.',
                    'scatter': '산점도는 두 지표 간의 상관관계를 분석합니다. 각 점은 하나의 이미지를 나타냅니다.',
                    'histogram': '히스토그램은 선택한 지표의 값 분포를 비교합니다. 두 그룹의 분포 패턴 차이를 확인할 수 있습니다.'
                };
                
                const descElement = document.getElementById('chartDescription');
                if (descElement) {
                    descElement.textContent = descriptions[chartType] || '차트 설명을 불러올 수 없습니다.';
                }
            }

            getStyleName(style) {
                const names = {
                    lagom: '라곰',
                    hanok: '한옥',
                    baroque: '바로크',
                    rococo: '로코코'
                };
                return names[style] || style;
            }

            getMetricName(metric) {
                const names = {
                    'avgSaturation': '평균 채도',
                    'avgBrightness': '평균 명도',
                    'avgColorDiversity': '색상 다양성',
                    'avgNegativeSpace': '여백 비율',
                    'avgEdgeDensity': '엣지 밀도',
                    'avgTextureComplexity': '텍스처 복잡성',
                    'avgSymmetry': '대칭성'
                };
                return names[metric] || metric;
            }
        }

        // 전역 함수들
        let analyzer;

        function clearStyle(style) {
            analyzer.styles[style] = [];
            document.getElementById(`${style}Input`).value = '';
            analyzer.updateImageCount(style);
            analyzer.checkAnalysisReady();
        }

        function startAnalysis() {
            analyzer.startAnalysis();
        }

        function exportResults() {
            const data = analyzer.analysisResults;
            if (!data) return;
            
            let csv = 'Style,Team,Filename,Saturation,Brightness,ColorDiversity,NegativeSpace,EdgeDensity,TextureComplexity,Symmetry\n';
            
            Object.keys(data.individual).forEach(style => {
                const team = analyzer.teams.nature.includes(style) ? 'Nature' : 'Ornate';
                data.individual[style].images.forEach(img => {
                    csv += `${style},${team},${img.filename},${img.saturation},${img.brightness},${img.colordiversity},${img.negativespace},${img.edgedensity},${img.texturecomplexity},${img.symmetry}\n`;
                });
            });
            
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'design_analysis_results.csv';
            link.click();
        }

        function exportPDF() {
            alert('PDF 내보내기 기능은 실제 구현에서는 jsPDF 라이브러리를 사용하여 구현할 수 있습니다.');
        }

        function exportCSV() {
            exportResults();
        }

        function exportChart() {
            const canvas = document.getElementById('comparisonChart');
            const link = document.createElement('a');
            link.download = 'comparison_chart.png';
            link.href = canvas.toDataURL();
            link.click();
        }

        function updateChart() {
            if (analyzer && analyzer.analysisResults) {
                analyzer.updateChart();
            }
        }

        // 앱 초기화
        document.addEventListener('DOMContentLoaded', () => {
            analyzer = new DesignAnalyzer();
        });
    </script>
</body>
</html>
