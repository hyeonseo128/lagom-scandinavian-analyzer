<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„ ë””ìì¸ ì •ëŸ‰í™” ì—°êµ¬ ë¶„ì„ê¸°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f8f9fa;
            line-height: 1.6;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px 0;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
            font-weight: 400;
        }

        .header .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            margin-bottom: 20px;
        }

        .keywords {
            font-size: 0.9rem;
            opacity: 0.8;
            font-style: italic;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .research-phases {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .phase-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            border-left: 4px solid #3498db;
            transition: transform 0.2s ease;
        }

        .phase-card:hover {
            transform: translateY(-2px);
        }

        .phase-card.active {
            border-left-color: #e74c3c;
            background: linear-gradient(135deg, #fff 0%, #f8f9ff 100%);
        }

        .phase-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }

        .phase-number {
            background: #3498db;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
            font-weight: bold;
        }

        .upload-sections {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .upload-group {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }

        .upload-group.experimental {
            border-top: 4px solid #27ae60;
        }

        .upload-group.control {
            border-top: 4px solid #e67e22;
        }

        .group-title {
            font-size: 1.4rem;
            font-weight: 600;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }

        .group-icon {
            margin-right: 10px;
            font-size: 1.5rem;
        }

        .upload-area {
            border: 2px dashed #bdc3c7;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #fafbfc;
        }

        .upload-area:hover {
            border-color: #3498db;
            background: #f8f9ff;
        }

        .upload-area.dragover {
            border-color: #2ecc71;
            background: #f0fff4;
            transform: scale(1.02);
        }

        .upload-btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            margin: 10px 5px;
            transition: all 0.3s ease;
        }

        .upload-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }

        .upload-btn.clear {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .upload-btn.clear:hover {
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
        }

        .image-count {
            margin-top: 15px;
            font-weight: 600;
            color: #2c3e50;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .count-badge {
            background: #ecf0f1;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.9rem;
        }

        .analysis-section {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }

        .analysis-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .analyze-btn {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .analyze-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(39, 174, 96, 0.3);
        }

        .analyze-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .progress-container {
            background: #ecf0f1;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: #d5dbdb;
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            transition: width 0.3s ease;
            border-radius: 6px;
        }

        .progress-text {
            text-align: center;
            font-weight: 600;
            color: #2c3e50;
        }

        .results-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 30px;
        }

        .results-card {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 25px;
            border-left: 4px solid #3498db;
        }

        .results-card.experimental {
            border-left-color: #27ae60;
        }

        .results-card.control {
            border-left-color: #e67e22;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .stat-label {
            font-size: 0.9rem;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #2c3e50;
        }

        .statistical-analysis {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }

        .significance-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .significance-table th,
        .significance-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ecf0f1;
        }

        .significance-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #2c3e50;
        }

        .significant {
            color: #27ae60;
            font-weight: bold;
        }

        .not-significant {
            color: #e74c3c;
        }

        .chart-container {
            margin: 20px 0;
            text-align: center;
        }

        .chart-controls {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .chart-selector, .metric-selector {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .chart-selector label, .metric-selector label {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9rem;
        }

        .chart-selector select, .metric-selector select {
            padding: 8px 15px;
            border: 2px solid #bdc3c7;
            border-radius: 6px;
            background: white;
            font-size: 0.9rem;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }

        .chart-selector select:focus, .metric-selector select:focus {
            outline: none;
            border-color: #3498db;
        }

        .chart-canvas {
            max-width: 100%;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            background: white;
            margin: 20px 0;
        }

        .chart-description {
            background: #f8f9ff;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            color: #2c3e50;
            font-size: 0.9rem;
            line-height: 1.5;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .research-report {
            background: white;
            border-radius: 12px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            line-height: 1.8;
        }

        .report-section {
            margin-bottom: 30px;
        }

        .report-section h3 {
            color: #2c3e50;
            font-size: 1.4rem;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #ecf0f1;
        }

        .export-controls {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            margin-top: 20px;
        }

        .export-btn {
            background: linear-gradient(135deg, #8e44ad 0%, #9b59b6 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 6px;
            margin: 0 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .export-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(142, 68, 173, 0.3);
        }

        @media (max-width: 768px) {
            .upload-sections,
            .results-grid {
                grid-template-columns: 1fr;
            }
            
            .analysis-controls {
                flex-direction: column;
            }
        }

        .methodology-info {
            background: #e8f5e8;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            border-left: 4px solid #27ae60;
        }

        .warning-box {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            color: #856404;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„ ë””ìì¸ì˜ ì‹œê°ì  íŠ¹ì§• ì •ëŸ‰í™” ì—°êµ¬</h1>
        <div class="subtitle">'ë¼ê³°(Lagom)'ì˜ ë¯¸í•™ì„ ì¤‘ì‹¬ìœ¼ë¡œ í•œ í”„ë¡œê·¸ë˜ë° ê¸°ë°˜ ìœµí•© íƒêµ¬</div>
        <div class="keywords">
            Keywords: Scandinavian Design, Lagom, Computer Vision, Image Analysis, Data Science, Quantification
        </div>
    </div>

    <div class="container">
        <!-- ì—°êµ¬ ë‹¨ê³„ ì„¤ëª… -->
        <div class="research-phases">
            <div class="phase-card active">
                <div class="phase-title">
                    <span class="phase-number">1</span>
                    ë°ì´í„°ì…‹ êµ¬ì¶•
                </div>
                <p>ì‹¤í—˜êµ°(ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„ ë””ìì¸)ê³¼ ëŒ€ì¡°êµ°(ë°”ë¡œí¬ ë“± í™”ë ¤í•œ ìŠ¤íƒ€ì¼)ì˜ ì´ë¯¸ì§€ë¥¼ ì²´ê³„ì ìœ¼ë¡œ ìˆ˜ì§‘í•˜ì—¬ ë¹„êµ ë¶„ì„ì„ ìœ„í•œ ë°ì´í„°ë² ì´ìŠ¤ë¥¼ êµ¬ì¶•í•©ë‹ˆë‹¤.</p>
            </div>
            <div class="phase-card">
                <div class="phase-title">
                    <span class="phase-number">2</span>
                    ì •ëŸ‰ì  ë¶„ì„
                </div>
                <p>ìƒ‰ìƒ(ì±„ë„, ëª…ë„, ë‹¤ì–‘ì„±), ê³µê°„(ì—¬ë°± ë¹„ìœ¨), ë³µì¡ì„±(ì—£ì§€ ë°€ë„) ë“±ì˜ ê°ê´€ì  ì§€í‘œë¥¼ í†µí•´ ë””ìì¸ íŠ¹ì„±ì„ ìˆ˜ì¹˜í™”í•©ë‹ˆë‹¤.</p>
            </div>
            <div class="phase-card">
                <div class="phase-title">
                    <span class="phase-number">3</span>
                    í†µê³„ì  ê²€ì¦
                </div>
                <p>t-testë¥¼ í†µí•´ ë‘ ê·¸ë£¹ ê°„ì˜ ì°¨ì´ê°€ í†µê³„ì ìœ¼ë¡œ ìœ ì˜ë¯¸í•œì§€ ê²€ì¦í•˜ì—¬ ê°€ì„¤ì˜ íƒ€ë‹¹ì„±ì„ ê³¼í•™ì ìœ¼ë¡œ ì…ì¦í•©ë‹ˆë‹¤.</p>
            </div>
            <div class="phase-card">
                <div class="phase-title">
                    <span class="phase-number">4</span>
                    ì—°êµ¬ ë³´ê³ ì„œ
                </div>
                <p>ë¶„ì„ ê²°ê³¼ë¥¼ í•™ìˆ ì  í˜•íƒœì˜ ì—°êµ¬ ë³´ê³ ì„œë¡œ ì •ë¦¬í•˜ì—¬ ë¬¸í™”ì  ë¯¸í•™ì˜ ë°ì´í„° ê³¼í•™ì  í•´ì„ ì‚¬ë¡€ë¥¼ ì œì‹œí•©ë‹ˆë‹¤.</p>
            </div>
        </div>

        <!-- ì´ë¯¸ì§€ ì—…ë¡œë“œ ì„¹ì…˜ -->
        <div class="upload-sections">
            <div class="upload-group experimental">
                <div class="group-title">
                    <span class="group-icon">ğŸ‡¸ğŸ‡ª</span>
                    ì‹¤í—˜êµ°: ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„ ë””ìì¸
                </div>
                <div class="methodology-info">
                    <strong>ìˆ˜ì§‘ ëŒ€ìƒ:</strong> ìŠ¤ì›¨ë´ í˜„ì§€ ì¸í…Œë¦¬ì–´, ê±´ì¶•, ê³µê³µë””ìì¸, IKEA ë“± ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„ ë¸Œëœë“œ ì œí’ˆ ì´ë¯¸ì§€
                </div>
                <div class="upload-area" id="experimentalUpload">
                    <p>ğŸ“· ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„ ë””ìì¸ ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ì„¸ìš”</p>
                    <p style="font-size: 0.9rem; color: #7f8c8d; margin-top: 10px;">
                        ë“œë˜ê·¸ ì•¤ ë“œë¡­ ë˜ëŠ” í´ë¦­í•˜ì—¬ ì—¬ëŸ¬ ì´ë¯¸ì§€ ì„ íƒ
                    </p>
                    <input type="file" id="experimentalInput" multiple accept="image/*" style="display: none;">
                    <button class="upload-btn" onclick="document.getElementById('experimentalInput').click()">
                        ì´ë¯¸ì§€ ì„ íƒ
                    </button>
                    <button class="upload-btn clear" onclick="clearGroup('experimental')">
                        ì´ˆê¸°í™”
                    </button>
                </div>
                <div class="image-count">
                    <span>ì—…ë¡œë“œëœ ì´ë¯¸ì§€:</span>
                    <span class="count-badge" id="experimentalCount">0ì¥</span>
                </div>
            </div>

            <div class="upload-group control">
                <div class="group-title">
                    <span class="group-icon">ğŸ›ï¸</span>
                    ëŒ€ì¡°êµ°: ë¹„êµ ë¬¸í™”ê¶Œ ë””ìì¸
                </div>
                <div class="methodology-info">
                    <strong>ìˆ˜ì§‘ ëŒ€ìƒ:</strong> ë°”ë¡œí¬, ë¡œì½”ì½”, ë¹…í† ë¦¬ì•„ ì‹œëŒ€ ë“± í™”ë ¤í•˜ê³  ì¥ì‹ì ì¸ ì˜ˆìˆ  ì‘í’ˆ ë° ë””ìì¸ ì´ë¯¸ì§€
                </div>
                <div class="upload-area" id="controlUpload">
                    <p>ğŸ¨ í™”ë ¤í•œ ìŠ¤íƒ€ì¼ì˜ ë¹„êµ ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ì„¸ìš”</p>
                    <p style="font-size: 0.9rem; color: #7f8c8d; margin-top: 10px;">
                        ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„ ë””ìì¸ê³¼ ëŒ€ì¡°ë˜ëŠ” ë³µì¡í•˜ê³  ì¥ì‹ì ì¸ ì´ë¯¸ì§€
                    </p>
                    <input type="file" id="controlInput" multiple accept="image/*" style="display: none;">
                    <button class="upload-btn" onclick="document.getElementById('controlInput').click()">
                        ì´ë¯¸ì§€ ì„ íƒ
                    </button>
                    <button class="upload-btn clear" onclick="clearGroup('control')">
                        ì´ˆê¸°í™”
                    </button>
                </div>
                <div class="image-count">
                    <span>ì—…ë¡œë“œëœ ì´ë¯¸ì§€:</span>
                    <span class="count-badge" id="controlCount">0ì¥</span>
                </div>
            </div>
        </div>

        <!-- ë¶„ì„ ì‹¤í–‰ ì„¹ì…˜ -->
        <div class="analysis-section">
            <h3>ğŸ“Š ì •ëŸ‰ì  ë¶„ì„ ì‹¤í–‰</h3>
            <div class="warning-box">
                <strong>âš ï¸ ì—°êµ¬ ì¡°ê±´:</strong> ê° ê·¸ë£¹ë‹¹ ìµœì†Œ 10ì¥ ì´ìƒì˜ ì´ë¯¸ì§€ê°€ í•„ìš”í•©ë‹ˆë‹¤. ë” ë§ì€ ì´ë¯¸ì§€ì¼ìˆ˜ë¡ í†µê³„ì ìœ¼ë¡œ ì‹ ë¢°ì„± ìˆëŠ” ê²°ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
            </div>
            
            <div class="analysis-controls">
                <button class="analyze-btn" id="analyzeBtn" onclick="startAnalysis()" disabled>
                    ğŸ”¬ ë¶„ì„ ì‹œì‘
                </button>
                <button class="export-btn" onclick="exportResults()" disabled id="exportBtn">
                    ğŸ“„ ê²°ê³¼ ë‚´ë³´ë‚´ê¸°
                </button>
            </div>

            <div class="progress-container" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">ë¶„ì„ ì¤€ë¹„ ì¤‘...</div>
            </div>
        </div>

        <!-- ë¶„ì„ ê²°ê³¼ ì„¹ì…˜ -->
        <div class="results-grid" id="resultsGrid" style="display: none;">
            <div class="results-card experimental">
                <h3>ğŸ‡¸ğŸ‡ª ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„ ë””ìì¸ ë¶„ì„ ê²°ê³¼</h3>
                <div class="stats-grid" id="experimentalStats">
                    <!-- í†µê³„ í•­ëª©ë“¤ì´ ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
                </div>
            </div>
            <div class="results-card control">
                <h3>ğŸ›ï¸ ë¹„êµ ë¬¸í™”ê¶Œ ë””ìì¸ ë¶„ì„ ê²°ê³¼</h3>
                <div class="stats-grid" id="controlStats">
                    <!-- í†µê³„ í•­ëª©ë“¤ì´ ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
                </div>
            </div>
        </div>

        <!-- í†µê³„ì  ê²€ì¦ ê²°ê³¼ -->
        <div class="statistical-analysis" id="statisticalAnalysis" style="display: none;">
            <h3>ğŸ“ˆ í†µê³„ì  ìœ ì˜ì„± ê²€ì¦ (t-test)</h3>
            <div class="methodology-info">
                <strong>ê²€ì¦ ë°©ë²•:</strong> ë…ë¦½í‘œë³¸ t-ê²€ì • (Independent Samples t-test)<br>
                <strong>ìœ ì˜ìˆ˜ì¤€:</strong> Î± = 0.05 (p-value < 0.05ì¼ ë•Œ í†µê³„ì ìœ¼ë¡œ ìœ ì˜ë¯¸í•¨)
            </div>
            <table class="significance-table" id="significanceTable">
                <thead>
                    <tr>
                        <th>ë¶„ì„ ì§€í‘œ</th>
                        <th>ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„ í‰ê· </th>
                        <th>ëŒ€ì¡°êµ° í‰ê· </th>
                        <th>ì°¨ì´ìœ¨ (%)</th>
                        <th>p-value</th>
                        <th>í†µê³„ì  ìœ ì˜ì„±</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- ê²°ê³¼ê°€ ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
                </tbody>
            </table>
        </div>

        <!-- ì‹œê°í™” ì°¨íŠ¸ -->
        <div class="chart-container" id="chartContainer" style="display: none;">
            <h3>ğŸ“Š ë¹„êµ ë¶„ì„ ì‹œê°í™”</h3>
            
            <!-- ì°¨íŠ¸ ìœ í˜• ì„ íƒ -->
            <div class="chart-controls">
                <div class="chart-selector">
                    <label for="chartType">ì°¨íŠ¸ ìœ í˜•:</label>
                    <select id="chartType">
                        <option value="bar">ë§‰ëŒ€ ê·¸ë˜í”„</option>
                        <option value="boxplot">ë°•ìŠ¤ í”Œë¡¯</option>
                        <option value="scatter">ì‚°ì ë„</option>
                        <option value="histogram">íˆìŠ¤í† ê·¸ë¨</option>
                        <option value="radar">ë ˆì´ë” ì°¨íŠ¸</option>
                    </select>
                </div>
                
                <div class="metric-selector" id="metricSelector" style="display: none;">
                    <label for="selectedMetric">ë¶„ì„ ì§€í‘œ:</label>
                    <select id="selectedMetric">
                        <option value="saturation">í‰ê·  ì±„ë„</option>
                        <option value="brightness">í‰ê·  ëª…ë„</option>
                        <option value="colordiversity">ìƒ‰ìƒ ë‹¤ì–‘ì„±</option>
                        <option value="negativespace">ì—¬ë°± ë¹„ìœ¨</option>
                        <option value="edgedensity">ì—£ì§€ ë°€ë„</option>
                        <option value="texturecomplexity">í…ìŠ¤ì²˜ ë³µì¡ì„±</option>
                        <option value="symmetry">ëŒ€ì¹­ì„±</option>
                    </select>
                </div>
                
                <button class="upload-btn" onclick="exportChart()">
                    ğŸ’¾ ì°¨íŠ¸ ì €ì¥
                </button>
            </div>
            
            <canvas id="comparisonChart" class="chart-canvas" width="900" height="500"></canvas>
            
            <!-- ì°¨íŠ¸ ì„¤ëª… -->
            <div class="chart-description" id="chartDescription">
                ì°¨íŠ¸ ìœ í˜•ì„ ì„ íƒí•˜ì—¬ ë°ì´í„°ë¥¼ ì‹œê°í™”í•´ë³´ì„¸ìš”.
            </div>
        </div>

        <!-- ì—°êµ¬ ë³´ê³ ì„œ -->
        <div class="research-report" id="researchReport" style="display: none;">
            <h2>ì—°êµ¬ ê²°ê³¼ ë³´ê³ ì„œ</h2>
            
            <div class="report-section">
                <h3>1. ì—°êµ¬ ëª©ì  ë° ë°©ë²•</h3>
                <p>ë³¸ ì—°êµ¬ëŠ” ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„ ë””ìì¸ì˜ í•µì‹¬ ê°œë…ì¸ 'ë¼ê³°(Lagom)'ì„ ì»´í“¨í„° ë¹„ì „ ê¸°ìˆ ì„ í†µí•´ ì •ëŸ‰í™”í•˜ê³ , íƒ€ ë¬¸í™”ê¶Œì˜ ì‹œê° ì˜ˆìˆ ê³¼ ê°ê´€ì ìœ¼ë¡œ ë¹„êµ ë¶„ì„í•˜ëŠ” ê²ƒì„ ëª©ì ìœ¼ë¡œ í•œë‹¤. ì´ë¯¸ì§€ ë¶„ì„ ì•Œê³ ë¦¬ì¦˜ì„ í™œìš©í•˜ì—¬ ìƒ‰ìƒ, ê³µê°„, ë³µì¡ì„± ë“±ì˜ ì‹œê°ì  íŠ¹ì§•ì„ ìˆ˜ì¹˜í™”í•˜ê³ , í†µê³„ì  ê²€ì¦ì„ í†µí•´ ê·¸ ì°¨ì´ì˜ ìœ ì˜ë¯¸ì„±ì„ ê²€ì¦í•˜ì˜€ë‹¤.</p>
            </div>

            <div class="report-section">
                <h3>2. ì£¼ìš” ì—°êµ¬ ê²°ê³¼</h3>
                <div id="keyFindings">
                    <!-- ì£¼ìš” ë°œê²¬ì‚¬í•­ì´ ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
                </div>
            </div>

            <div class="report-section">
                <h3>3. ê²°ë¡  ë° ì˜ì˜</h3>
                <div id="conclusions">
                    <!-- ê²°ë¡ ì´ ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
                </div>
            </div>

            <div class="export-controls">
                <button class="export-btn" onclick="exportPDF()">ğŸ“‘ PDF ë³´ê³ ì„œ ë‹¤ìš´ë¡œë“œ</button>
                <button class="export-btn" onclick="exportCSV()">ğŸ“Š ì›ì‹œ ë°ì´í„° CSV ë‹¤ìš´ë¡œë“œ</button>
                <button class="export-btn" onclick="exportChart()">ğŸ“ˆ ì°¨íŠ¸ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ</button>
            </div>
        </div>
    </div>

    <script>
        class ScandinavianDesignResearcher {
            constructor() {
                this.experimentalImages = [];
                this.controlImages = [];
                this.analysisResults = null;
                this.setupEventListeners();
            }

            setupEventListeners() {
                // ì‹¤í—˜êµ° ì´ë¯¸ì§€ ì—…ë¡œë“œ
                const experimentalInput = document.getElementById('experimentalInput');
                const experimentalUpload = document.getElementById('experimentalUpload');

                experimentalInput.addEventListener('change', (e) => {
                    this.handleImageUpload(e.target.files, 'experimental');
                });

                this.setupDragAndDrop(experimentalUpload, experimentalInput, 'experimental');

                // ëŒ€ì¡°êµ° ì´ë¯¸ì§€ ì—…ë¡œë“œ
                const controlInput = document.getElementById('controlInput');
                const controlUpload = document.getElementById('controlUpload');

                controlInput.addEventListener('change', (e) => {
                    this.handleImageUpload(e.target.files, 'control');
                });

                this.setupDragAndDrop(controlUpload, controlInput, 'control');
            }

            setupDragAndDrop(uploadArea, input, groupType) {
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });

                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });

                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    this.handleImageUpload(e.dataTransfer.files, groupType);
                });
            }

            async handleImageUpload(files, groupType) {
                const imageArray = groupType === 'experimental' ? this.experimentalImages : this.controlImages;
                
                for (const file of files) {
                    if (file.type.startsWith('image/')) {
                        try {
                            const image = await this.loadImage(file);
                            const analysisData = await this.preprocessImage(image, file.name);
                            imageArray.push(analysisData);
                        } catch (error) {
                            console.error('ì´ë¯¸ì§€ ë¡œë“œ ì˜¤ë¥˜:', error);
                        }
                    }
                }

                this.updateImageCount(groupType);
                this.checkAnalysisReady();
            }

            loadImage(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.onerror = reject;
                        img.src = e.target.result;
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            async preprocessImage(image, filename) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // í‘œì¤€ í¬ê¸°ë¡œ ì¡°ì • (512x512)
                canvas.width = 512;
                canvas.height = 512;
                ctx.drawImage(image, 0, 0, 512, 512);
                
                const imageData = ctx.getImageData(0, 0, 512, 512);
                
                return {
                    filename: filename,
                    imageData: imageData,
                    canvas: canvas
                };
            }

            updateImageCount(groupType) {
                const count = groupType === 'experimental' ? this.experimentalImages.length : this.controlImages.length;
                const countElement = document.getElementById(groupType + 'Count');
                countElement.textContent = `${count}ì¥`;
            }

            checkAnalysisReady() {
                const analyzeBtn = document.getElementById('analyzeBtn');
                const ready = this.experimentalImages.length >= 3 && this.controlImages.length >= 3;
                analyzeBtn.disabled = !ready;
            }

            async startAnalysis() {
                const progressContainer = document.getElementById('progressContainer');
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');

                progressContainer.style.display = 'block';
                
                try {
                    // 1. ì‹¤í—˜êµ° ë¶„ì„
                    progressText.textContent = 'ì‹¤í—˜êµ°(ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„) ì´ë¯¸ì§€ ë¶„ì„ ì¤‘...';
                    progressFill.style.width = '25%';
                    
                    const experimentalResults = await this.analyzeImageGroup(this.experimentalImages);
                    
                    // 2. ëŒ€ì¡°êµ° ë¶„ì„
                    progressText.textContent = 'ëŒ€ì¡°êµ°(ë¹„êµ ë¬¸í™”ê¶Œ) ì´ë¯¸ì§€ ë¶„ì„ ì¤‘...';
                    progressFill.style.width = '50%';
                    
                    const controlResults = await this.analyzeImageGroup(this.controlImages);
                    
                    // 3. í†µê³„ ë¶„ì„
                    progressText.textContent = 'í†µê³„ì  ê²€ì¦ ìˆ˜í–‰ ì¤‘...';
                    progressFill.style.width = '75%';
                    
                    const statisticalResults = this.performStatisticalAnalysis(experimentalResults, controlResults);
                    
                    // 4. ê²°ê³¼ í‘œì‹œ
                    progressText.textContent = 'ê²°ê³¼ ìƒì„± ì¤‘...';
                    progressFill.style.width = '100%';
                    
                    this.analysisResults = {
                        experimental: experimentalResults,
                        control: controlResults,
                        statistical: statisticalResults
                    };
                    
                    this.displayResults();
                    
                    progressText.textContent = 'ë¶„ì„ ì™„ë£Œ!';
                    setTimeout(() => {
                        progressContainer.style.display = 'none';
                    }, 2000);
                    
                } catch (error) {
                    console.error('ë¶„ì„ ì˜¤ë¥˜:', error);
                    progressText.textContent = 'ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
                }
            }

            async analyzeImageGroup(images) {
                const results = {
                    images: [],
                    aggregated: {
                        avgSaturation: 0,
                        avgBrightness: 0,
                        avgColorDiversity: 0,
                        avgNegativeSpace: 0,
                        avgEdgeDensity: 0,
                        avgTextureComplexity: 0,
                        avgSymmetry: 0
                    }
                };

                // ê° ì´ë¯¸ì§€ ë¶„ì„
                for (const imageData of images) {
                    const analysis = this.analyzeImage(imageData.imageData);
                    results.images.push({
                        filename: imageData.filename,
                        ...analysis
                    });
                }

                // í‰ê· ê°’ ê³„ì‚°
                const metrics = ['avgSaturation', 'avgBrightness', 'avgColorDiversity', 
                               'avgNegativeSpace', 'avgEdgeDensity', 'avgTextureComplexity', 'avgSymmetry'];
                
                metrics.forEach(metric => {
                    const key = metric.replace('avg', '').toLowerCase();
                    const values = results.images.map(img => img[key] || 0);
                    results.aggregated[metric] = values.reduce((sum, val) => sum + val, 0) / values.length;
                });

                return results;
            }

            analyzeImage(imageData) {
                const pixels = imageData.data;
                const width = imageData.width;
                const height = imageData.height;

                // ìƒ‰ìƒ ë¶„ì„
                const colorAnalysis = this.analyzeColors(pixels);
                
                // ê³µê°„ ë¶„ì„
                const spaceAnalysis = this.analyzeSpace(pixels, width, height);
                
                // ë³µì¡ì„± ë¶„ì„
                const complexityAnalysis = this.analyzeComplexity(pixels, width, height);

                return {
                    saturation: colorAnalysis.avgSaturation,
                    brightness: colorAnalysis.avgBrightness,
                    colordiversity: colorAnalysis.colorDiversity,
                    negativespace: spaceAnalysis.negativeSpaceRatio,
                    edgedensity: complexityAnalysis.edgeDensity,
                    texturecomplexity: complexityAnalysis.textureComplexity,
                    symmetry: spaceAnalysis.symmetryScore
                };
            }

            analyzeColors(pixels) {
                const colors = [];
                
                // í”½ì…€ ìƒ˜í”Œë§
                for (let i = 0; i < pixels.length; i += 16) {
                    const r = pixels[i];
                    const g = pixels[i + 1];
                    const b = pixels[i + 2];
                    
                    if (r !== undefined && g !== undefined && b !== undefined) {
                        colors.push([r, g, b]);
                    }
                }

                // ì£¼ìš” ìƒ‰ìƒ ì¶”ì¶œ
                const dominantColors = this.extractDominantColors(colors, 5);
                
                // HSV ë³€í™˜ ë° ë¶„ì„
                const hsvColors = dominantColors.map(color => this.rgbToHsv(color));
                
                const avgSaturation = hsvColors.reduce((sum, hsv) => sum + hsv[1], 0) / hsvColors.length;
                const avgBrightness = hsvColors.reduce((sum, hsv) => sum + hsv[2], 0) / hsvColors.length;
                const colorDiversity = this.calculateColorDiversity(dominantColors);

                return {
                    avgSaturation,
                    avgBrightness,
                    colorDiversity
                };
            }

            extractDominantColors(colors, numColors) {
                if (colors.length === 0) return [];
                
                // ê°„ë‹¨í•œ K-means êµ¬í˜„
                const centroids = [];
                for (let i = 0; i < numColors; i++) {
                    centroids.push(colors[Math.floor(Math.random() * colors.length)]);
                }
                
                for (let iter = 0; iter < 10; iter++) {
                    const clusters = Array(numColors).fill().map(() => []);
                    
                    colors.forEach(color => {
                        let minDist = Infinity;
                        let closestCentroid = 0;
                        
                        centroids.forEach((centroid, idx) => {
                            const dist = this.colorDistance(color, centroid);
                            if (dist < minDist) {
                                minDist = dist;
                                closestCentroid = idx;
                            }
                        });
                        
                        clusters[closestCentroid].push(color);
                    });
                    
                    clusters.forEach((cluster, idx) => {
                        if (cluster.length > 0) {
                            const newCentroid = [
                                cluster.reduce((sum, c) => sum + c[0], 0) / cluster.length,
                                cluster.reduce((sum, c) => sum + c[1], 0) / cluster.length,
                                cluster.reduce((sum, c) => sum + c[2], 0) / cluster.length
                            ];
                            centroids[idx] = newCentroid;
                        }
                    });
                }
                
                return centroids;
            }

            colorDistance(color1, color2) {
                return Math.sqrt(
                    Math.pow(color1[0] - color2[0], 2) +
                    Math.pow(color1[1] - color2[1], 2) +
                    Math.pow(color1[2] - color2[2], 2)
                );
            }

            rgbToHsv([r, g, b]) {
                r /= 255;
                g /= 255;
                b /= 255;
                
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const diff = max - min;
                
                let h = 0;
                let s = max === 0 ? 0 : diff / max;
                let v = max;
                
                if (diff !== 0) {
                    switch (max) {
                        case r: h = ((g - b) / diff) % 6; break;
                        case g: h = (b - r) / diff + 2; break;
                        case b: h = (r - g) / diff + 4; break;
                    }
                    h /= 6;
                }
                
                if (h < 0) h += 1;
                
                return [h, s, v];
            }

            calculateColorDiversity(colors) {
                if (colors.length <= 1) return 0;
                
                let totalDistance = 0;
                let comparisons = 0;
                
                for (let i = 0; i < colors.length; i++) {
                    for (let j = i + 1; j < colors.length; j++) {
                        totalDistance += this.colorDistance(colors[i], colors[j]);
                        comparisons++;
                    }
                }
                
                return comparisons > 0 ? (totalDistance / comparisons) / 441.67 : 0;
            }

            analyzeSpace(pixels, width, height) {
                const grayscale = this.convertToGrayscale(pixels, width, height);
                const edges = this.detectEdges(grayscale, width, height);
                
                const totalPixels = width * height;
                const edgePixels = edges.reduce((sum, pixel) => sum + (pixel > 128 ? 1 : 0), 0);
                const negativeSpaceRatio = Math.max(0, (totalPixels - edgePixels * 3) / totalPixels);
                
                const symmetryScore = this.calculateSymmetry(grayscale, width, height);
                
                return {
                    negativeSpaceRatio,
                    symmetryScore
                };
            }

            convertToGrayscale(pixels, width, height) {
                const grayscale = [];
                for (let i = 0; i < pixels.length; i += 4) {
                    const gray = pixels[i] * 0.299 + pixels[i + 1] * 0.587 + pixels[i + 2] * 0.114;
                    grayscale.push(gray);
                }
                return grayscale;
            }

            detectEdges(grayscale, width, height) {
                const edges = new Array(grayscale.length).fill(0);
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = y * width + x;
                        
                        const gx = (
                            grayscale[idx - width - 1] * -1 + grayscale[idx - width + 1] * 1 +
                            grayscale[idx - 1] * -2 + grayscale[idx + 1] * 2 +
                            grayscale[idx + width - 1] * -1 + grayscale[idx + width + 1] * 1
                        );
                        
                        const gy = (
                            grayscale[idx - width - 1] * -1 + grayscale[idx - width] * -2 + grayscale[idx - width + 1] * -1 +
                            grayscale[idx + width - 1] * 1 + grayscale[idx + width] * 2 + grayscale[idx + width + 1] * 1
                        );
                        
                        edges[idx] = Math.sqrt(gx * gx + gy * gy);
                    }
                }
                
                return edges;
            }

            calculateSymmetry(grayscale, width, height) {
                const halfWidth = Math.floor(width / 2);
                let totalDiff = 0;
                let comparisons = 0;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < halfWidth; x++) {
                        const leftIdx = y * width + x;
                        const rightIdx = y * width + (width - 1 - x);
                        
                        if (leftIdx < grayscale.length && rightIdx < grayscale.length) {
                            totalDiff += Math.abs(grayscale[leftIdx] - grayscale[rightIdx]);
                            comparisons++;
                        }
                    }
                }
                
                return comparisons > 0 ? 1 - (totalDiff / comparisons) / 255 : 0;
            }

            analyzeComplexity(pixels, width, height) {
                const grayscale = this.convertToGrayscale(pixels, width, height);
                const edges = this.detectEdges(grayscale, width, height);
                
                const totalPixels = edges.length;
                const edgePixels = edges.reduce((sum, pixel) => sum + (pixel > 50 ? 1 : 0), 0);
                const edgeDensity = edgePixels / totalPixels;
                
                const mean = grayscale.reduce((sum, val) => sum + val, 0) / grayscale.length;
                const variance = grayscale.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / grayscale.length;
                const textureComplexity = Math.sqrt(variance) / 255;
                
                return {
                    edgeDensity,
                    textureComplexity
                };
            }

            performStatisticalAnalysis(experimentalResults, controlResults) {
                const metrics = ['avgSaturation', 'avgBrightness', 'avgColorDiversity', 
                               'avgNegativeSpace', 'avgEdgeDensity', 'avgTextureComplexity', 'avgSymmetry'];
                
                const results = {};
                
                metrics.forEach(metric => {
                    const expData = experimentalResults.images.map(img => {
                        const key = metric.replace('avg', '').toLowerCase();
                        return img[key] || 0;
                    });
                    
                    const ctrlData = controlResults.images.map(img => {
                        const key = metric.replace('avg', '').toLowerCase();
                        return img[key] || 0;
                    });
                    
                    const expMean = expData.reduce((sum, val) => sum + val, 0) / expData.length;
                    const ctrlMean = ctrlData.reduce((sum, val) => sum + val, 0) / ctrlData.length;
                    
                    const ttest = this.performTTest(expData, ctrlData);
                    
                    results[metric] = {
                        experimentalMean: expMean,
                        controlMean: ctrlMean,
                        difference: ((expMean - ctrlMean) / ctrlMean) * 100,
                        tStatistic: ttest.tStat,
                        pValue: ttest.pValue,
                        significant: ttest.pValue < 0.05
                    };
                });
                
                return results;
            }

            performTTest(group1, group2) {
                const n1 = group1.length;
                const n2 = group2.length;
                
                const mean1 = group1.reduce((sum, val) => sum + val, 0) / n1;
                const mean2 = group2.reduce((sum, val) => sum + val, 0) / n2;
                
                const var1 = group1.reduce((sum, val) => sum + Math.pow(val - mean1, 2), 0) / (n1 - 1);
                const var2 = group2.reduce((sum, val) => sum + Math.pow(val - mean2, 2), 0) / (n2 - 1);
                
                const pooledVar = ((n1 - 1) * var1 + (n2 - 1) * var2) / (n1 + n2 - 2);
                const standardError = Math.sqrt(pooledVar * (1/n1 + 1/n2));
                
                const tStat = (mean1 - mean2) / standardError;
                
                // ê°„ë‹¨í•œ p-value ì¶”ì • (ì •í™•í•œ ê³„ì‚°ì„ ìœ„í•´ì„œëŠ” t-ë¶„í¬ í…Œì´ë¸” í•„ìš”)
                const df = n1 + n2 - 2;
                let pValue;
                
                if (Math.abs(tStat) > 2.576) pValue = 0.01;
                else if (Math.abs(tStat) > 1.96) pValue = 0.05;
                else if (Math.abs(tStat) > 1.645) pValue = 0.10;
                else pValue = 0.20;
                
                return { tStat, pValue };
            }

            displayResults() {
                this.displayGroupStats();
                this.displayStatisticalSignificance();
                this.generateResearchReport();
                
                // ì§ì ‘ ì°¨íŠ¸ ê·¸ë¦¬ê¸°
                this.drawChart();
                
                document.getElementById('resultsGrid').style.display = 'grid';
                document.getElementById('statisticalAnalysis').style.display = 'block';
                document.getElementById('chartContainer').style.display = 'block';
                document.getElementById('researchReport').style.display = 'block';
                document.getElementById('exportBtn').disabled = false;
            }

            drawChart() {
                const canvas = document.getElementById('comparisonChart');
                const ctx = canvas ? canvas.getContext('2d') : null;
                
                if (!canvas || !ctx) {
                    console.error('ìº”ë²„ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                    return;
                }
                
                console.log('ì°¨íŠ¸ ê·¸ë¦¬ê¸° ì‹œì‘');
                
                // ì°¨íŠ¸ ì»¨íŠ¸ë¡¤ ì„¤ì •
                this.setupSimpleChartControls();
                
                // ê¸°ë³¸ ë§‰ëŒ€ ì°¨íŠ¸ ê·¸ë¦¬ê¸°
                this.updateSimpleChart();
            }

            setupSimpleChartControls() {
                const chartTypeSelect = document.getElementById('chartType');
                
                if (chartTypeSelect) {
                    // ê¸°ì¡´ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
                    chartTypeSelect.onchange = null;
                    
                    // ìƒˆ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
                    chartTypeSelect.addEventListener('change', () => {
                        this.updateSimpleChart();
                    });
                    
                    console.log('ì°¨íŠ¸ ì»¨íŠ¸ë¡¤ ì„¤ì • ì™„ë£Œ');
                }
            }

            updateSimpleChart() {
                const chartType = document.getElementById('chartType')?.value || 'bar';
                const canvas = document.getElementById('comparisonChart');
                const ctx = canvas ? canvas.getContext('2d') : null;
                
                if (!canvas || !ctx) {
                    console.error('ìº”ë²„ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                    return;
                }
                
                // ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // ë°ì´í„° ì¤€ë¹„
                const metrics = ['ì±„ë„', 'ëª…ë„', 'ìƒ‰ìƒë‹¤ì–‘ì„±', 'ì—¬ë°±ë¹„ìœ¨', 'ì—£ì§€ë°€ë„', 'í…ìŠ¤ì²˜ë³µì¡ì„±', 'ëŒ€ì¹­ì„±'];
                const expData = [
                    this.analysisResults.experimental.aggregated.avgSaturation || 0,
                    this.analysisResults.experimental.aggregated.avgBrightness || 0,
                    this.analysisResults.experimental.aggregated.avgColorDiversity || 0,
                    this.analysisResults.experimental.aggregated.avgNegativeSpace || 0,
                    this.analysisResults.experimental.aggregated.avgEdgeDensity || 0,
                    this.analysisResults.experimental.aggregated.avgTextureComplexity || 0,
                    this.analysisResults.experimental.aggregated.avgSymmetry || 0
                ];
                
                const ctrlData = [
                    this.analysisResults.control.aggregated.avgSaturation || 0,
                    this.analysisResults.control.aggregated.avgBrightness || 0,
                    this.analysisResults.control.aggregated.avgColorDiversity || 0,
                    this.analysisResults.control.aggregated.avgNegativeSpace || 0,
                    this.analysisResults.control.aggregated.avgEdgeDensity || 0,
                    this.analysisResults.control.aggregated.avgTextureComplexity || 0,
                    this.analysisResults.control.aggregated.avgSymmetry || 0
                ];
                
                // ì°¨íŠ¸ íƒ€ì…ì— ë”°ë¼ ê·¸ë¦¬ê¸°
                switch(chartType) {
                    case 'bar':
                        this.drawSimpleBarChart(ctx, canvas, metrics, expData, ctrlData);
                        break;
                    case 'boxplot':
                        this.drawSimpleBoxPlot(ctx, canvas);
                        break;
                    case 'scatter':
                        this.drawSimpleScatter(ctx, canvas);
                        break;
                    case 'histogram':
                        this.drawSimpleHistogram(ctx, canvas);
                        break;
                    case 'radar':
                        this.drawSimpleRadar(ctx, canvas, metrics, expData, ctrlData);
                        break;
                    default:
                        this.drawSimpleBarChart(ctx, canvas, metrics, expData, ctrlData);
                }
            }

            drawSimpleBoxPlot(ctx, canvas) {
                // ê°œë³„ ì§€í‘œ ì„ íƒ í‘œì‹œ
                const metricSelector = document.getElementById('metricSelector');
                if (metricSelector) {
                    metricSelector.style.display = 'flex';
                }
                
                const selectedMetric = document.getElementById('selectedMetric')?.value || 'saturation';
                const metricKey = selectedMetric.replace('avg', '').toLowerCase();
                
                // ë°ì´í„° ì¶”ì¶œ
                const expValues = this.analysisResults.experimental.images.map(img => img[metricKey] || 0).filter(val => val > 0);
                const ctrlValues = this.analysisResults.control.images.map(img => img[metricKey] || 0).filter(val => val > 0);
                
                if (expValues.length === 0 || ctrlValues.length === 0) {
                    ctx.fillStyle = '#e74c3c';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('ë°ì´í„°ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤', canvas.width / 2, canvas.height / 2);
                    return;
                }
                
                // ë°•ìŠ¤í”Œë¡¯ í†µê³„ ê³„ì‚°
                const expStats = this.calculateBoxStats(expValues);
                const ctrlStats = this.calculateBoxStats(ctrlValues);
                
                const allValues = [...expValues, ...ctrlValues];
                const minVal = Math.min(...allValues);
                const maxVal = Math.max(...allValues);
                const range = maxVal - minVal;
                
                const padding = 80;
                const chartHeight = canvas.height - 2 * padding;
                const boxWidth = 80;
                const centerX1 = canvas.width / 3;
                const centerX2 = (canvas.width * 2) / 3;
                
                // ë°°ê²½
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Yì¶• ê·¸ë¦¬ê¸°
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, padding + chartHeight);
                ctx.stroke();
                
                // Yì¶• ëˆˆê¸ˆê³¼ ê²©ì
                for (let i = 0; i <= 5; i++) {
                    const y = padding + chartHeight - (chartHeight * i / 5);
                    const value = minVal + (range * i / 5);
                    
                    // ê²©ìì„ 
                    ctx.strokeStyle = '#ecf0f1';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(canvas.width - padding, y);
                    ctx.stroke();
                    
                    // ë¼ë²¨
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText(value.toFixed(3), padding - 10, y + 3);
                }
                
                // ë°•ìŠ¤í”Œë¡¯ ê·¸ë¦¬ê¸°
                this.drawSingleBoxPlot(ctx, expStats, centerX1, padding, chartHeight, minVal, range, '#27ae60', 'ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„');
                this.drawSingleBoxPlot(ctx, ctrlStats, centerX2, padding, chartHeight, minVal, range, '#e67e22', 'ë¹„êµ ë¬¸í™”ê¶Œ');
                
                // ì œëª©
                const metricNames = {
                    'saturation': 'í‰ê·  ì±„ë„',
                    'brightness': 'í‰ê·  ëª…ë„',
                    'colordiversity': 'ìƒ‰ìƒ ë‹¤ì–‘ì„±',
                    'negativespace': 'ì—¬ë°± ë¹„ìœ¨',
                    'edgedensity': 'ì—£ì§€ ë°€ë„',
                    'texturecomplexity': 'í…ìŠ¤ì²˜ ë³µì¡ì„±',
                    'symmetry': 'ëŒ€ì¹­ì„±'
                };
                
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${metricNames[metricKey]} ë°•ìŠ¤í”Œë¡¯ ë¹„êµ`, canvas.width / 2, 30);
                
                // ì„¤ëª… ì—…ë°ì´íŠ¸
                const descElement = document.getElementById('chartDescription');
                if (descElement) {
                    descElement.textContent = 'ë°•ìŠ¤ í”Œë¡¯: ë°ì´í„°ì˜ ë¶„í¬ì™€ ì´ìƒì¹˜ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤. ìƒìëŠ” 1ì‚¬ë¶„ìœ„ìˆ˜ì—ì„œ 3ì‚¬ë¶„ìœ„ìˆ˜ê¹Œì§€ì˜ ë²”ìœ„ë¥¼, ê°€ìš´ë° ì„ ì€ ì¤‘ì•™ê°’ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.';
                }
            }

            calculateBoxStats(values) {
                const sorted = [...values].sort((a, b) => a - b);
                const n = sorted.length;
                
                if (n === 0) return null;
                
                const q1Index = Math.floor(n * 0.25);
                const medianIndex = Math.floor(n * 0.5);
                const q3Index = Math.floor(n * 0.75);
                
                const q1 = sorted[q1Index];
                const median = sorted[medianIndex];
                const q3 = sorted[q3Index];
                const iqr = q3 - q1;
                
                return {
                    min: sorted[0],
                    q1,
                    median,
                    q3,
                    max: sorted[n - 1],
                    lowerWhisker: Math.max(sorted[0], q1 - 1.5 * iqr),
                    upperWhisker: Math.min(sorted[n - 1], q3 + 1.5 * iqr),
                    outliers: sorted.filter(v => v < q1 - 1.5 * iqr || v > q3 + 1.5 * iqr)
                };
            }

            drawSingleBoxPlot(ctx, stats, centerX, startY, chartHeight, minVal, range, color, label) {
                if (!stats) return;
                
                const boxWidth = 60;
                const valueToY = (value) => startY + chartHeight - ((value - minVal) / range) * chartHeight;
                
                // ìˆ˜ì—¼ ê·¸ë¦¬ê¸°
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                
                // ìœ„ìª½ ìˆ˜ì—¼
                ctx.beginPath();
                ctx.moveTo(centerX, valueToY(stats.upperWhisker));
                ctx.lineTo(centerX, valueToY(stats.q3));
                ctx.stroke();
                
                // ì•„ë˜ìª½ ìˆ˜ì—¼
                ctx.beginPath();
                ctx.moveTo(centerX, valueToY(stats.q1));
                ctx.lineTo(centerX, valueToY(stats.lowerWhisker));
                ctx.stroke();
                
                // ìˆ˜ì—¼ ë í‘œì‹œ
                ctx.beginPath();
                ctx.moveTo(centerX - 15, valueToY(stats.upperWhisker));
                ctx.lineTo(centerX + 15, valueToY(stats.upperWhisker));
                ctx.moveTo(centerX - 15, valueToY(stats.lowerWhisker));
                ctx.lineTo(centerX + 15, valueToY(stats.lowerWhisker));
                ctx.stroke();
                
                // ë°•ìŠ¤ ê·¸ë¦¬ê¸°
                const boxY = valueToY(stats.q3);
                const boxHeight = valueToY(stats.q1) - valueToY(stats.q3);
                
                ctx.fillStyle = color + '40';
                ctx.fillRect(centerX - boxWidth/2, boxY, boxWidth, boxHeight);
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.strokeRect(centerX - boxWidth/2, boxY, boxWidth, boxHeight);
                
                // ì¤‘ì•™ê°’ ì„ 
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX - boxWidth/2, valueToY(stats.median));
                ctx.lineTo(centerX + boxWidth/2, valueToY(stats.median));
                ctx.stroke();
                
                // ì´ìƒì¹˜ í‘œì‹œ
                ctx.fillStyle = color;
                stats.outliers.forEach(outlier => {
                    ctx.beginPath();
                    ctx.arc(centerX, valueToY(outlier), 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                // ë¼ë²¨
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(label, centerX, startY + chartHeight + 30);
            }

            drawSimpleScatter(ctx, canvas) {
                // ê°œë³„ ì§€í‘œ ì„ íƒ í‘œì‹œ
                const metricSelector = document.getElementById('metricSelector');
                if (metricSelector) {
                    metricSelector.style.display = 'flex';
                }
                
                const selectedMetric = document.getElementById('selectedMetric')?.value || 'saturation';
                const metricKey = selectedMetric.replace('avg', '').toLowerCase();
                
                // ë‹¤ë¥¸ ì§€í‘œì™€ì˜ ìƒê´€ê´€ê³„ (ì—¬ë°± ë¹„ìœ¨ê³¼ ë¹„êµ)
                const correlationMetric = 'negativespace';
                
                const expDataX = this.analysisResults.experimental.images.map(img => img[metricKey] || 0);
                const expDataY = this.analysisResults.experimental.images.map(img => img[correlationMetric] || 0);
                const ctrlDataX = this.analysisResults.control.images.map(img => img[metricKey] || 0);
                const ctrlDataY = this.analysisResults.control.images.map(img => img[correlationMetric] || 0);
                
                const allX = [...expDataX, ...ctrlDataX].filter(v => v > 0);
                const allY = [...expDataY, ...ctrlDataY].filter(v => v > 0);
                
                if (allX.length === 0 || allY.length === 0) {
                    ctx.fillStyle = '#e74c3c';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('ë°ì´í„°ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤', canvas.width / 2, canvas.height / 2);
                    return;
                }
                
                const minX = Math.min(...allX);
                const maxX = Math.max(...allX);
                const minY = Math.min(...allY);
                const maxY = Math.max(...allY);
                
                const padding = 80;
                const chartWidth = canvas.width - 2 * padding;
                const chartHeight = canvas.height - 2 * padding;
                
                // ë°°ê²½
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ì¶•ê³¼ ê²©ì ê·¸ë¦¬ê¸°
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, padding + chartHeight);
                ctx.lineTo(padding + chartWidth, padding + chartHeight);
                ctx.stroke();
                
                // ê²©ì
                ctx.strokeStyle = '#ecf0f1';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 5; i++) {
                    // ì„¸ë¡œ ê²©ì
                    const x = padding + (chartWidth * i / 5);
                    ctx.beginPath();
                    ctx.moveTo(x, padding);
                    ctx.lineTo(x, padding + chartHeight);
                    ctx.stroke();
                    
                    // ê°€ë¡œ ê²©ì
                    const y = padding + (chartHeight * i / 5);
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(padding + chartWidth, y);
                    ctx.stroke();
                }
                
                // ì ë“¤ ê·¸ë¦¬ê¸°
                for (let i = 0; i < expDataX.length; i++) {
                    if (expDataX[i] > 0 && expDataY[i] > 0) {
                        const x = padding + ((expDataX[i] - minX) / (maxX - minX)) * chartWidth;
                        const y = padding + chartHeight - ((expDataY[i] - minY) / (maxY - minY)) * chartHeight;
                        
                        ctx.fillStyle = '#27ae60';
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }
                
                for (let i = 0; i < ctrlDataX.length; i++) {
                    if (ctrlDataX[i] > 0 && ctrlDataY[i] > 0) {
                        const x = padding + ((ctrlDataX[i] - minX) / (maxX - minX)) * chartWidth;
                        const y = padding + chartHeight - ((ctrlDataY[i] - minY) / (maxY - minY)) * chartHeight;
                        
                        ctx.fillStyle = '#e67e22';
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }
                
                // ì¶• ë¼ë²¨
                const metricNames = {
                    'saturation': 'í‰ê·  ì±„ë„',
                    'brightness': 'í‰ê·  ëª…ë„',
                    'colordiversity': 'ìƒ‰ìƒ ë‹¤ì–‘ì„±',
                    'negativespace': 'ì—¬ë°± ë¹„ìœ¨',
                    'edgedensity': 'ì—£ì§€ ë°€ë„',
                    'texturecomplexity': 'í…ìŠ¤ì²˜ ë³µì¡ì„±',
                    'symmetry': 'ëŒ€ì¹­ì„±'
                };
                
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(metricNames[metricKey], canvas.width/2, canvas.height - 20);
                
                ctx.save();
                ctx.translate(15, canvas.height/2);
                ctx.rotate(-Math.PI/2);
                ctx.fillText(metricNames[correlationMetric], 0, 0);
                ctx.restore();
                
                // ì œëª©
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${metricNames[metricKey]} vs ${metricNames[correlationMetric]}`, canvas.width / 2, 30);
                
                // ë²”ë¡€
                const legendY = canvas.height - 60;
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(canvas.width - 200, legendY, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„', canvas.width - 175, legendY + 12);
                
                ctx.fillStyle = '#e67e22';
                ctx.fillRect(canvas.width - 200, legendY + 20, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.fillText('ë¹„êµ ë¬¸í™”ê¶Œ', canvas.width - 175, legendY + 32);
                
                // ì„¤ëª… ì—…ë°ì´íŠ¸
                const descElement = document.getElementById('chartDescription');
                if (descElement) {
                    descElement.textContent = 'ì‚°ì ë„: ë‘ ì§€í‘œ ê°„ì˜ ìƒê´€ê´€ê³„ë¥¼ ë¶„ì„í•©ë‹ˆë‹¤. ê° ì ì€ í•˜ë‚˜ì˜ ì´ë¯¸ì§€ë¥¼ ë‚˜íƒ€ë‚´ë©°, íŒ¨í„´ì„ í†µí•´ ê´€ë ¨ì„±ì„ íŒŒì•…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.';
                }
            }

            drawSimpleHistogram(ctx, canvas) {
                // ê°œë³„ ì§€í‘œ ì„ íƒ í‘œì‹œ
                const metricSelector = document.getElementById('metricSelector');
                if (metricSelector) {
                    metricSelector.style.display = 'flex';
                }
                
                const selectedMetric = document.getElementById('selectedMetric')?.value || 'saturation';
                const metricKey = selectedMetric.replace('avg', '').toLowerCase();
                
                const expValues = this.analysisResults.experimental.images.map(img => img[metricKey] || 0).filter(val => val > 0);
                const ctrlValues = this.analysisResults.control.images.map(img => img[metricKey] || 0).filter(val => val > 0);
                
                if (expValues.length === 0 || ctrlValues.length === 0) {
                    ctx.fillStyle = '#e74c3c';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('ë°ì´í„°ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤', canvas.width / 2, canvas.height / 2);
                    return;
                }
                
                const allValues = [...expValues, ...ctrlValues];
                const minVal = Math.min(...allValues);
                const maxVal = Math.max(...allValues);
                const range = maxVal - minVal;
                const bins = 8;
                const binWidth = range / bins;
                
                // íˆìŠ¤í† ê·¸ë¨ ê³„ì‚°
                const expHist = new Array(bins).fill(0);
                const ctrlHist = new Array(bins).fill(0);
                
                expValues.forEach(value => {
                    const binIndex = Math.min(Math.floor((value - minVal) / binWidth), bins - 1);
                    expHist[binIndex]++;
                });
                
                ctrlValues.forEach(value => {
                    const binIndex = Math.min(Math.floor((value - minVal) / binWidth), bins - 1);
                    ctrlHist[binIndex]++;
                });
                
                const maxCount = Math.max(...expHist, ...ctrlHist, 1);
                const padding = 80;
                const chartWidth = canvas.width - 2 * padding;
                const chartHeight = canvas.height - 2 * padding;
                const barWidth = chartWidth / bins;
                
                // ë°°ê²½
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ì¶• ê·¸ë¦¬ê¸°
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, padding + chartHeight);
                ctx.lineTo(padding + chartWidth, padding + chartHeight);
                ctx.stroke();
                
                // íˆìŠ¤í† ê·¸ë¨ ê·¸ë¦¬ê¸°
                for (let i = 0; i < bins; i++) {
                    const x = padding + i * barWidth;
                    
                    // ì‹¤í—˜êµ°
                    const expHeight = (expHist[i] / maxCount) * chartHeight;
                    ctx.fillStyle = '#27ae6080';
                    ctx.fillRect(x + 2, padding + chartHeight - expHeight, barWidth * 0.4, expHeight);
                    
                    // ëŒ€ì¡°êµ°
                    const ctrlHeight = (ctrlHist[i] / maxCount) * chartHeight;
                    ctx.fillStyle = '#e67e2280';
                    ctx.fillRect(x + barWidth * 0.5, padding + chartHeight - ctrlHeight, barWidth * 0.4, ctrlHeight);
                    
                    // Xì¶• ë¼ë²¨ (ì¼ë¶€ë§Œ)
                    if (i % 2 === 0) {
                        const binValue = minVal + i * binWidth;
                        ctx.fillStyle = '#2c3e50';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(binValue.toFixed(2), x + barWidth/2, padding + chartHeight + 20);
                    }
                }
                
                // Yì¶• ëˆˆê¸ˆ
                for (let i = 0; i <= 5; i++) {
                    const y = padding + chartHeight - (chartHeight * i / 5);
                    const count = Math.round(maxCount * i / 5);
                    
                    ctx.strokeStyle = '#ecf0f1';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(padding + chartWidth, y);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText(count.toString(), padding - 10, y + 3);
                }
                
                // ì œëª©
                const metricNames = {
                    'saturation': 'í‰ê·  ì±„ë„',
                    'brightness': 'í‰ê·  ëª…ë„',
                    'colordiversity': 'ìƒ‰ìƒ ë‹¤ì–‘ì„±',
                    'negativespace': 'ì—¬ë°± ë¹„ìœ¨',
                    'edgedensity': 'ì—£ì§€ ë°€ë„',
                    'texturecomplexity': 'í…ìŠ¤ì²˜ ë³µì¡ì„±',
                    'symmetry': 'ëŒ€ì¹­ì„±'
                };
                
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${metricNames[metricKey]} ë¶„í¬ ë¹„êµ`, canvas.width / 2, 30);
                
                // ë²”ë¡€
                const legendY = canvas.height - 60;
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(canvas.width - 200, legendY, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„', canvas.width - 175, legendY + 12);
                
                ctx.fillStyle = '#e67e22';
                ctx.fillRect(canvas.width - 200, legendY + 20, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.fillText('ë¹„êµ ë¬¸í™”ê¶Œ', canvas.width - 175, legendY + 32);
                
                // ì„¤ëª… ì—…ë°ì´íŠ¸
                const descElement = document.getElementById('chartDescription');
                if (descElement) {
                    descElement.textContent = 'íˆìŠ¤í† ê·¸ë¨: ì„ íƒí•œ ì§€í‘œì˜ ê°’ ë¶„í¬ë¥¼ ë¹„êµí•©ë‹ˆë‹¤. ë‘ ê·¸ë£¹ì˜ ë¶„í¬ íŒ¨í„´ì´ ì–´ë–»ê²Œ ë‹¤ë¥¸ì§€ ì‹œê°ì ìœ¼ë¡œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.';
                }
            }

            drawSimpleRadar(ctx, canvas, metrics, expData, ctrlData) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(canvas.width, canvas.height) / 4;
                const numMetrics = metrics.length;
                
                // ë°ì´í„° ì •ê·œí™”
                const maxValue = Math.max(...expData, ...ctrlData, 0.1);
                const normalizedExp = expData.map(val => val / maxValue);
                const normalizedCtrl = ctrlData.map(val => val / maxValue);
                
                // ê²©ì ê·¸ë¦¬ê¸°
                ctx.strokeStyle = '#ecf0f1';
                ctx.lineWidth = 1;
                
                for (let level = 0.2; level <= 1; level += 0.2) {
                    ctx.beginPath();
                    for (let i = 0; i <= numMetrics; i++) {
                        const angle = (i * 2 * Math.PI) / numMetrics - Math.PI / 2;
                        const x = centerX + Math.cos(angle) * radius * level;
                        const y = centerY + Math.sin(angle) * radius * level;
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                // ì¶• ê·¸ë¦¬ê¸°
                ctx.strokeStyle = '#bdc3c7';
                for (let i = 0; i < numMetrics; i++) {
                    const angle = (i * 2 * Math.PI) / numMetrics - Math.PI / 2;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                    
                    // ë¼ë²¨
                    const labelX = centerX + Math.cos(angle) * (radius + 25);
                    const labelY = centerY + Math.sin(angle) * (radius + 25);
                    
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(metrics[i], labelX, labelY);
                }
                
                // ì‹¤í—˜êµ° ë°ì´í„°
                ctx.strokeStyle = '#27ae60';
                ctx.fillStyle = '#27ae6040';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i <= numMetrics; i++) {
                    const dataIndex = i % numMetrics;
                    const angle = (i * 2 * Math.PI) / numMetrics - Math.PI / 2;
                    const value = normalizedExp[dataIndex];
                    const x = centerX + Math.cos(angle) * radius * value;
                    const y = centerY + Math.sin(angle) * radius * value;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                ctx.fill();
                
                // ëŒ€ì¡°êµ° ë°ì´í„°
                ctx.strokeStyle = '#e67e22';
                ctx.fillStyle = '#e67e2240';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i <= numMetrics; i++) {
                    const dataIndex = i % numMetrics;
                    const angle = (i * 2 * Math.PI) / numMetrics - Math.PI / 2;
                    const value = normalizedCtrl[dataIndex];
                    const x = centerX + Math.cos(angle) * radius * value;
                    const y = centerY + Math.sin(angle) * radius * value;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                ctx.fill();
                
                // ì œëª©
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ë ˆì´ë” ì°¨íŠ¸: ì¢…í•© ì§€í‘œ ë¹„êµ', canvas.width / 2, 30);
                
                // ë²”ë¡€
                const legendY = canvas.height - 40;
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(canvas.width - 200, legendY, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„', canvas.width - 175, legendY + 12);
                
                ctx.fillStyle = '#e67e22';
                ctx.fillRect(canvas.width - 200, legendY + 20, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.fillText('ë¹„êµ ë¬¸í™”ê¶Œ', canvas.width - 175, legendY + 32);
                
                // ì„¤ëª… ì—…ë°ì´íŠ¸
                const descElement = document.getElementById('chartDescription');
                if (descElement) {
                    descElement.textContent = 'ë ˆì´ë” ì°¨íŠ¸: ëª¨ë“  ì§€í‘œë¥¼ ì¢…í•©ì ìœ¼ë¡œ ë¹„êµí•©ë‹ˆë‹¤. ì¤‘ì‹¬ì—ì„œ ë©€ìˆ˜ë¡ ë†’ì€ ê°’ì„ ë‚˜íƒ€ë‚´ë©°, ì „ë°˜ì ì¸ íŒ¨í„´ ì°¨ì´ë¥¼ íŒŒì•…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.';
                }
            }

            drawSimpleBarChart(ctx, canvas, metrics, expData, ctrlData) {
                const padding = 80;
                const chartWidth = canvas.width - 2 * padding;
                const chartHeight = canvas.height - 2 * padding;
                const barWidth = chartWidth / (metrics.length * 2.5);
                const maxValue = Math.max(...expData, ...ctrlData, 0.1); // ìµœì†Œê°’ ë³´ì¥
                
                console.log('ì°¨íŠ¸ ê·¸ë¦¬ê¸° íŒŒë¼ë¯¸í„°:', { padding, chartWidth, chartHeight, barWidth, maxValue });
                
                // ë°°ê²½
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ì¶• ê·¸ë¦¬ê¸°
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, padding + chartHeight);
                ctx.lineTo(padding + chartWidth, padding + chartHeight);
                ctx.stroke();
                
                // ë§‰ëŒ€ ê·¸ë¦¬ê¸°
                metrics.forEach((metric, index) => {
                    const x = padding + index * barWidth * 2.5;
                    
                    // ì‹¤í—˜êµ° ë§‰ëŒ€ (ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„)
                    const expHeight = Math.max((expData[index] / maxValue) * chartHeight, 2); // ìµœì†Œ ë†’ì´
                    ctx.fillStyle = '#27ae60';
                    ctx.fillRect(x, padding + chartHeight - expHeight, barWidth, expHeight);
                    
                    // ëŒ€ì¡°êµ° ë§‰ëŒ€ (ë¹„êµ ë¬¸í™”ê¶Œ)
                    const ctrlHeight = Math.max((ctrlData[index] / maxValue) * chartHeight, 2); // ìµœì†Œ ë†’ì´
                    ctx.fillStyle = '#e67e22';
                    ctx.fillRect(x + barWidth + 5, padding + chartHeight - ctrlHeight, barWidth, ctrlHeight);
                    
                    // ê°’ í‘œì‹œ
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    
                    if (expHeight > 15) {
                        ctx.fillText(expData[index].toFixed(2), x + barWidth/2, padding + chartHeight - expHeight - 5);
                    }
                    if (ctrlHeight > 15) {
                        ctx.fillText(ctrlData[index].toFixed(2), x + barWidth + 5 + barWidth/2, padding + chartHeight - ctrlHeight - 5);
                    }
                    
                    // Xì¶• ë¼ë²¨ (íšŒì „)
                    ctx.save();
                    ctx.translate(x + barWidth, padding + chartHeight + 15);
                    ctx.rotate(-Math.PI / 6); // 30ë„ íšŒì „
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '11px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(metric, 0, 0);
                    ctx.restore();
                });
                
                // Yì¶• ëˆˆê¸ˆ ë° ë¼ë²¨
                for (let i = 0; i <= 5; i++) {
                    const y = padding + chartHeight - (chartHeight * i / 5);
                    const value = (maxValue * i / 5).toFixed(2);
                    
                    // ëˆˆê¸ˆì„ 
                    ctx.strokeStyle = '#ecf0f1';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(padding + chartWidth, y);
                    ctx.stroke();
                    
                    // ë¼ë²¨
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText(value, padding - 10, y + 3);
                }
                
                // ì œëª©
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„ vs ë¹„êµ ë¬¸í™”ê¶Œ - ì§€í‘œë³„ í‰ê· ê°’ ë¹„êµ', canvas.width / 2, 30);
                
                // ë²”ë¡€
                const legendY = canvas.height - 40;
                
                // ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(canvas.width - 200, legendY, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„', canvas.width - 175, legendY + 12);
                
                // ë¹„êµ ë¬¸í™”ê¶Œ
                ctx.fillStyle = '#e67e22';
                ctx.fillRect(canvas.width - 200, legendY + 20, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.fillText('ë¹„êµ ë¬¸í™”ê¶Œ', canvas.width - 175, legendY + 32);
                
                // ì°¨íŠ¸ ì„¤ëª… ì—…ë°ì´íŠ¸
                const descElement = document.getElementById('chartDescription');
                if (descElement) {
                    descElement.textContent = 'ë§‰ëŒ€ ê·¸ë˜í”„: ê° ì§€í‘œë³„ë¡œ ë‘ ê·¸ë£¹ì˜ í‰ê· ê°’ì„ ë¹„êµí•©ë‹ˆë‹¤. ë…¹ìƒ‰ì€ ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„ ë””ìì¸, ì£¼í™©ìƒ‰ì€ ë¹„êµ ë¬¸í™”ê¶Œì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.';
                }
                
                console.log('ì°¨íŠ¸ ê·¸ë¦¬ê¸° ì™„ë£Œ');
            }

            initializeChart() {
                // ì²« ë²ˆì§¸ ì°¨íŠ¸ ì´ˆê¸°í™” - ê¸°ë³¸ìœ¼ë¡œ ë§‰ëŒ€ ê·¸ë˜í”„
                const canvas = document.getElementById('comparisonChart');
                const ctx = canvas.getContext('2d');
                
                if (!canvas || !ctx) {
                    throw new Error('ìº”ë²„ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                }
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                this.drawBarChart(ctx, canvas);
                this.updateChartDescription('bar');
            }

            drawDefaultChart() {
                // ì˜¤ë¥˜ ë°œìƒ ì‹œ ê¸°ë³¸ ì°¨íŠ¸ ê·¸ë¦¬ê¸°
                try {
                    const canvas = document.getElementById('comparisonChart');
                    const ctx = canvas.getContext('2d');
                    
                    if (canvas && ctx) {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = '#2c3e50';
                        ctx.font = '16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('ì°¨íŠ¸ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤...', canvas.width / 2, canvas.height / 2);
                        
                        // 1ì´ˆ í›„ ê¸°ë³¸ ë§‰ëŒ€ ì°¨íŠ¸ ì‹œë„
                        setTimeout(() => {
                            try {
                                this.drawBarChart(ctx, canvas);
                                this.updateChartDescription('bar');
                            } catch (e) {
                                console.error('ê¸°ë³¸ ì°¨íŠ¸ ê·¸ë¦¬ê¸° ì‹¤íŒ¨:', e);
                            }
                        }, 1000);
                    }
                } catch (error) {
                    console.error('ê¸°ë³¸ ì°¨íŠ¸ ê·¸ë¦¬ê¸° ì˜¤ë¥˜:', error);
                }
            }

            setupChartControls() {
                const chartTypeSelect = document.getElementById('chartType');
                const metricSelect = document.getElementById('selectedMetric');
                
                if (!chartTypeSelect || !metricSelect) {
                    console.error('ì°¨íŠ¸ ì»¨íŠ¸ë¡¤ ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                    return;
                }
                
                // ê¸°ì¡´ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±° (ì¤‘ë³µ ë°©ì§€)
                chartTypeSelect.onchange = null;
                metricSelect.onchange = null;
                
                // ìƒˆ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì • - ì•ˆì „í•œ ë°©ì‹ìœ¼ë¡œ
                const updateChartSafely = () => {
                    try {
                        this.updateChart();
                    } catch (error) {
                        console.error('ì°¨íŠ¸ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:', error);
                    }
                };
                
                chartTypeSelect.addEventListener('change', updateChartSafely);
                metricSelect.addEventListener('change', updateChartSafely);
                
                console.log('ì°¨íŠ¸ ì»¨íŠ¸ë¡¤ì´ ì„±ê³µì ìœ¼ë¡œ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤.');
            }

            displayGroupStats() {
                const expStats = document.getElementById('experimentalStats');
                const ctrlStats = document.getElementById('controlStats');
                
                const metrics = [
                    { key: 'avgSaturation', label: 'í‰ê·  ì±„ë„', format: (val) => val.toFixed(3) },
                    { key: 'avgBrightness', label: 'í‰ê·  ëª…ë„', format: (val) => val.toFixed(3) },
                    { key: 'avgColorDiversity', label: 'ìƒ‰ìƒ ë‹¤ì–‘ì„±', format: (val) => val.toFixed(3) },
                    { key: 'avgNegativeSpace', label: 'ì—¬ë°± ë¹„ìœ¨', format: (val) => val.toFixed(3) },
                    { key: 'avgEdgeDensity', label: 'ì—£ì§€ ë°€ë„', format: (val) => val.toFixed(3) },
                    { key: 'avgTextureComplexity', label: 'í…ìŠ¤ì²˜ ë³µì¡ì„±', format: (val) => val.toFixed(3) },
                    { key: 'avgSymmetry', label: 'ëŒ€ì¹­ì„±', format: (val) => val.toFixed(3) }
                ];
                
                expStats.innerHTML = '';
                ctrlStats.innerHTML = '';
                
                metrics.forEach(metric => {
                    const expValue = this.analysisResults.experimental.aggregated[metric.key];
                    const ctrlValue = this.analysisResults.control.aggregated[metric.key];
                    
                    expStats.innerHTML += `
                        <div class="stat-item">
                            <div class="stat-label">${metric.label}</div>
                            <div class="stat-value">${metric.format(expValue)}</div>
                        </div>
                    `;
                    
                    ctrlStats.innerHTML += `
                        <div class="stat-item">
                            <div class="stat-label">${metric.label}</div>
                            <div class="stat-value">${metric.format(ctrlValue)}</div>
                        </div>
                    `;
                });
            }

            displayStatisticalSignificance() {
                const tableBody = document.querySelector('#significanceTable tbody');
                tableBody.innerHTML = '';
                
                const metricNames = {
                    'avgSaturation': 'í‰ê·  ì±„ë„',
                    'avgBrightness': 'í‰ê·  ëª…ë„',
                    'avgColorDiversity': 'ìƒ‰ìƒ ë‹¤ì–‘ì„±',
                    'avgNegativeSpace': 'ì—¬ë°± ë¹„ìœ¨',
                    'avgEdgeDensity': 'ì—£ì§€ ë°€ë„',
                    'avgTextureComplexity': 'í…ìŠ¤ì²˜ ë³µì¡ì„±',
                    'avgSymmetry': 'ëŒ€ì¹­ì„±'
                };
                
                Object.keys(this.analysisResults.statistical).forEach(metric => {
                    const result = this.analysisResults.statistical[metric];
                    const significanceClass = result.significant ? 'significant' : 'not-significant';
                    const significanceText = result.significant ? 'ìœ ì˜ë¯¸ âœ“' : 'ìœ ì˜ë¯¸í•˜ì§€ ì•ŠìŒ âœ—';
                    
                    tableBody.innerHTML += `
                        <tr>
                            <td>${metricNames[metric]}</td>
                            <td>${result.experimentalMean.toFixed(3)}</td>
                            <td>${result.controlMean.toFixed(3)}</td>
                            <td>${result.difference.toFixed(1)}%</td>
                            <td>${result.pValue.toFixed(3)}</td>
                            <td class="${significanceClass}">${significanceText}</td>
                        </tr>
                    `;
                });
            }

            drawComparisonChart() {
                const canvas = document.getElementById('comparisonChart');
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const metrics = ['ì±„ë„', 'ëª…ë„', 'ìƒ‰ìƒë‹¤ì–‘ì„±', 'ì—¬ë°±ë¹„ìœ¨', 'ì—£ì§€ë°€ë„', 'í…ìŠ¤ì²˜ë³µì¡ì„±', 'ëŒ€ì¹­ì„±'];
                const expData = [
                    this.analysisResults.experimental.aggregated.avgSaturation,
                    this.analysisResults.experimental.aggregated.avgBrightness,
                    this.analysisResults.experimental.aggregated.avgColorDiversity,
                    this.analysisResults.experimental.aggregated.avgNegativeSpace,
                    this.analysisResults.experimental.aggregated.avgEdgeDensity,
                    this.analysisResults.experimental.aggregated.avgTextureComplexity,
                    this.analysisResults.experimental.aggregated.avgSymmetry
                ];
                
                const ctrlData = [
                    this.analysisResults.control.aggregated.avgSaturation,
                    this.analysisResults.control.aggregated.avgBrightness,
                    this.analysisResults.control.aggregated.avgColorDiversity,
                    this.analysisResults.control.aggregated.avgNegativeSpace,
                    this.analysisResults.control.aggregated.avgEdgeDensity,
                    this.analysisResults.control.aggregated.avgTextureComplexity,
                    this.analysisResults.control.aggregated.avgSymmetry
                ];
                
                const barWidth = canvas.width / (metrics.length * 2 + 1);
                const maxValue = Math.max(...expData, ...ctrlData);
                const chartHeight = canvas.height - 80;
                
                metrics.forEach((metric, index) => {
                    const x = (index * 2 + 1) * barWidth;
                    
                    // ì‹¤í—˜êµ° ë§‰ëŒ€
                    const expHeight = (expData[index] / maxValue) * chartHeight;
                    ctx.fillStyle = '#27ae60';
                    ctx.fillRect(x, canvas.height - expHeight - 40, barWidth * 0.8, expHeight);
                    
                    // ëŒ€ì¡°êµ° ë§‰ëŒ€
                    const ctrlHeight = (ctrlData[index] / maxValue) * chartHeight;
                    ctx.fillStyle = '#e67e22';
                    ctx.fillRect(x + barWidth, canvas.height - ctrlHeight - 40, barWidth * 0.8, ctrlHeight);
                    
                    // ë¼ë²¨
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(metric, x + barWidth, canvas.height - 5);
                });
                
                // ë²”ë¡€
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(50, 20, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.font = '14px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„', 80, 32);
                
                ctx.fillStyle = '#e67e22';
                ctx.fillRect(200, 20, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.fillText('ë¹„êµ ë¬¸í™”ê¶Œ', 230, 32);
            }

            generateResearchReport() {
                const keyFindings = document.getElementById('keyFindings');
                const conclusions = document.getElementById('conclusions');
                
                // ì£¼ìš” ë°œê²¬ì‚¬í•­ ìƒì„±
                const significantFindings = [];
                Object.keys(this.analysisResults.statistical).forEach(metric => {
                    const result = this.analysisResults.statistical[metric];
                    if (result.significant) {
                        const direction = result.difference > 0 ? 'ë†’ê²Œ' : 'ë‚®ê²Œ';
                        const metricName = this.getMetricName(metric);
                        significantFindings.push(`â€¢ ${metricName}: ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„ ë””ìì¸ì´ ${Math.abs(result.difference).toFixed(1)}% ${direction} ë‚˜íƒ€ë‚¨ (p=${result.pValue.toFixed(3)})`);
                    }
                });
                
                if (significantFindings.length > 0) {
                    keyFindings.innerHTML = `
                        <p><strong>í†µê³„ì ìœ¼ë¡œ ìœ ì˜ë¯¸í•œ ì°¨ì´ê°€ ë°œê²¬ëœ ì§€í‘œ:</strong></p>
                        <ul style="margin-left: 20px; margin-top: 10px;">
                            ${significantFindings.join('<br>')}
                        </ul>
                    `;
                } else {
                    keyFindings.innerHTML = `
                        <p>ë¶„ì„ ê²°ê³¼, ë‘ ê·¸ë£¹ ê°„ì— í†µê³„ì ìœ¼ë¡œ ìœ ì˜ë¯¸í•œ ì°¨ì´ë¥¼ ë°œê²¬í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. 
                        ì´ëŠ” í‘œë³¸ í¬ê¸°ê°€ ì‘ê±°ë‚˜, ì„ íƒëœ ì´ë¯¸ì§€ì˜ íŠ¹ì„±, ë˜ëŠ” ë¶„ì„ ë°©ë²•ì˜ í•œê³„ ë•Œë¬¸ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
                    `;
                }
                
                // ê²°ë¡  ìƒì„±
                const lagomCharacteristics = this.analyzeLagomCharacteristics();
                conclusions.innerHTML = lagomCharacteristics;
            }

            getMetricName(metric) {
                const names = {
                    'avgSaturation': 'í‰ê·  ì±„ë„',
                    'avgBrightness': 'í‰ê·  ëª…ë„',
                    'avgColorDiversity': 'ìƒ‰ìƒ ë‹¤ì–‘ì„±',
                    'avgNegativeSpace': 'ì—¬ë°± ë¹„ìœ¨',
                    'avgEdgeDensity': 'ì—£ì§€ ë°€ë„',
                    'avgTextureComplexity': 'í…ìŠ¤ì²˜ ë³µì¡ì„±',
                    'avgSymmetry': 'ëŒ€ì¹­ì„±'
                };
                return names[metric] || metric;
            }

            updateChartDescription(chartType) {
                const descriptions = {
                    'bar': 'ë§‰ëŒ€ ê·¸ë˜í”„ëŠ” ë‘ ê·¸ë£¹ ê°„ì˜ í‰ê· ê°’ ì°¨ì´ë¥¼ ì§ê´€ì ìœ¼ë¡œ ë¹„êµí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê° ì§€í‘œë³„ë¡œ ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„ ë””ìì¸(ë…¹ìƒ‰)ê³¼ ë¹„êµ ë¬¸í™”ê¶Œ(ì£¼í™©ìƒ‰)ì˜ ê°’ì„ ë‚˜ë€íˆ í‘œì‹œí•©ë‹ˆë‹¤.',
                    'boxplot': 'ë°•ìŠ¤ í”Œë¡¯ì€ ë°ì´í„°ì˜ ë¶„í¬ì™€ ì´ìƒì¹˜ë¥¼ í•œëˆˆì— íŒŒì•…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìƒìëŠ” 1ì‚¬ë¶„ìœ„ìˆ˜(Q1)ì—ì„œ 3ì‚¬ë¶„ìœ„ìˆ˜(Q3)ê¹Œì§€ì˜ ë²”ìœ„ë¥¼ ë‚˜íƒ€ë‚´ë©°, ê°€ìš´ë° ì„ ì€ ì¤‘ì•™ê°’ì…ë‹ˆë‹¤.',
                    'scatter': 'ì‚°ì ë„ ë§¤íŠ¸ë¦­ìŠ¤ëŠ” ì—¬ëŸ¬ ì§€í‘œ ê°„ì˜ ìƒê´€ê´€ê³„ë¥¼ ë™ì‹œì— ë¶„ì„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ëŒ€ê°ì„ ì˜ íˆìŠ¤í† ê·¸ë¨ì€ ê° ì§€í‘œì˜ ë¶„í¬ë¥¼, ë‚˜ë¨¸ì§€ëŠ” ì§€í‘œ ê°„ ìƒê´€ê´€ê³„ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤.',
                    'histogram': 'íˆìŠ¤í† ê·¸ë¨ì€ ì„ íƒí•œ ì§€í‘œì˜ ê°’ ë¶„í¬ë¥¼ ë¹„êµí•©ë‹ˆë‹¤. ë‘ ê·¸ë£¹ì˜ ë¶„í¬ íŒ¨í„´ì´ ë‹¤ë¥¸ì§€, ê²¹ì¹˜ëŠ” êµ¬ê°„ì´ ìˆëŠ”ì§€ ë“±ì„ ì‹œê°ì ìœ¼ë¡œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                    'radar': 'ë ˆì´ë” ì°¨íŠ¸ëŠ” ëª¨ë“  ì§€í‘œë¥¼ í•˜ë‚˜ì˜ ì°¨íŠ¸ì—ì„œ ì¢…í•©ì ìœ¼ë¡œ ë¹„êµí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì¤‘ì‹¬ì—ì„œ ë©€ìˆ˜ë¡ ë†’ì€ ê°’ì„ ë‚˜íƒ€ë‚´ë©°, ë‘ ê·¸ë£¹ì˜ ì „ë°˜ì ì¸ íŒ¨í„´ ì°¨ì´ë¥¼ íŒŒì•…í•˜ê¸° ì¢‹ìŠµë‹ˆë‹¤.'
                };
                
                const descElement = document.getElementById('chartDescription');
                if (descElement) {
                    descElement.textContent = descriptions[chartType] || 'ì°¨íŠ¸ ì„¤ëª…ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
                }
            }

            drawBarChart(ctx, canvas) {
                const metrics = ['ì±„ë„', 'ëª…ë„', 'ìƒ‰ìƒë‹¤ì–‘ì„±', 'ì—¬ë°±ë¹„ìœ¨', 'ì—£ì§€ë°€ë„', 'í…ìŠ¤ì²˜ë³µì¡ì„±', 'ëŒ€ì¹­ì„±'];
                const expData = [
                    this.analysisResults.experimental.aggregated.avgSaturation,
                    this.analysisResults.experimental.aggregated.avgBrightness,
                    this.analysisResults.experimental.aggregated.avgColorDiversity,
                    this.analysisResults.experimental.aggregated.avgNegativeSpace,
                    this.analysisResults.experimental.aggregated.avgEdgeDensity,
                    this.analysisResults.experimental.aggregated.avgTextureComplexity,
                    this.analysisResults.experimental.aggregated.avgSymmetry
                ];
                
                const ctrlData = [
                    this.analysisResults.control.aggregated.avgSaturation,
                    this.analysisResults.control.aggregated.avgBrightness,
                    this.analysisResults.control.aggregated.avgColorDiversity,
                    this.analysisResults.control.aggregated.avgNegativeSpace,
                    this.analysisResults.control.aggregated.avgEdgeDensity,
                    this.analysisResults.control.aggregated.avgTextureComplexity,
                    this.analysisResults.control.aggregated.avgSymmetry
                ];
                
                const barWidth = canvas.width / (metrics.length * 2 + 1);
                const maxValue = Math.max(...expData, ...ctrlData);
                const chartHeight = canvas.height - 120;
                const startY = 80;
                
                metrics.forEach((metric, index) => {
                    const x = (index * 2 + 1) * barWidth;
                    
                    // ì‹¤í—˜êµ° ë§‰ëŒ€
                    const expHeight = (expData[index] / maxValue) * chartHeight;
                    ctx.fillStyle = '#27ae60';
                    ctx.fillRect(x, startY + chartHeight - expHeight, barWidth * 0.7, expHeight);
                    
                    // ëŒ€ì¡°êµ° ë§‰ëŒ€
                    const ctrlHeight = (ctrlData[index] / maxValue) * chartHeight;
                    ctx.fillStyle = '#e67e22';
                    ctx.fillRect(x + barWidth * 0.8, startY + chartHeight - ctrlHeight, barWidth * 0.7, ctrlHeight);
                    
                    // ê°’ í‘œì‹œ
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(expData[index].toFixed(2), x + barWidth * 0.35, startY + chartHeight - expHeight - 5);
                    ctx.fillText(ctrlData[index].toFixed(2), x + barWidth * 1.15, startY + chartHeight - ctrlHeight - 5);
                    
                    // ë¼ë²¨
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(metric, x + barWidth, canvas.height - 20);
                });
                
                // ë²”ë¡€
                this.drawLegend(ctx, canvas);
            }

            drawLegend(ctx, canvas) {
                // ë²”ë¡€
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(canvas.width - 180, canvas.height - 60, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.font = '14px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„', canvas.width - 155, canvas.height - 48);
                
                ctx.fillStyle = '#e67e22';
                ctx.fillRect(canvas.width - 180, canvas.height - 35, 20, 15);
                ctx.fillStyle = '#2c3e50';
                ctx.fillText('ë¹„êµ ë¬¸í™”ê¶Œ', canvas.width - 155, canvas.height - 23);
            }

            drawBoxPlot(ctx, canvas, metric) {
                // ë°•ìŠ¤í”Œë¡¯ êµ¬í˜„ - ê°„ë‹¨í™”ëœ ë²„ì „
                ctx.fillStyle = '#2c3e50';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${this.getMetricName(metric)} ë°•ìŠ¤í”Œë¡¯`, canvas.width / 2, canvas.height / 2);
                ctx.font = '12px Arial';
                ctx.fillText('(ë°•ìŠ¤í”Œë¡¯ êµ¬í˜„ ì¤‘)', canvas.width / 2, canvas.height / 2 + 30);
            }

            drawScatterMatrix(ctx, canvas) {
                // ì‚°ì ë„ ë§¤íŠ¸ë¦­ìŠ¤ - ê°„ë‹¨í™”ëœ ë²„ì „
                ctx.fillStyle = '#2c3e50';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ì‚°ì ë„ ë§¤íŠ¸ë¦­ìŠ¤', canvas.width / 2, canvas.height / 2);
                ctx.font = '12px Arial';
                ctx.fillText('(ì§€í‘œ ê°„ ìƒê´€ê´€ê³„ ë¶„ì„)', canvas.width / 2, canvas.height / 2 + 30);
            }

            drawHistogram(ctx, canvas, metric) {
                // íˆìŠ¤í† ê·¸ë¨ - ê°„ë‹¨í™”ëœ ë²„ì „
                ctx.fillStyle = '#2c3e50';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${this.getMetricName(metric)} ë¶„í¬`, canvas.width / 2, canvas.height / 2);
                ctx.font = '12px Arial';
                ctx.fillText('(íˆìŠ¤í† ê·¸ë¨ êµ¬í˜„ ì¤‘)', canvas.width / 2, canvas.height / 2 + 30);
            }

            drawRadarChart(ctx, canvas) {
                // ë ˆì´ë” ì°¨íŠ¸ - ê°„ë‹¨í™”ëœ ë²„ì „
                ctx.fillStyle = '#2c3e50';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ë ˆì´ë” ì°¨íŠ¸', canvas.width / 2, canvas.height / 2);
                ctx.font = '12px Arial';
                ctx.fillText('(ì¢…í•© ì§€í‘œ ë¹„êµ)', canvas.width / 2, canvas.height / 2 + 30);
            }

            analyzeLagomCharacteristics() {
                const stats = this.analysisResults.statistical;
                let conclusion = '';
                
                // ë¼ê³° íŠ¹ì„± ë¶„ì„
                const lagomIndicators = [];
                
                if (stats.avgSaturation && stats.avgSaturation.difference < 0) {
                    lagomIndicators.push('ë‚®ì€ ì±„ë„ë¥¼ í†µí•œ ì ˆì œëœ ìƒ‰ìƒ ì‚¬ìš©');
                }
                
                if (stats.avgNegativeSpace && stats.avgNegativeSpace.difference > 0) {
                    lagomIndicators.push('ì¶©ë¶„í•œ ì—¬ë°±ì„ í†µí•œ ë¯¸ë‹ˆë©€í•œ ê³µê°„ êµ¬ì„±');
                }
                
                if (stats.avgTextureComplexity && stats.avgTextureComplexity.difference < 0) {
                    lagomIndicators.push('ë‚®ì€ ë³µì¡ì„±ì„ í†µí•œ ë‹¨ìˆœí•˜ê³  ê¸°ëŠ¥ì ì¸ ë””ìì¸');
                }
                
                if (lagomIndicators.length > 0) {
                    conclusion = `
                        <p>ë³¸ ì—°êµ¬ë¥¼ í†µí•´ 'ë¼ê³°(Lagom)'ìœ¼ë¡œ ëŒ€í‘œë˜ëŠ” ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„ ë””ìì¸ì˜ íŠ¹ì„±ì´ ì •ëŸ‰ì ìœ¼ë¡œ í™•ì¸ë˜ì—ˆìŠµë‹ˆë‹¤:</p>
                        <ul style="margin-left: 20px; margin-top: 10px;">
                            ${lagomIndicators.map(indicator => `<li>${indicator}</li>`).join('')}
                        </ul>
                        <p style="margin-top: 15px;">ì´ëŸ¬í•œ ê²°ê³¼ëŠ” ì¶”ìƒì ì´ê³  ë¬¸í™”ì ì¸ ê°œë…ì¸ 'ë¼ê³°'ì´ ì‹¤ì œë¡œ ì¸¡ì • ê°€ëŠ¥í•œ ì‹œê°ì  íŠ¹ì§•ìœ¼ë¡œ êµ¬í˜„ë˜ê³  ìˆìŒì„ ì‹œì‚¬í•©ë‹ˆë‹¤. 
                        ë³¸ ì—°êµ¬ëŠ” ë¬¸í™”ì  ë¯¸í•™ì„ ë°ì´í„° ê³¼í•™ì  ì ‘ê·¼ìœ¼ë¡œ í•´ì„í•˜ëŠ” ìƒˆë¡œìš´ ìœµí•© ì—°êµ¬ ë°©ë²•ë¡ ì˜ ê°€ëŠ¥ì„±ì„ ì œì‹œí•˜ì˜€ìŠµë‹ˆë‹¤.</p>
                    `;
                } else {
                    conclusion = `
                        <p>ë³¸ ì—°êµ¬ì—ì„œëŠ” ìŠ¤ì¹¸ë””ë‚˜ë¹„ì•„ ë””ìì¸ê³¼ ë¹„êµ ë¬¸í™”ê¶Œ ê°„ì˜ ëª…í™•í•œ ì°¨ì´ë¥¼ í†µê³„ì ìœ¼ë¡œ ì…ì¦í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. 
                        ì´ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ìš”ì¸ë“¤ë¡œ ì¸í•´ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:</p>
                        <ul style="margin-left: 20px; margin-top: 10px;">
                            <li>í‘œë³¸ í¬ê¸°ì˜ í•œê³„ (ê° ê·¸ë£¹ë‹¹ ë” ë§ì€ ì´ë¯¸ì§€ í•„ìš”)</li>
                            <li>ì´ë¯¸ì§€ ì„ ì • ê¸°ì¤€ì˜ ê°œì„  í•„ìš”</li>
                            <li>ë¶„ì„ ì•Œê³ ë¦¬ì¦˜ì˜ ì •êµí™” í•„ìš”</li>
                            <li>ì¶”ê°€ì ì¸ ë¶„ì„ ì§€í‘œ ë„ì… í•„ìš”</li>
                        </ul>
                        <p style="margin-top: 15px;">í–¥í›„ ì—°êµ¬ì—ì„œëŠ” ë” í° ë°ì´í„°ì…‹ê³¼ ê°œì„ ëœ ë¶„ì„ ë°©ë²•ì„ í†µí•´ 
                        ë¼ê³°ì˜ ì‹œê°ì  íŠ¹ì„±ì„ ë”ìš± ì •í™•í•˜ê²Œ ì •ëŸ‰í™”í•  ìˆ˜ ìˆì„ ê²ƒìœ¼ë¡œ ê¸°ëŒ€ë©ë‹ˆë‹¤.</p>
                    `;
                }
                
                return conclusion;
            }
        }

        // ì „ì—­ í•¨ìˆ˜ë“¤
        function clearGroup(groupType) {
            if (groupType === 'experimental') {
                researcher.experimentalImages = [];
                document.getElementById('experimentalInput').value = '';
            } else {
                researcher.controlImages = [];
                document.getElementById('controlInput').value = '';
            }
            researcher.updateImageCount(groupType);
            researcher.checkAnalysisReady();
        }

        function startAnalysis() {
            researcher.startAnalysis();
        }

        function exportResults() {
            // CSV í˜•íƒœë¡œ ê²°ê³¼ ë‚´ë³´ë‚´ê¸°
            const data = researcher.analysisResults;
            if (!data) return;
            
            let csv = 'Group,Filename,Saturation,Brightness,ColorDiversity,NegativeSpace,EdgeDensity,TextureComplexity,Symmetry\n';
            
            data.experimental.images.forEach(img => {
                csv += `Scandinavian,${img.filename},${img.saturation},${img.brightness},${img.colordiversity},${img.negativespace},${img.edgedensity},${img.texturecomplexity},${img.symmetry}\n`;
            });
            
            data.control.images.forEach(img => {
                csv += `Comparative,${img.filename},${img.saturation},${img.brightness},${img.colordiversity},${img.negativespace},${img.edgedensity},${img.texturecomplexity},${img.symmetry}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'scandinavian_design_analysis_results.csv';
            link.click();
        }

        function exportPDF() {
            alert('PDF ë‚´ë³´ë‚´ê¸° ê¸°ëŠ¥ì€ ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” jsPDF ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ì—¬ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
        }

        function exportCSV() {
            exportResults();
        }

        function exportChart() {
            const canvas = document.getElementById('comparisonChart');
            const link = document.createElement('a');
            link.download = 'comparison_chart.png';
            link.href = canvas.toDataURL();
            link.click();
        }

        function updateChart() {
            // ì´ í•¨ìˆ˜ëŠ” ë” ì´ìƒ í•„ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. 
            // ì°¨íŠ¸ ì—…ë°ì´íŠ¸ëŠ” í´ë˜ìŠ¤ ë‚´ë¶€ì—ì„œ ì²˜ë¦¬ë©ë‹ˆë‹¤.
            console.log('ì°¨íŠ¸ ì—…ë°ì´íŠ¸ëŠ” ë¶„ì„ ì™„ë£Œ í›„ ìë™ìœ¼ë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤.');
        }

        // ì•± ì´ˆê¸°í™”
        let researcher;
        document.addEventListener('DOMContentLoaded', () => {
            researcher = new ScandinavianDesignResearcher();
        });
    </script>
</body>
</html>